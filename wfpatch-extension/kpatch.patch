From 320fb70984e3ba7b188c38923ac07dfb6cf968af Mon Sep 17 00:00:00 2001
From: Michael Fruth <michael.fruth@uni-passau.de>
Date: Wed, 10 Mar 2021 10:27:48 +0100
Subject: [PATCH 2/2] Bump to v0.9.5

Merge tag v0.9.5 from upstream (https://github.com/dynup/kpatch.git)
into WFPatch modified branch. Squashed merge commit for better
tracability of the WFPatch history/changes.

Merge conflicts resolved manually:
kpatch-build/create-diff-object.c
kpatch-build/lookup.c
---
 .github/workflows/unit.yml                    |  26 +
 .travis.yml                                   |   8 +
 Makefile                                      |   6 +-
 README.md                                     | 163 ++---
 contrib/kpatch.spec                           |  70 +-
 doc/patch-author-guide.md                     |  98 ++-
 kmod/core/core.c                              |  59 +-
 kmod/patch/Makefile                           |  17 +-
 kmod/patch/kpatch-macros.h                    |  21 +-
 kmod/patch/livepatch-patch-hook.c             | 121 ++++
 kpatch-build/Makefile                         |   6 +-
 kpatch-build/create-diff-object.c             | 596 ++++++++++--------
 kpatch-build/create-klp-module.c              |   2 +-
 kpatch-build/create-kpatch-module.c           |  17 +-
 kpatch-build/gcc-plugins/gcc-common.h         |   4 +
 kpatch-build/gcc-plugins/ppc64le-plugin.c     |  23 +-
 kpatch-build/kpatch-build                     | 342 ++++++++--
 kpatch-build/{kpatch-gcc => kpatch-cc}        |   5 +-
 kpatch-build/kpatch-elf.c                     |   6 +-
 kpatch-build/kpatch-elf.h                     |  12 +-
 kpatch-build/lookup.c                         | 191 +++---
 kpatch-build/lookup.h                         |  11 +-
 kpatch/kpatch                                 |  64 +-
 man/kpatch-build.1                            |  14 +-
 man/kpatch.1                                  |   5 +-
 test/difftree.sh                              |  19 +-
 test/integration/Makefile                     |   6 +-
 test/integration/centos-7                     |   1 +
 test/integration/centos-7/README              |   1 -
 test/integration/centos-7/data-new.patch      |  28 -
 .../centos-7/data-read-mostly.patch.disable   |  11 -
 test/integration/centos-7/fixup-section.patch |  12 -
 .../centos-7/gcc-static-local-var-6.patch     |  23 -
 .../centos-7/gcc-static-local-var.patch       |  25 -
 ...-cmdline-rebuild-SLOW-LOADED.test.disabled |   3 -
 ...eminfo-cmdline-rebuild-SLOW.patch.disabled |  37 --
 .../centos-7/module-kvm-fixup.patch           |  12 -
 .../centos-7/module-shadow.patch.disabled     |  25 -
 test/integration/centos-7/remote-setup        |  45 --
 .../centos-7/replace-section-references.patch |  12 -
 .../centos-7/special-static-2.patch           |  24 -
 test/integration/centos-8                     |   1 +
 test/integration/kpatch-test                  | 127 +++-
 test/integration/lib.sh                       |  32 +-
 .../data-new-LOADED.test                      |   0
 test/integration/linux-5.10.11/data-new.patch |  20 +
 .../gcc-static-local-var-6.patch              |  22 +
 .../linux-5.10.11/macro-callbacks.patch       | 163 +++++
 .../module-call-external.patch                |  14 +-
 test/integration/linux-5.10.11/multiple.test  |   7 +
 .../new-function.patch                        |   8 +-
 .../linux-5.10.11/new-globals.patch           |  34 +
 .../linux-5.10.11/warn-detect-FAIL.patch      |   9 +
 .../rhel-7.6/symvers-disagreement-FAIL.patch  |  51 ++
 .../rhel-7.7/symvers-disagreement-FAIL.patch  |  51 ++
 .../rhel-7.8/symvers-disagreement-FAIL.patch  |  49 ++
 .../bug-table-section.patch                   |   6 +-
 .../cmdline-string-LOADED.test                |   0
 .../cmdline-string.patch                      |   4 +-
 .../integration/rhel-7.9/data-new-LOADED.test |   3 +
 test/integration/rhel-7.9/data-new.patch      |  28 +
 .../rhel-7.9/data-read-mostly.patch.disabled  |  11 +
 test/integration/rhel-7.9/fixup-section.patch |  11 +
 .../gcc-constprop.patch                       |   6 +-
 .../{centos-7 => rhel-7.9}/gcc-isra.patch     |   6 +-
 .../gcc-mangled-3.patch                       |   6 +-
 .../gcc-static-local-var-2.patch              |   6 +-
 .../gcc-static-local-var-3.patch              |   6 +-
 .../gcc-static-local-var-4.patch              |   6 +-
 .../gcc-static-local-var-4.test               |   0
 .../gcc-static-local-var-5.patch              |   4 +-
 .../rhel-7.9/gcc-static-local-var-6.patch     |  22 +
 .../macro-callbacks.patch                     |  47 +-
 .../{centos-7 => rhel-7.9}/macro-printk.patch |  50 +-
 .../meminfo-init-FAIL.patch                   |   6 +-
 .../meminfo-init2-FAIL.patch                  |   8 +-
 .../meminfo-string-LOADED.test                |   0
 .../meminfo-string.patch                      |   8 +-
 .../rhel-7.9/module-call-external.patch       |  38 ++
 .../{centos-7 => rhel-7.9}/multiple.test      |   2 +-
 test/integration/rhel-7.9/new-function.patch  |  25 +
 .../{centos-7 => rhel-7.9}/new-globals.patch  |  12 +-
 .../parainstructions-section.patch            |   4 +-
 .../shadow-newpid-LOADED.test                 |   0
 .../shadow-newpid.patch                       |  31 +-
 .../smp-locks-section.patch                   |   4 +-
 .../special-static.patch                      |   6 +-
 .../rhel-7.9/symvers-disagreement-FAIL.patch  |  49 ++
 .../tracepoints-section.patch                 |   6 +-
 .../warn-detect-FAIL.patch                    |   4 +-
 ...t => gcc-static-local-var-4.test.disabled} |   0
 .../rhel-8.0/symvers-disagreement-FAIL.patch  |  51 ++
 test/integration/rhel-8.1/module.patch        |   2 +-
 ...est => shadow-newpid-LOADED.test.disabled} |   0
 .../rhel-8.1/symvers-disagreement-FAIL.patch  |  51 ++
 .../rhel-8.2/bug-table-section.patch          |  12 +
 .../rhel-8.2/cmdline-string-LOADED.test       |   3 +
 .../integration/rhel-8.2/cmdline-string.patch |  13 +
 .../integration/rhel-8.2/data-new-LOADED.test |   3 +
 test/integration/rhel-8.2/data-new.patch      |  20 +
 .../rhel-8.2/data-read-mostly.patch.disabled  |  13 +
 test/integration/rhel-8.2/fixup-section.patch |  11 +
 test/integration/rhel-8.2/gcc-constprop.patch |  13 +
 test/integration/rhel-8.2/gcc-isra.patch      |  11 +
 test/integration/rhel-8.2/gcc-mangled-3.patch |  13 +
 .../rhel-8.2/gcc-static-local-var-2.patch     |  13 +
 .../rhel-8.2/gcc-static-local-var-3.patch     |  19 +
 .../gcc-static-local-var-4.patch.disabled     |  24 +
 .../gcc-static-local-var-4.test.disabled      |   8 +
 .../rhel-8.2/gcc-static-local-var-5.patch     |  45 ++
 .../rhel-8.2/gcc-static-local-var-6.patch     |  22 +
 .../rhel-8.2/macro-callbacks.patch            | 155 +++++
 test/integration/rhel-8.2/macro-printk.patch  | 148 +++++
 .../rhel-8.2/meminfo-init-FAIL.patch          |  11 +
 .../rhel-8.2/meminfo-init2-FAIL.patch         |  19 +
 .../rhel-8.2/meminfo-string-LOADED.test       |   3 +
 .../integration/rhel-8.2/meminfo-string.patch |  12 +
 test/integration/rhel-8.2/module-LOADED.test  |  13 +
 test/integration/rhel-8.2/module.patch        |  85 +++
 test/integration/rhel-8.2/multiple.test       |   7 +
 test/integration/rhel-8.2/new-function.patch  |  25 +
 test/integration/rhel-8.2/new-globals.patch   |  34 +
 .../rhel-8.2/parainstructions-section.patch   |  11 +
 .../shadow-newpid-LOADED.test.disabled        |   3 +
 .../rhel-8.2/shadow-newpid.patch.disabled     |  77 +++
 .../rhel-8.2/smp-locks-section.patch          |  13 +
 .../rhel-8.2/special-static.patch.disabled    |  22 +
 .../rhel-8.2/symvers-disagreement-FAIL.patch  |  51 ++
 .../rhel-8.2/tracepoints-section.patch        |  13 +
 .../rhel-8.2/warn-detect-FAIL.patch           |   8 +
 .../rhel-8.3/bug-table-section.patch          |  12 +
 .../rhel-8.3/cmdline-string-LOADED.test       |   3 +
 .../integration/rhel-8.3/cmdline-string.patch |  13 +
 .../integration/rhel-8.3/data-new-LOADED.test |   3 +
 test/integration/rhel-8.3/data-new.patch      |  20 +
 .../rhel-8.3/data-read-mostly.patch.disabled  |  13 +
 test/integration/rhel-8.3/fixup-section.patch |  11 +
 test/integration/rhel-8.3/gcc-constprop.patch |  13 +
 test/integration/rhel-8.3/gcc-isra.patch      |  11 +
 test/integration/rhel-8.3/gcc-mangled-3.patch |  13 +
 .../rhel-8.3/gcc-static-local-var-2.patch     |  13 +
 .../rhel-8.3/gcc-static-local-var-3.patch     |  19 +
 .../gcc-static-local-var-4.patch.disabled     |  24 +
 .../gcc-static-local-var-4.test.disabled      |   8 +
 .../rhel-8.3/gcc-static-local-var-5.patch     |  45 ++
 .../rhel-8.3/gcc-static-local-var-6.patch     |  22 +
 .../rhel-8.3/macro-callbacks.patch            | 155 +++++
 test/integration/rhel-8.3/macro-printk.patch  | 148 +++++
 .../rhel-8.3/meminfo-init-FAIL.patch          |  11 +
 .../rhel-8.3/meminfo-init2-FAIL.patch         |  19 +
 .../rhel-8.3/meminfo-string-LOADED.test       |   3 +
 .../integration/rhel-8.3/meminfo-string.patch |  12 +
 test/integration/rhel-8.3/module-LOADED.test  |  13 +
 test/integration/rhel-8.3/module.patch        |  85 +++
 test/integration/rhel-8.3/multiple.test       |   7 +
 test/integration/rhel-8.3/new-function.patch  |  25 +
 test/integration/rhel-8.3/new-globals.patch   |  34 +
 .../rhel-8.3/parainstructions-section.patch   |  11 +
 .../shadow-newpid-LOADED.test.disabled        |   3 +
 .../rhel-8.3/shadow-newpid.patch.disabled     |  77 +++
 .../rhel-8.3/smp-locks-section.patch          |  13 +
 .../rhel-8.3/special-static.patch.disabled    |  22 +
 .../rhel-8.3/symvers-disagreement-FAIL.patch  |  51 ++
 .../rhel-8.3/tracepoints-section.patch        |  13 +
 .../rhel-8.3/warn-detect-FAIL.patch           |   8 +
 .../rhel-8.4/bug-table-section.patch          |  12 +
 .../rhel-8.4/cmdline-string-LOADED.test       |   3 +
 .../integration/rhel-8.4/cmdline-string.patch |  13 +
 .../integration/rhel-8.4/data-new-LOADED.test |   3 +
 test/integration/rhel-8.4/data-new.patch      |  20 +
 .../rhel-8.4/data-read-mostly.patch           |  11 +
 test/integration/rhel-8.4/fixup-section.patch |  11 +
 test/integration/rhel-8.4/gcc-constprop.patch |  13 +
 test/integration/rhel-8.4/gcc-isra.patch      |  11 +
 test/integration/rhel-8.4/gcc-mangled-3.patch |  13 +
 .../rhel-8.4/gcc-static-local-var-2.patch     |  13 +
 .../rhel-8.4/gcc-static-local-var-3.patch     |  19 +
 .../rhel-8.4/gcc-static-local-var-4.patch     |  23 +
 .../rhel-8.4/gcc-static-local-var-4.test      |   8 +
 .../rhel-8.4/gcc-static-local-var-5.patch     |  45 ++
 .../rhel-8.4/gcc-static-local-var-6.patch     |  22 +
 .../rhel-8.4/macro-callbacks.patch            | 155 +++++
 test/integration/rhel-8.4/macro-printk.patch  | 149 +++++
 .../rhel-8.4/meminfo-init-FAIL.patch          |  11 +
 .../rhel-8.4/meminfo-init2-FAIL.patch         |  19 +
 .../rhel-8.4/meminfo-string-LOADED.test       |   3 +
 .../integration/rhel-8.4/meminfo-string.patch |  12 +
 test/integration/rhel-8.4/module-LOADED.test  |  13 +
 test/integration/rhel-8.4/module.patch        |  85 +++
 test/integration/rhel-8.4/multiple.test       |   7 +
 test/integration/rhel-8.4/new-function.patch  |  25 +
 test/integration/rhel-8.4/new-globals.patch   |  34 +
 .../rhel-8.4/parainstructions-section.patch   |  11 +
 .../rhel-8.4/shadow-newpid-LOADED.test        |   3 +
 test/integration/rhel-8.4/shadow-newpid.patch |  75 +++
 .../rhel-8.4/smp-locks-section.patch          |  13 +
 .../integration/rhel-8.4/special-static.patch |  22 +
 .../rhel-8.4/symvers-disagreement-FAIL.patch  |  46 ++
 .../rhel-8.4/tracepoints-section.patch        |  13 +
 .../rhel-8.4/warn-detect-FAIL.patch           |   9 +
 test/integration/vm-integration-run           |   1 +
 test/unit/objs                                |   2 +-
 202 files changed, 5088 insertions(+), 1054 deletions(-)
 create mode 100644 .github/workflows/unit.yml
 rename kpatch-build/{kpatch-gcc => kpatch-cc} (89%)
 create mode 120000 test/integration/centos-7
 delete mode 100644 test/integration/centos-7/README
 delete mode 100644 test/integration/centos-7/data-new.patch
 delete mode 100644 test/integration/centos-7/data-read-mostly.patch.disable
 delete mode 100644 test/integration/centos-7/fixup-section.patch
 delete mode 100644 test/integration/centos-7/gcc-static-local-var-6.patch
 delete mode 100644 test/integration/centos-7/gcc-static-local-var.patch
 delete mode 100755 test/integration/centos-7/meminfo-cmdline-rebuild-SLOW-LOADED.test.disabled
 delete mode 100644 test/integration/centos-7/meminfo-cmdline-rebuild-SLOW.patch.disabled
 delete mode 100644 test/integration/centos-7/module-kvm-fixup.patch
 delete mode 100644 test/integration/centos-7/module-shadow.patch.disabled
 delete mode 100755 test/integration/centos-7/remote-setup
 delete mode 100644 test/integration/centos-7/replace-section-references.patch
 delete mode 100644 test/integration/centos-7/special-static-2.patch
 create mode 120000 test/integration/centos-8
 rename test/integration/{centos-7 => linux-5.10.11}/data-new-LOADED.test (100%)
 create mode 100644 test/integration/linux-5.10.11/data-new.patch
 create mode 100644 test/integration/linux-5.10.11/gcc-static-local-var-6.patch
 create mode 100644 test/integration/linux-5.10.11/macro-callbacks.patch
 rename test/integration/{centos-7 => linux-5.10.11}/module-call-external.patch (57%)
 create mode 100755 test/integration/linux-5.10.11/multiple.test
 rename test/integration/{centos-7 => linux-5.10.11}/new-function.patch (72%)
 create mode 100644 test/integration/linux-5.10.11/new-globals.patch
 create mode 100644 test/integration/linux-5.10.11/warn-detect-FAIL.patch
 create mode 100644 test/integration/rhel-7.6/symvers-disagreement-FAIL.patch
 create mode 100644 test/integration/rhel-7.7/symvers-disagreement-FAIL.patch
 create mode 100644 test/integration/rhel-7.8/symvers-disagreement-FAIL.patch
 rename test/integration/{centos-7 => rhel-7.9}/bug-table-section.patch (62%)
 rename test/integration/{centos-7 => rhel-7.9}/cmdline-string-LOADED.test (100%)
 rename test/integration/{centos-7 => rhel-7.9}/cmdline-string.patch (67%)
 create mode 100755 test/integration/rhel-7.9/data-new-LOADED.test
 create mode 100644 test/integration/rhel-7.9/data-new.patch
 create mode 100644 test/integration/rhel-7.9/data-read-mostly.patch.disabled
 create mode 100644 test/integration/rhel-7.9/fixup-section.patch
 rename test/integration/{centos-7 => rhel-7.9}/gcc-constprop.patch (52%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-isra.patch (56%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-mangled-3.patch (54%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-static-local-var-2.patch (61%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-static-local-var-3.patch (57%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-static-local-var-4.patch (67%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-static-local-var-4.test (100%)
 rename test/integration/{centos-7 => rhel-7.9}/gcc-static-local-var-5.patch (89%)
 create mode 100644 test/integration/rhel-7.9/gcc-static-local-var-6.patch
 rename test/integration/{centos-7 => rhel-7.9}/macro-callbacks.patch (87%)
 rename test/integration/{centos-7 => rhel-7.9}/macro-printk.patch (71%)
 rename test/integration/{centos-7 => rhel-7.9}/meminfo-init-FAIL.patch (51%)
 rename test/integration/{centos-7 => rhel-7.9}/meminfo-init2-FAIL.patch (54%)
 rename test/integration/{centos-7 => rhel-7.9}/meminfo-string-LOADED.test (100%)
 rename test/integration/{centos-7 => rhel-7.9}/meminfo-string.patch (56%)
 create mode 100644 test/integration/rhel-7.9/module-call-external.patch
 rename test/integration/{centos-7 => rhel-7.9}/multiple.test (69%)
 create mode 100644 test/integration/rhel-7.9/new-function.patch
 rename test/integration/{centos-7 => rhel-7.9}/new-globals.patch (67%)
 rename test/integration/{centos-7 => rhel-7.9}/parainstructions-section.patch (70%)
 rename test/integration/{centos-7 => rhel-7.9}/shadow-newpid-LOADED.test (100%)
 rename test/integration/{centos-7 => rhel-7.9}/shadow-newpid.patch (62%)
 rename test/integration/{centos-7 => rhel-7.9}/smp-locks-section.patch (76%)
 rename test/integration/{centos-7 => rhel-7.9}/special-static.patch (65%)
 create mode 100644 test/integration/rhel-7.9/symvers-disagreement-FAIL.patch
 rename test/integration/{centos-7 => rhel-7.9}/tracepoints-section.patch (59%)
 rename test/integration/{centos-7 => rhel-7.9}/warn-detect-FAIL.patch (52%)
 rename test/integration/rhel-8.0/{gcc-static-local-var-4.test => gcc-static-local-var-4.test.disabled} (100%)
 create mode 100644 test/integration/rhel-8.0/symvers-disagreement-FAIL.patch
 rename test/integration/rhel-8.1/{shadow-newpid-LOADED.test => shadow-newpid-LOADED.test.disabled} (100%)
 create mode 100644 test/integration/rhel-8.1/symvers-disagreement-FAIL.patch
 create mode 100644 test/integration/rhel-8.2/bug-table-section.patch
 create mode 100755 test/integration/rhel-8.2/cmdline-string-LOADED.test
 create mode 100644 test/integration/rhel-8.2/cmdline-string.patch
 create mode 100755 test/integration/rhel-8.2/data-new-LOADED.test
 create mode 100644 test/integration/rhel-8.2/data-new.patch
 create mode 100644 test/integration/rhel-8.2/data-read-mostly.patch.disabled
 create mode 100644 test/integration/rhel-8.2/fixup-section.patch
 create mode 100644 test/integration/rhel-8.2/gcc-constprop.patch
 create mode 100644 test/integration/rhel-8.2/gcc-isra.patch
 create mode 100644 test/integration/rhel-8.2/gcc-mangled-3.patch
 create mode 100644 test/integration/rhel-8.2/gcc-static-local-var-2.patch
 create mode 100644 test/integration/rhel-8.2/gcc-static-local-var-3.patch
 create mode 100644 test/integration/rhel-8.2/gcc-static-local-var-4.patch.disabled
 create mode 100755 test/integration/rhel-8.2/gcc-static-local-var-4.test.disabled
 create mode 100644 test/integration/rhel-8.2/gcc-static-local-var-5.patch
 create mode 100644 test/integration/rhel-8.2/gcc-static-local-var-6.patch
 create mode 100644 test/integration/rhel-8.2/macro-callbacks.patch
 create mode 100644 test/integration/rhel-8.2/macro-printk.patch
 create mode 100644 test/integration/rhel-8.2/meminfo-init-FAIL.patch
 create mode 100644 test/integration/rhel-8.2/meminfo-init2-FAIL.patch
 create mode 100755 test/integration/rhel-8.2/meminfo-string-LOADED.test
 create mode 100644 test/integration/rhel-8.2/meminfo-string.patch
 create mode 100755 test/integration/rhel-8.2/module-LOADED.test
 create mode 100644 test/integration/rhel-8.2/module.patch
 create mode 100755 test/integration/rhel-8.2/multiple.test
 create mode 100644 test/integration/rhel-8.2/new-function.patch
 create mode 100644 test/integration/rhel-8.2/new-globals.patch
 create mode 100644 test/integration/rhel-8.2/parainstructions-section.patch
 create mode 100755 test/integration/rhel-8.2/shadow-newpid-LOADED.test.disabled
 create mode 100644 test/integration/rhel-8.2/shadow-newpid.patch.disabled
 create mode 100644 test/integration/rhel-8.2/smp-locks-section.patch
 create mode 100644 test/integration/rhel-8.2/special-static.patch.disabled
 create mode 100644 test/integration/rhel-8.2/symvers-disagreement-FAIL.patch
 create mode 100644 test/integration/rhel-8.2/tracepoints-section.patch
 create mode 100644 test/integration/rhel-8.2/warn-detect-FAIL.patch
 create mode 100644 test/integration/rhel-8.3/bug-table-section.patch
 create mode 100755 test/integration/rhel-8.3/cmdline-string-LOADED.test
 create mode 100644 test/integration/rhel-8.3/cmdline-string.patch
 create mode 100755 test/integration/rhel-8.3/data-new-LOADED.test
 create mode 100644 test/integration/rhel-8.3/data-new.patch
 create mode 100644 test/integration/rhel-8.3/data-read-mostly.patch.disabled
 create mode 100644 test/integration/rhel-8.3/fixup-section.patch
 create mode 100644 test/integration/rhel-8.3/gcc-constprop.patch
 create mode 100644 test/integration/rhel-8.3/gcc-isra.patch
 create mode 100644 test/integration/rhel-8.3/gcc-mangled-3.patch
 create mode 100644 test/integration/rhel-8.3/gcc-static-local-var-2.patch
 create mode 100644 test/integration/rhel-8.3/gcc-static-local-var-3.patch
 create mode 100644 test/integration/rhel-8.3/gcc-static-local-var-4.patch.disabled
 create mode 100755 test/integration/rhel-8.3/gcc-static-local-var-4.test.disabled
 create mode 100644 test/integration/rhel-8.3/gcc-static-local-var-5.patch
 create mode 100644 test/integration/rhel-8.3/gcc-static-local-var-6.patch
 create mode 100644 test/integration/rhel-8.3/macro-callbacks.patch
 create mode 100644 test/integration/rhel-8.3/macro-printk.patch
 create mode 100644 test/integration/rhel-8.3/meminfo-init-FAIL.patch
 create mode 100644 test/integration/rhel-8.3/meminfo-init2-FAIL.patch
 create mode 100755 test/integration/rhel-8.3/meminfo-string-LOADED.test
 create mode 100644 test/integration/rhel-8.3/meminfo-string.patch
 create mode 100755 test/integration/rhel-8.3/module-LOADED.test
 create mode 100644 test/integration/rhel-8.3/module.patch
 create mode 100755 test/integration/rhel-8.3/multiple.test
 create mode 100644 test/integration/rhel-8.3/new-function.patch
 create mode 100644 test/integration/rhel-8.3/new-globals.patch
 create mode 100644 test/integration/rhel-8.3/parainstructions-section.patch
 create mode 100755 test/integration/rhel-8.3/shadow-newpid-LOADED.test.disabled
 create mode 100644 test/integration/rhel-8.3/shadow-newpid.patch.disabled
 create mode 100644 test/integration/rhel-8.3/smp-locks-section.patch
 create mode 100644 test/integration/rhel-8.3/special-static.patch.disabled
 create mode 100644 test/integration/rhel-8.3/symvers-disagreement-FAIL.patch
 create mode 100644 test/integration/rhel-8.3/tracepoints-section.patch
 create mode 100644 test/integration/rhel-8.3/warn-detect-FAIL.patch
 create mode 100644 test/integration/rhel-8.4/bug-table-section.patch
 create mode 100755 test/integration/rhel-8.4/cmdline-string-LOADED.test
 create mode 100644 test/integration/rhel-8.4/cmdline-string.patch
 create mode 100755 test/integration/rhel-8.4/data-new-LOADED.test
 create mode 100644 test/integration/rhel-8.4/data-new.patch
 create mode 100644 test/integration/rhel-8.4/data-read-mostly.patch
 create mode 100644 test/integration/rhel-8.4/fixup-section.patch
 create mode 100644 test/integration/rhel-8.4/gcc-constprop.patch
 create mode 100644 test/integration/rhel-8.4/gcc-isra.patch
 create mode 100644 test/integration/rhel-8.4/gcc-mangled-3.patch
 create mode 100644 test/integration/rhel-8.4/gcc-static-local-var-2.patch
 create mode 100644 test/integration/rhel-8.4/gcc-static-local-var-3.patch
 create mode 100644 test/integration/rhel-8.4/gcc-static-local-var-4.patch
 create mode 100755 test/integration/rhel-8.4/gcc-static-local-var-4.test
 create mode 100644 test/integration/rhel-8.4/gcc-static-local-var-5.patch
 create mode 100644 test/integration/rhel-8.4/gcc-static-local-var-6.patch
 create mode 100644 test/integration/rhel-8.4/macro-callbacks.patch
 create mode 100644 test/integration/rhel-8.4/macro-printk.patch
 create mode 100644 test/integration/rhel-8.4/meminfo-init-FAIL.patch
 create mode 100644 test/integration/rhel-8.4/meminfo-init2-FAIL.patch
 create mode 100755 test/integration/rhel-8.4/meminfo-string-LOADED.test
 create mode 100644 test/integration/rhel-8.4/meminfo-string.patch
 create mode 100755 test/integration/rhel-8.4/module-LOADED.test
 create mode 100644 test/integration/rhel-8.4/module.patch
 create mode 100755 test/integration/rhel-8.4/multiple.test
 create mode 100644 test/integration/rhel-8.4/new-function.patch
 create mode 100644 test/integration/rhel-8.4/new-globals.patch
 create mode 100644 test/integration/rhel-8.4/parainstructions-section.patch
 create mode 100755 test/integration/rhel-8.4/shadow-newpid-LOADED.test
 create mode 100644 test/integration/rhel-8.4/shadow-newpid.patch
 create mode 100644 test/integration/rhel-8.4/smp-locks-section.patch
 create mode 100644 test/integration/rhel-8.4/special-static.patch
 create mode 100644 test/integration/rhel-8.4/symvers-disagreement-FAIL.patch
 create mode 100644 test/integration/rhel-8.4/tracepoints-section.patch
 create mode 100644 test/integration/rhel-8.4/warn-detect-FAIL.patch

diff --git a/.github/workflows/unit.yml b/.github/workflows/unit.yml
new file mode 100644
index 0000000..fccd12a
--- /dev/null
+++ b/.github/workflows/unit.yml
@@ -0,0 +1,26 @@
+name: build and unit tests
+
+on: [push, pull_request]
+
+jobs:
+  build:
+    strategy:
+      matrix:
+        cflags: [ "", "-O2", "-O3" ]
+    runs-on: ubuntu-latest
+    env:
+      CFLAGS: ${{ matrix.cflags }}
+    steps:
+    - uses: actions/checkout@v2
+    - name: dependencies
+      run: sudo apt-get install -y libelf-dev linux-headers-$(uname -r) shellcheck elfutils
+    - name: make
+      run: make
+    - name: submodule update
+      run: git submodule update --init
+    - name: make unit
+      run: make unit
+    - name: make check
+      run: make check
+    - name: install
+      run: sudo make install
diff --git a/.travis.yml b/.travis.yml
index 1c1fda6..b7dbd7a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,6 +3,14 @@ before_install:
   - sudo apt-get -qq update
   - sudo apt-get install -y libelf-dev linux-headers-$(uname -r) shellcheck elfutils
 
+jobs:
+  include:
+    - name: "Default"
+    - name: "-O2"
+      env: CFLAGS="-O2"
+    - name: "-O3"
+      env: CFLAGS="-O3"
+
 script:
   - make
   - make unit
diff --git a/Makefile b/Makefile
index 3c0a9c6..1153492 100644
--- a/Makefile
+++ b/Makefile
@@ -62,4 +62,8 @@ vagrant-integration-quick:
 	$(MAKE) -C $(INTEGRATION_DIR) vagrant-quick
 
 check:
-	shellcheck kpatch/kpatch kpatch-build/kpatch-build kpatch-build/kpatch-gcc
+	shellcheck kpatch/kpatch kpatch-build/kpatch-build kpatch-build/kpatch-cc
+	shellcheck test/difftree.sh test/integration/kpatch-test		\
+		   test/integration/lib.sh test/integration/rebase-patches	\
+		   test/integration/test-vagrant				\
+		   test/integration/vm-integration-run
diff --git a/README.md b/README.md
index 0c9e2ce..3488a03 100644
--- a/README.md
+++ b/README.md
@@ -20,100 +20,58 @@ And a few more:
 - https://www.youtube.com/watch?v=rN0sFjrJQfU
 - https://www.youtube.com/watch?v=Mftc80KyjA4
 
+Table of contents
+=================
+
+- [Supported Architectures](#supported-architectures)
+- [Installation](#installation)
+	- [Prerequisites](#prerequisites)
+		- [Fedora, RHEL, CentOS](#fedora-rhel-centos)
+		- [Oracle Linux 7](#oracle-linux-7)
+		- [Ubuntu](#ubuntu)
+		- [Debian 9 (Stretch)](#debian-9-stretch)
+		- [Debian 8 (Jessie)](#debian-8-jessie)
+		- [Debian 7 (Lenny)](#debian-7-lenny)
+		- [Gentoo](#gentoo)
+	- [Build](#build)
+	- [Install](#install)
+- [Quick start](#quick-start)
+- [Patch Author Guide](#patch-author-guide)
+- [How it works](#how-it-works)
+	- [kpatch-build](#kpatch-build)
+	- [Patching](#patching)
+- [Limitations](#limitations)
+- [Frequently Asked Questions](#frequently-asked-questions)
+- [Get involved](#get-involved)
+- [License](#license)
+
+
+Supported Architectures
+-----------------------
+
+- [x] x86-64
+- [x] ppc64le
+- [ ] arm64
+- [ ] s390
+
 Installation
 ------------
 
 ### Prerequisites
 
-#### Fedora
-
-*NOTE: You'll need about 15GB of free disk space for the kpatch-build cache in
-`~/.kpatch` and for ccache.*
-
-Install the dependencies for compiling kpatch:
-
-```bash
-UNAME=$(uname -r)
-sudo dnf install gcc kernel-devel-${UNAME%.*} elfutils elfutils-devel
-```
-
-Install the dependencies for the "kpatch-build" command:
-
-```bash
-sudo dnf install pesign yum-utils openssl wget numactl-devel patchutils
-sudo dnf builddep kernel-${UNAME%.*}
-sudo dnf debuginfo-install kernel-${UNAME%.*}
-
-# required on ppc64le
-sudo dnf install gcc-plugin-devel
-
-# optional, but highly recommended
-sudo dnf install ccache
-ccache --max-size=5G
-```
+Before starting, see [Supported Architectures](#supported-architectures) and check if your device's architecture is supported.
 
-#### RHEL 7
+#### Fedora, RHEL, CentOS
 
 *NOTE: You'll need about 15GB of free disk space for the kpatch-build cache in
 `~/.kpatch` and for ccache.*
 
-Install the dependencies for compiling kpatch:
+Install the dependencies for compiling kpatch and running kpatch-build:
 
 ```bash
-UNAME=$(uname -r)
-sudo yum install gcc kernel-devel-${UNAME%.*} elfutils elfutils-devel
-```
-
-Install the dependencies for the "kpatch-build" command:
-
-```bash
-sudo yum-config-manager --enable rhel-7-server-optional-rpms
-sudo yum install pesign yum-utils zlib-devel \
-  binutils-devel newt-devel python-devel perl-ExtUtils-Embed \
-  audit-libs-devel numactl-devel pciutils-devel bison ncurses-devel \
-  patchutils
-
-sudo yum-builddep kernel-${UNAME%.*}
-sudo debuginfo-install kernel-${UNAME%.*}
-
-# required on ppc64le
-sudo yum install gcc-plugin-devel
-
-# optional, but highly recommended
-sudo yum install "https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm"
-sudo yum install  ccache
-sudo yum remove -y epel-release             # If you no longer want epel repos
-ccache --max-size=5G
-```
-
-#### CentOS 7
-
-*NOTE: You'll need about 15GB of free disk space for the kpatch-build cache in
-`~/.kpatch` and for ccache.*
-
-Install the dependencies for compiling kpatch:
-
-```bash
-UNAME=$(uname -r)
-sudo yum install gcc kernel-devel-${UNAME%.*} elfutils elfutils-devel
-```
-
-Install the dependencies for the "kpatch-build" command:
-
-```bash
-sudo yum install pesign yum-utils zlib-devel \
-  binutils-devel newt-devel python-devel perl-ExtUtils-Embed \
-  audit-libs audit-libs-devel numactl-devel pciutils-devel bison patchutils
-
-# enable CentOS 7 debug repo
-sudo yum-config-manager --enable debug
-
-sudo yum-builddep kernel-${UNAME%.*}
-sudo debuginfo-install kernel-${UNAME%.*}
-
-# optional, but highly recommended - enable EPEL 7
-sudo yum install ccache
-ccache --max-size=5G
+source test/integration/lib.sh
+# Will request root privileges
+kpatch_dependencies
 ```
 
 #### Oracle Linux 7
@@ -154,47 +112,16 @@ ccache --max-size=5G
 *NOTE: You'll need about 15GB of free disk space for the kpatch-build cache in
 `~/.kpatch` and for ccache.*
 
-Install the dependencies for compiling kpatch:
-
-```bash
-apt-get install make gcc libelf-dev
-```
-
-Install the dependencies for the "kpatch-build" command:
+Install the dependencies for compiling kpatch and running kpatch-build
 
 ```bash
-apt-get install dpkg-dev devscripts elfutils
-apt-get build-dep linux
-
+source test/integration/lib.sh
 # required on ppc64le
 # e.g., on Ubuntu 18.04 for gcc-7.3
 apt-get install gcc-7-plugin-dev
-
-# optional, but highly recommended
-apt-get install ccache
-ccache --max-size=5G
-```
-
-Install kernel debug symbols:
-
-```bash
-# Add ddebs repository
-codename=$(lsb_release -sc)
-sudo tee /etc/apt/sources.list.d/ddebs.list << EOF
-deb http://ddebs.ubuntu.com/ ${codename} main restricted universe multiverse
-deb http://ddebs.ubuntu.com/ ${codename}-security main restricted universe multiverse
-deb http://ddebs.ubuntu.com/ ${codename}-updates main restricted universe multiverse
-deb http://ddebs.ubuntu.com/ ${codename}-proposed main restricted universe multiverse
-EOF
-
-# add APT key
-wget -Nq http://ddebs.ubuntu.com/dbgsym-release-key.asc -O- | sudo apt-key add -
-apt-get update && apt-get install linux-image-$(uname -r)-dbgsym
+# Will request root privileges
+kpatch_dependencies
 ```
-If there are no packages published yet to the codename-security pocket, the
-apt update may report a "404 Not Found" error, as well as a complaint about
-disabling the repository by default.  This message may be ignored (see issue
-#710).
 
 #### Debian 9 (Stretch)
 
@@ -664,7 +591,7 @@ built separately.
 Get involved
 ------------
 
-If you have questions or feedback, join the #kpatch IRC channel on freenode and
+If you have questions or feedback, join the #kpatch IRC channel on [Libera](https://libera.chat) and
 say hi.  We also have a [mailing list](https://www.redhat.com/mailman/listinfo/kpatch).
 
 Contributions are very welcome.  Feel free to open issues or PRs on github.
diff --git a/contrib/kpatch.spec b/contrib/kpatch.spec
index 882d729..55fdaa5 100644
--- a/contrib/kpatch.spec
+++ b/contrib/kpatch.spec
@@ -1,6 +1,12 @@
+# needed for the kernel specific module
+%define KVER %(uname -r)
+
+# Don't build kpatch kernel module by default
+%bcond_with kpatch_mod
+
 Name: kpatch
 Summary: Dynamic kernel patching
-Version: 0.9.1
+Version: 0.9.5
 License: GPLv2
 Group: System Environment/Kernel
 URL: http://github.com/dynup/kpatch
@@ -9,11 +15,12 @@ Source0: %{name}-%{version}.tar.gz
 
 Requires: kmod bash
 BuildRequires: gcc kernel-devel elfutils elfutils-devel
+%if %{with kpatch_mod}
+BuildRequires: kernel-devel-uname-r = %{KVER}
+BuildRequires: kernel-uname-r = %{KVER}
+%endif
 BuildRoot: %(mktemp -ud %{_tmppath}/%{name}-%{version}-%{release}-XXXXXX)
 
-# needed for the kernel specific module
-%define KVER %(uname -r)
-
 %description
 kpatch is a Linux dynamic kernel patching tool which allows you to patch a
 running kernel without rebooting or restarting any processes.  It enables
@@ -47,6 +54,7 @@ having to wait for long-running tasks to complete, users to log off, or
 for scheduled reboot windows.  It gives more control over up-time without
 sacrificing security or stability.
 
+%if %{with kpatch_mod}
 %package %{KVER}
 Requires: %{name}
 Summary: Dynamic kernel patching
@@ -58,17 +66,18 @@ having to wait for long-running tasks to complete, users to log off, or
 for scheduled reboot windows.  It gives more control over up-time without
 sacrificing security or stability.
 
+%endif
 
 %prep
 %setup -q
 
 %build
-make %{_smp_mflags}
+make %{_smp_mflags} %{?with_kpatch_mod: BUILDMOD=yes KPATCH_BUILD=/lib/modules/%{KVER}/build}
 
 %install
 rm -rf %{buildroot}
 
-make install PREFIX=/%{_usr} DESTDIR=%{buildroot}
+make install PREFIX=/%{_usr} DESTDIR=%{buildroot} %{?with_kpatch_mod: BUILDMOD=yes KPATCH_BUILD=/lib/modules/%{KVER}/build}
 
 %clean
 rm -rf %{buildroot}
@@ -81,9 +90,11 @@ rm -rf %{buildroot}
 %{_usr}/lib/systemd/system/*
 %{_sysconfdir}/init/kpatch.conf
 
+%if %{with kpatch_mod}
 %files %{KVER}
 %defattr(-,root,root,-)
 %{_usr}/lib/kpatch/%{KVER}
+%endif
 
 %files build
 %defattr(-,root,root,-)
@@ -93,6 +104,53 @@ rm -rf %{buildroot}
 %{_mandir}/man1/kpatch-build.1*
 
 %changelog
+* Wed Oct 13 Artem Savkov <asavkov@redhat.com> - 0.9.5
+- openEuler support
+- kpatch-build: Do not check KLP_REPLACE for kpatch.ko-based patches
+- create-diff-object: fix use after free in kpatch-check-relocations()
+- kpatch-build: Handle error in create-klp-module
+- create-diff-object: support ppc64le relative jump labels
+- kmod/patch: clean only rebuildable objs
+- kpatch-build: save environment varibles to file
+
+* Wed Aug 25 Yannick Cote <ycote@redhat.com> - 0.9.4
+- Support for multiple source files
+- Makefile tweaks for handling non-replace kpatch building
+- Support CONFIG_PRINTK_INDEX
+- kpatch-build: set EXTRAVERSION and not localversion for RH kernels
+- Make sure section symbols exist
+- create-diff-object: Check that the section has a secsym
+- kpatch: rmmod module of the same name before loading a module
+- kpatch-build: enable option -R|--replace to build replace klp
+- kpatch: use /sys/kernel/kpatch/ to check whether core module is loaded
+- kpatch: Sync signal subcmd usage output with manpage
+- fixes for the out-of-range relocation check
+
+* Tue Apr 20 Yannick Cote <ycote@redhat.com> - 0.9.3
+- Initial support for clang compiler
+- Add support for rhel-8.4
+- rhel-8.4: workaround pahole and extended ELF sections
+- rhel-8.4: drop klp.arch support
+- Kpatch command waits for module to fully unload
+- Kpatch command informs user when signal subcommand is unnecessary
+- kpatch-build skips ppc64le vdso files
+
+* Tue Sep 8 2020 Joe Lawrence <joe.lawrence@redhat.com> - 0.9.2
+- Integration test support for rhel-{7.8,7.9,8.1,8.2}, centos-8
+- Better support for gcc child functions
+- Batch jump label errors to report all instances
+- Dynrela code cleanup
+- Remove .klp.arch and add support for jump labels in v5.8+ kernels
+- Mark ignored sections earlier to support functions missing ftrace hook
+- Minor README.md improvements
+- Add ppc64le mcount support to patched functions
+- Show additional stalled process information in kpatch script
+- Increased shellcheck coverage and fixes
+- ppc64le plugin fixes for gcc v10
+- Ignore __UNIQUE_ID_ symbol from tristate config objects
+- Don't clear dmesg during integration tests
+- Detect and report MODVERSIONS symbol version CRC changes
+
 * Wed Mar 11 2020 Yannick Cote <ycote@redhat.com> - 0.9.1
 - Handle ppc64le toc with only constants
 - Don't strip callback section symbols
diff --git a/doc/patch-author-guide.md b/doc/patch-author-guide.md
index 07b6ad3..f3dcf73 100644
--- a/doc/patch-author-guide.md
+++ b/doc/patch-author-guide.md
@@ -39,6 +39,13 @@ recommended that when patching a system which has already been patched, the
 second patch should be a cumulative upgrade which is a superset of the first
 patch.
 
+Since upstream kernel 5.1, livepatch supports a "replace" flag to help the
+management of cumulative patches. With the flag set, the kernel will load
+the cumulative patch and unload all existing patches in one transition.
+kpatch-build enables the replace flag by default. If replace behavior is
+not desired, the user can disable it with -R|--non-replace.
+
+
 Data structure changes
 ----------------------
 
@@ -548,7 +555,7 @@ Some examples:
   any new functions to the bottom of source files, using newline whitespace to
   maintain original line counts, etc. A more exact fix can be employed by
   modifying the source code that invokes `__LINE__` and hard-coding the
-  original line number in place.
+  original line number in place.  This occurred in issue #1124 for example.
 
 Removing references to static local variables
 ---------------------------------------------
@@ -774,3 +781,92 @@ excellent example and description of this problem with annotated disassembly.
 
 Adding `__attribute__((optimize("-fno-optimize-sibling-calls")))` instructs
 GCC to turn off the optimization for the given function.
+
+Exported symbol versioning
+--------------------------
+
+### Background
+
+`CONFIG_MODVERSIONS` enables an ABI check between exported kernel symbols and
+modules referencing those symbols, enforced on module load.  When building the
+kernel, preprocessor output from `gcc -E` for each source file is passed to
+scripts/genksyms.  The genksyms script recursively expands each exported symbol
+to its basic types.  A hash is generated for each symbol as it traverses back up
+the symbol tree.  The end result is a CRC for each exported function in
+the Module.symvers file and embedded in the vmlinux kernel object itself.
+
+A similar checksumming is performed when building modules: referenced exported
+symbol CRCs are stored in the moduleâ€™s `__versions` section (you can also find
+these in plain-text intermediate \*.mod.c files.)
+
+When the kernel loads a module, the symbol CRCs found in its `__versions` are
+compared to those of the kernel, if the two do not match, the kernel will refuse
+to load it:
+```
+<module>: disagrees about version of symbol <symbol>
+<module>: Unknown symbol <symbol> (err -22)
+```
+
+### Kpatch detection
+
+After building the original and patched sources, kpatch-build compares the
+newly calculated Module.symvers against the original.  Discrepancies are
+reported:
+
+```
+ERROR: Version disagreement for symbol <symbol>
+```
+
+These reports should be addressed to ensure that the resulting kpatch module
+can be loaded.
+
+#### False positives
+
+It is rare, but possible for a kpatch to introduce inadvertent symbol CRC
+changes that are not true ABI changes.  The following conditions must occur:
+
+1. The kpatch must modify the definition of an exported symbol.  For example,
+   introducing a new header file may further define an opaque data type:
+   Before the kpatch, compilation unit U from the original kernel build only
+   knew about a `struct S` declaration (not its complete type).  At the same
+   time, U contains function F, which has an interface that references S.  If
+   the kpatch adds a header file to U that now fully defines `struct S { int
+   a, b, c; }`, its symbol type graph changes, CRCs generated for F are updated,
+   but its ABI remains consistent.
+
+2. The kpatch must introduce either a change or reference to F such that it is
+   included in the resulting kpatch module.  This will force a `__version`
+   entry based on the new CRC.
+
+   Note: if a kpatch doesn't change or reference F such that it is **not**
+   included in the resulting kpatch module, the new CRC value won't be added
+   to the module's `__version` table.  However, if a future accumulative patch
+   does add a new change or reference to F, the new CRC will become a problem.
+
+#### Avoidance
+
+Kpatches should introduce new `#include` directives sparingly.  Whenever
+possible, extract the required definitions from header filers into kpatched
+compilation units directly.
+
+If additional header files or symbol definitions cannot be avoided, consider
+surrounding the offending include/definitions in an `#ifndef __GENKSYMS__`
+macro.  The genksyms script will skip over those blocks when performing its CRC
+calculations.
+
+### But what about a real ABI change?
+
+If a kpatch introduces a true ABI change, each of calling functions would
+consequently need to be updated in the kpatch module.  For unexported functions,
+this may be handled safely if the kpatch does indeed update all callers.
+However, since motivation behind `CONFIG_MODVERSIONS` is to provide basic ABI
+verification between the kernel and modules for  **exported** functions, kpatch
+cannot safely change this ABI without worrying about breaking other out-of-tree
+drivers.  Those drivers have been built against the reference kernel's original
+set of CRCs and expect the original ABI.
+
+To track down specifically what caused a symbol CRC change, tools like
+[kabi-dw](https://github.com/skozina/kabi-dw) can be employed to produce a
+detailed symbol definition report.  For a kpatch-build, kabi-dw can be modified
+to operate on .o object files (not just .ko and vmlinux files) and the
+`$CACHEDIR/tmp/{orig, patched}` directories compared.
diff --git a/kmod/core/core.c b/kmod/core/core.c
index e4c6a04..cc97ad0 100644
--- a/kmod/core/core.c
+++ b/kmod/core/core.c
@@ -377,16 +377,6 @@ static int kpatch_apply_patch(void *data)
 		return ret;
 	}
 
-	/* run any user-defined pre-patch callbacks */
-	list_for_each_entry(object, &kpmod->objects, list) {
-		ret = pre_patch_callback(object);
-		if (ret) {
-			pr_err("pre-patch callback failed!\n");
-			kpatch_state_finish(KPATCH_STATE_FAILURE);
-			goto err;
-		}
-	}
-
 	/* tentatively add the new funcs to the global func hash */
 	do_for_each_linked_func(kpmod, func) {
 		hash_add_rcu(kpatch_func_hash, &func->node, func->old_addr);
@@ -408,8 +398,7 @@ static int kpatch_apply_patch(void *data)
 			hash_del_rcu(&func->node);
 		} while_for_each_linked_func();
 
-		ret = -EBUSY;
-		goto err;
+		return -EBUSY;
 	}
 
 	/*
@@ -430,12 +419,6 @@ static int kpatch_apply_patch(void *data)
 		post_patch_callback(object);
 
 	return 0;
-err:
-	/* undo pre-patch callbacks by calling post-unpatch counterparts */
-	list_for_each_entry(object, &kpmod->objects, list)
-		post_unpatch_callback(object);
-
-	return ret;
 }
 
 /* Called from stop_machine */
@@ -468,10 +451,6 @@ static int kpatch_remove_patch(void *data)
 		hash_del_rcu(&func->node);
 	} while_for_each_linked_func();
 
-	/* run any user-defined post-unpatch callbacks */
-	list_for_each_entry(object, &kpmod->objects, list)
-		post_unpatch_callback(object);
-
 	return 0;
 
 err:
@@ -742,7 +721,7 @@ static int kpatch_write_relocations(struct kpatch_module *kpmod,
 			break;
 		case R_X86_64_64:
 			loc = dynrela->dest;
-			val = dynrela->src;
+			val = dynrela->src + dynrela->addend;
 			size = 8;
 			break;
 		default:
@@ -1086,11 +1065,30 @@ int kpatch_register(struct kpatch_module *kpmod, bool replace)
 
 	kpatch_state_updating();
 
-	/*
-	 * Idle the CPUs, verify activeness safety, and atomically make the new
-	 * functions visible to the ftrace handler.
-	 */
-	ret = stop_machine(kpatch_apply_patch, &args, NULL);
+	/* run any user-defined pre-patch callbacks */
+	list_for_each_entry(object, &kpmod->objects, list) {
+		ret = pre_patch_callback(object);
+		if(ret){
+			pr_err("pre-patch callback failed!\n");
+			kpatch_state_finish(KPATCH_STATE_FAILURE);
+			break;
+		}
+	}
+
+	/* if pre_patch_callback succeed. */
+	if (!ret) {
+		/*
+		 * Idle the CPUs, verify activeness safety, and atomically make the new
+		 * functions visible to the ftrace handler.
+		 */
+		ret = stop_machine(kpatch_apply_patch, &args, NULL);
+	}
+
+	/* if pre_patch_callback or stop_machine failed */
+	if (ret) {
+		list_for_each_entry(object, &kpmod->objects, list)
+			post_unpatch_callback(object);
+	}
 
 	/*
 	 * For the replace case, remove any obsolete funcs from the ftrace
@@ -1224,6 +1222,11 @@ int kpatch_unregister(struct kpatch_module *kpmod)
 
 	ret = stop_machine(kpatch_remove_patch, kpmod, NULL);
 
+	if (!ret) {
+		/* run any user-defined post-unpatch callbacks */
+		list_for_each_entry(object, &kpmod->objects, list)
+			post_unpatch_callback(object);
+	}
 	/* NMI handlers can return to normal now */
 	kpatch_state_idle();
 
diff --git a/kmod/patch/Makefile b/kmod/patch/Makefile
index e017b17..bb4d49c 100644
--- a/kmod/patch/Makefile
+++ b/kmod/patch/Makefile
@@ -1,18 +1,13 @@
 KPATCH_BUILD ?= /lib/modules/$(shell uname -r)/build
-KPATCH_MAKE = $(MAKE) -C $(KPATCH_BUILD) M=$(PWD)
+KPATCH_MAKE = $(MAKE) -C $(KPATCH_BUILD) M=$(PWD) CFLAGS_MODULE='$(CFLAGS_MODULE)'
 LDFLAGS += $(KPATCH_LDFLAGS)
 
-# ppc64le kernel modules are expected to compile with the
-# -mcmodel=large flag.  This enables 64-bit relocations
-# instead of a 32-bit offset from the TOC pointer.
-PROCESSOR = $(shell uname -m)
-ifeq ($(PROCESSOR), ppc64le)
-KBUILD_CFLAGS_MODULE += -mcmodel=large
-endif
+# object files that this Makefile can (re)build on its own
+BUILDABLE_OBJS=$(filter-out output.o, $(wildcard *.o))
 
 obj-m += $(KPATCH_NAME).o
 ldflags-y += -T $(src)/kpatch.lds
-extra-y := kpatch.lds
+targets += kpatch.lds
 
 $(KPATCH_NAME)-objs += patch-hook.o output.o
 
@@ -21,9 +16,11 @@ all: $(KPATCH_NAME).ko
 $(KPATCH_NAME).ko:
 	$(KPATCH_MAKE)
 
+$(obj)/$(KPATCH_NAME).o: $(src)/kpatch.lds
+
 patch-hook.o: patch-hook.c kpatch-patch-hook.c livepatch-patch-hook.c
 	$(KPATCH_MAKE) patch-hook.o
 
 clean:
-	$(RM) -Rf .*.o.cmd .*.ko.cmd .tmp_versions *.o *.ko *.mod.c \
+	$(RM) -Rf .*.o.cmd .*.ko.cmd .tmp_versions $(BUILDABLE_OBJS) *.ko *.mod.c \
 	Module.symvers
diff --git a/kmod/patch/kpatch-macros.h b/kmod/patch/kpatch-macros.h
index a60a267..caaadbc 100644
--- a/kmod/patch/kpatch-macros.h
+++ b/kmod/patch/kpatch-macros.h
@@ -5,6 +5,13 @@
 #include <linux/jiffies.h>
 #include <linux/version.h>
 
+/* upstream 33def8498fdd "treewide: Convert macro and uses of __section(foo) to __section("foo")" */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+# define __kpatch_section(section) __section(section)
+#else
+# define __kpatch_section(section) __section(#section)
+#endif
+
 /*
  * KPATCH_IGNORE_SECTION macro
  *
@@ -14,7 +21,7 @@
  * symbol to section.
  */
 #define KPATCH_IGNORE_SECTION(_sec) \
-	char *__UNIQUE_ID(kpatch_ignore_section_) __section(.kpatch.ignore.sections) = _sec;
+	char *__UNIQUE_ID(kpatch_ignore_section_) __kpatch_section(.kpatch.ignore.sections) = _sec;
 
 /*
  * KPATCH_IGNORE_FUNCTION macro
@@ -25,7 +32,7 @@
  * detected as changed when, in fact, there has been no functional change.
  */
 #define KPATCH_IGNORE_FUNCTION(_fn) \
-	void *__kpatch_ignore_func_##_fn __section(.kpatch.ignore.functions) = _fn;
+	void *__kpatch_ignore_func_##_fn __kpatch_section(.kpatch.ignore.functions) = _fn;
 
 
 /* Support for livepatch callbacks */
@@ -75,25 +82,25 @@ struct kpatch_post_unpatch_callback {
 
 #define KPATCH_PRE_PATCH_CALLBACK(_fn) \
 	static inline kpatch_pre_patch_call_t __pre_patchtest(void) { return _fn; } \
-	static struct kpatch_pre_patch_callback kpatch_pre_patch_data __section(.kpatch.callbacks.pre_patch) __used = { \
+	static struct kpatch_pre_patch_callback kpatch_pre_patch_data __kpatch_section(.kpatch.callbacks.pre_patch) __used = { \
 		.fn = _fn, \
 		.objname = NULL \
 	};
 #define KPATCH_POST_PATCH_CALLBACK(_fn) \
 	static inline kpatch_post_patch_call_t __post_patchtest(void) { return _fn; } \
-	static struct kpatch_post_patch_callback kpatch_post_patch_data __section(.kpatch.callbacks.post_patch) __used = { \
+	static struct kpatch_post_patch_callback kpatch_post_patch_data __kpatch_section(.kpatch.callbacks.post_patch) __used = { \
 		.fn = _fn, \
 		.objname = NULL \
 	};
 #define KPATCH_PRE_UNPATCH_CALLBACK(_fn) \
 	static inline kpatch_pre_unpatch_call_t __pre_unpatchtest(void) { return _fn; } \
-	static struct kpatch_pre_unpatch_callback kpatch_pre_unpatch_data __section(.kpatch.callbacks.pre_unpatch) __used = { \
+	static struct kpatch_pre_unpatch_callback kpatch_pre_unpatch_data __kpatch_section(.kpatch.callbacks.pre_unpatch) __used = { \
 		.fn = _fn, \
 		.objname = NULL \
 	};
 #define KPATCH_POST_UNPATCH_CALLBACK(_fn) \
 	static inline kpatch_post_unpatch_call_t __post_unpatchtest(void) { return _fn; } \
-	static struct kpatch_post_unpatch_callback kpatch_post_unpatch_data __section(.kpatch.callbacks.post_unpatch) __used = { \
+	static struct kpatch_post_unpatch_callback kpatch_post_unpatch_data __kpatch_section(.kpatch.callbacks.post_unpatch) __used = { \
 		.fn = _fn, \
 		.objname = NULL \
 	};
@@ -110,7 +117,7 @@ struct kpatch_post_unpatch_callback {
  * run concurrently.
  */
 #define KPATCH_FORCE_UNSAFE(_fn) \
-	void *__kpatch_force_func_##_fn __section(.kpatch.force) = _fn;
+	void *__kpatch_force_func_##_fn __kpatch_section(.kpatch.force) = _fn;
 
 /*
  * KPATCH_PRINTK macro
diff --git a/kmod/patch/livepatch-patch-hook.c b/kmod/patch/livepatch-patch-hook.c
index e12fd50..3d13ab9 100644
--- a/kmod/patch/livepatch-patch-hook.c
+++ b/kmod/patch/livepatch-patch-hook.c
@@ -74,6 +74,18 @@
 # define HAVE_SIMPLE_ENABLE
 #endif
 
+#ifdef RHEL_RELEASE_CODE
+# if RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8, 2)
+#  define HAVE_KLP_REPLACE
+# endif
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
+# define HAVE_KLP_REPLACE
+#endif
+
+#ifndef KLP_REPLACE_ENABLE
+#define KLP_REPLACE_ENABLE true
+#endif
+
 /*
  * There are quite a few similar structures at play in this file:
  * - livepatch.h structs prefixed with klp_*
@@ -92,10 +104,28 @@
  *  done, the scaffold structs are no longer needed.
  */
 
+/*
+ * lpatch is the kernel data structure that will be created on patch
+ * init, registered with the livepatch API on init, and finally
+ * unregistered when the patch exits.  Its struct klp_object *objs
+ * member must be dynamically allocated according to the number of
+ * target objects it will be patching.
+ */
 static struct klp_patch *lpatch;
 
 static LIST_HEAD(patch_objects);
 static int patch_objects_nr;
+
+/**
+ * struct patch_object - scaffolding structure tracking patch target objects
+ * @list:	list of patch_object (threaded onto patch_objects)
+ * @funcs:	list of patch_func associated with this object
+ * @relocs:	list of patch_reloc associated with this object
+ * @callbacks:	kernel struct of object callbacks
+ * @name:	patch target object name (NULL for vmlinux)
+ * @funcs_nr:	count of kpatch_patch_func added to @funcs
+ * @relocs_nr:	count of patch_reloc added to @relocs
+ */
 struct patch_object {
 	struct list_head list;
 	struct list_head funcs;
@@ -107,16 +137,36 @@ struct patch_object {
 	int funcs_nr, relocs_nr;
 };
 
+/**
+ * struct patch_func - scaffolding structure for kpatch_patch_func
+ * @list:	list of patch_func (threaded onto patch_object.funcs)
+ * @kfunc:	array of kpatch_patch_func
+ */
 struct patch_func {
 	struct list_head list;
 	struct kpatch_patch_func *kfunc;
 };
 
+/**
+ * struct patch_reloc - scaffolding structure for kpatch_patch_dynrela
+ * @list:	list of patch_reloc (threaded onto patch_object.relocs)
+ * @kdynrela:	array of kpatch_patch_dynrela
+ */
 struct patch_reloc {
 	struct list_head list;
 	struct kpatch_patch_dynrela *kdynrela;
 };
 
+/**
+ * patch_alloc_new_object() - creates and initializes a new patch_object
+ * @name:	target object name
+ *
+ * Return: pointer to new patch_object, NULL on failure.
+ *
+ * Does not check for previously created patch_objects with the same
+ * name.  Updates patch_objects_nr and threads new data structure onto
+ * the patch_objects list.
+ */
 static struct patch_object *patch_alloc_new_object(const char *name)
 {
 	struct patch_object *object;
@@ -135,6 +185,16 @@ static struct patch_object *patch_alloc_new_object(const char *name)
 	return object;
 }
 
+/**
+ * patch_find_object_by_name() - find or create a patch_object with a
+ * 				  given name
+ * @name:	target object name
+ *
+ * Return: pointer to patch_object, NULL on failure.
+ *
+ * Searches the patch_objects list for an already created instance with
+ * @name, otherwise tries to create it via patch_alloc_new_object()
+ */
 static struct patch_object *patch_find_object_by_name(const char *name)
 {
 	struct patch_object *object;
@@ -146,6 +206,17 @@ static struct patch_object *patch_find_object_by_name(const char *name)
 	return patch_alloc_new_object(name);
 }
 
+/**
+ * patch_add_func_to_object() - create scaffolding from kpatch_patch_func data
+ *
+ * @kfunc:	Individual kpatch_patch_func pointer
+ *
+ * Return: 0 on success, -ENOMEM on failure.
+ *
+ * Builds scaffolding data structures from .kpatch.funcs section's array
+ * of kpatch_patch_func structures.  Updates the associated
+ * patch_object's funcs_nr count.
+ */
 static int patch_add_func_to_object(struct kpatch_patch_func *kfunc)
 {
 	struct patch_func *func;
@@ -168,6 +239,17 @@ static int patch_add_func_to_object(struct kpatch_patch_func *kfunc)
 }
 
 #ifndef HAVE_ELF_RELOCS
+/**
+ * patch_add_reloc_to_object() - create scaffolding from kpatch_patch_dynrela data
+ *
+ * @kdynrela:	Individual kpatch_patch_dynrela pointer
+ *
+ * Return: 0 on success, -ENOMEM on failure.
+ *
+ * Builds scaffolding data structures from .kpatch.dynrelas section's array
+ * of kpatch_patch_dynrela structures.  Updates the associated
+ * patch_object's relocs_nr count.
+ */
 static int patch_add_reloc_to_object(struct kpatch_patch_dynrela *kdynrela)
 {
 	struct patch_reloc *reloc;
@@ -190,6 +272,9 @@ static int patch_add_reloc_to_object(struct kpatch_patch_dynrela *kdynrela)
 }
 #endif
 
+/**
+ * patch_free_scaffold() - tear down the temporary kpatch scaffolding
+ */
 static void patch_free_scaffold(void) {
 	struct patch_func *func, *safefunc;
 	struct patch_object *object, *safeobject;
@@ -215,6 +300,9 @@ static void patch_free_scaffold(void) {
 	}
 }
 
+/**
+ * patch_free_livepatch() - release the klp_patch and friends
+ */
 static void patch_free_livepatch(struct klp_patch *patch)
 {
 	struct klp_object *object;
@@ -234,12 +322,21 @@ static void patch_free_livepatch(struct klp_patch *patch)
 	}
 }
 
+/* Defined by kpatch.lds.S */
 extern struct kpatch_pre_patch_callback __kpatch_callbacks_pre_patch[], __kpatch_callbacks_pre_patch_end[];
 extern struct kpatch_post_patch_callback __kpatch_callbacks_post_patch[], __kpatch_callbacks_post_patch_end[];
 extern struct kpatch_pre_unpatch_callback __kpatch_callbacks_pre_unpatch[], __kpatch_callbacks_pre_unpatch_end[];
 extern struct kpatch_post_unpatch_callback __kpatch_callbacks_post_unpatch[], __kpatch_callbacks_post_unpatch_end[];
 
 #ifdef HAVE_CALLBACKS
+/**
+ * add_callbacks_to_patch_objects() - create patch_objects that have callbacks
+ *
+ * Return: 0 on success, -ENOMEM or -EINVAL on failure
+ *
+ * Iterates through all kpatch pre/post-(un)patch callback data
+ * structures and creates scaffolding patch_objects for them.
+ */
 static int add_callbacks_to_patch_objects(void)
 {
 	struct kpatch_pre_patch_callback *p_pre_patch_callback;
@@ -329,6 +426,7 @@ static inline int add_callbacks_to_patch_objects(void)
 }
 #endif /* HAVE_CALLBACKS */
 
+/* Defined by kpatch.lds.S */
 extern struct kpatch_patch_func __kpatch_funcs[], __kpatch_funcs_end[];
 #ifndef HAVE_ELF_RELOCS
 extern struct kpatch_patch_dynrela __kpatch_dynrelas[], __kpatch_dynrelas_end[];
@@ -348,6 +446,12 @@ static int __init patch_init(void)
 	struct klp_reloc *lrelocs, *lreloc;
 #endif
 
+
+	/*
+	 * Step 1 - read from output.o, create temporary scaffolding
+	 * data-structures
+	 */
+
 	/* organize functions and relocs by object in scaffold */
 	for (kfunc = __kpatch_funcs;
 	     kfunc != __kpatch_funcs_end;
@@ -374,6 +478,16 @@ static int __init patch_init(void)
 	/* past this point, only possible return code is -ENOMEM */
 	ret = -ENOMEM;
 
+	/*
+	 * Step 2 - create livepatch klp_patch and friends
+	 *
+	 * There are two dynamically allocated parts:
+	 *
+	 *   klp_patch
+	 *     klp_object objs  [patch_objects_nr]  <= i
+	 *       klp_func funcs [object->funcs_nr]  <= j
+	 */
+
 	/* allocate and fill livepatch structures */
 	lpatch = kzalloc(sizeof(*lpatch), GFP_KERNEL);
 	if (!lpatch)
@@ -385,6 +499,9 @@ static int __init patch_init(void)
 		goto out;
 	lpatch->mod = THIS_MODULE;
 	lpatch->objs = lobjects;
+#ifdef HAVE_KLP_REPLACE
+	lpatch->replace = KLP_REPLACE_ENABLE;
+#endif
 #if defined(__powerpc64__) && defined(HAVE_IMMEDIATE)
 	lpatch->immediate = true;
 #endif
@@ -441,6 +558,10 @@ static int __init patch_init(void)
 		i++;
 	}
 
+	/*
+	 * Step 3 - throw away scaffolding
+	 */
+
 	/*
 	 * Once the patch structure that the live patching API expects
 	 * has been built, we can release the scaffold structure.
diff --git a/kpatch-build/Makefile b/kpatch-build/Makefile
index d5b9fac..c424e28 100644
--- a/kpatch-build/Makefile
+++ b/kpatch-build/Makefile
@@ -22,6 +22,8 @@ GCC_PLUGINS_DIR := $(shell gcc -print-file-name=plugin)
 PLUGIN_CFLAGS := $(filter-out -Wconversion, $(CFLAGS))
 PLUGIN_CFLAGS += -shared -I$(GCC_PLUGINS_DIR)/include \
 		   -Igcc-plugins -fPIC -fno-rtti -O2 -Wall
+else
+$(error Unsupported architecture ${ARCH}, check https://github.com/dynup/kpatch/#supported-architectures)
 endif
 
 
@@ -38,7 +40,7 @@ $(PLUGIN): gcc-plugins/ppc64le-plugin.c
 
 install: all
 	$(INSTALL) -d $(LIBEXECDIR)
-	$(INSTALL) $(TARGETS) kpatch-gcc $(LIBEXECDIR)
+	$(INSTALL) $(TARGETS) kpatch-cc $(LIBEXECDIR)
 	$(INSTALL) -d $(BINDIR)
 	$(INSTALL) kpatch-build $(BINDIR)
 	$(INSTALL) create-diff-object $(BINDIR)
@@ -50,4 +52,4 @@ uninstall:
 	$(RM) $(BINDIR)/create-diff-object
 
 clean:
-	$(RM) $(TARGETS) *.{o,d} insn/*.{o,d} gcc-plugins/*.{so,d}
+	$(RM) $(TARGETS) *.o *.d insn/*.o insn/*.d gcc-plugins/*.so gcc-plugins/*.d
diff --git a/kpatch-build/create-diff-object.c b/kpatch-build/create-diff-object.c
index 4f30365..35335b3 100644
--- a/kpatch-build/create-diff-object.c
+++ b/kpatch-build/create-diff-object.c
@@ -24,7 +24,7 @@
  * This file contains the heart of the ELF object differencing engine.
  *
  * The tool takes two ELF objects from two versions of the same source
- * file; a "base" object and a "patched" object.  These object need to have
+ * file; a "orig" object and a "patched" object.  These object need to have
  * been compiled with the -ffunction-sections and -fdata-sections GCC options.
  *
  * The tool compares the objects at a section level to determine what
@@ -104,7 +104,7 @@ static int is_bundleable(struct symbol *sym)
 	if (sym->type == STT_FUNC &&
 	    !strncmp(sym->sec->name, ".text.unlikely.",15) &&
 	    (!strcmp(sym->sec->name + 15, sym->name) ||
-			 (strstr(sym->name, ".cold.") &&
+			 (strstr(sym->name, ".cold") &&
 			  !strncmp(sym->sec->name + 15, sym->name, strlen(sym->sec->name) - 15))))
 		return 1;
 
@@ -277,7 +277,7 @@ static void kpatch_detect_child_functions(struct kpatch_elf *kelf)
 		if (sym->type != STT_FUNC)
 			continue;
 
-		childstr = strstr(sym->name, ".cold.");
+		childstr = strstr(sym->name, ".cold");
 		if (childstr) {
 			sym->parent = kpatch_lookup_parent(kelf, sym->name,
 							   childstr);
@@ -301,8 +301,12 @@ static bool is_dynamic_debug_symbol(struct symbol *sym)
 {
 	if (sym->type == STT_OBJECT && sym->sec && !strcmp(sym->sec->name, "__verbose"))
 		return true;
+	if (sym->type == STT_OBJECT && !strcmp(sym->sec->name, "__dyndbg"))
+		return true;
 	if (sym->type == STT_SECTION && !strcmp(sym->name, "__verbose"))
 		return true;
+	if (sym->type == STT_SECTION && !strcmp(sym->name, "__dyndbg"))
+		return true;
 	return false;
 }
 
@@ -313,60 +317,74 @@ static bool is_dynamic_debug_symbol(struct symbol *sym)
  * Special static local variables should never be correlated and should always
  * be included if they are referenced by an included function.
  */
-static int is_special_static(struct symbol *sym)
+static bool is_special_static(struct symbol *sym)
 {
-	static char *prefixes[] = {
-		"__key.",
-		"__warned.",
-		"__func__.",
-		"__FUNCTION__.",
-        "__PRETTY_FUNCTION__.",
-		"_rs.",
-		"CSWTCH.",
-		NULL,
-	};
-	char **prefix;
-
-    static char *postfixes[] = {
+	static char *var_names[] = {
+		"__key",
+		"__warned",
+		"__func__",
 		"__FUNCTION__",
-        "__PRETTY_FUNCTION__",
+        "__PRETTY_FUNCTION__.",
+		"_rs",
+		"CSWTCH",
+		"_entry",
 		NULL,
 	};
-    char **postfix;
+	char **var_name;
 
 	if (!sym)
-		return 0;
+		return false;
 
-	/* pr_debug() uses static local variables in the __verbose section */
+	/* pr_debug() uses static local variables in the __verbose or __dyndbg section */
 	if (is_dynamic_debug_symbol(sym))
-		return 1;
+		return true;
 
 	if (sym->type == STT_SECTION) {
 		/* make sure section is bundled */
 		if (!sym->sec->sym)
-			return 0;
+			return false;
 
 		/* use bundled object/function symbol for matching */
 		sym = sym->sec->sym;
 	}
 
 	if (sym->type != STT_OBJECT || sym->bind != STB_LOCAL)
-		return 0;
+		return false;
 
-	for (prefix = prefixes; *prefix; prefix++)
-		if (!strncmp(sym->name, *prefix, strlen(*prefix)))
-			return 1;
-
-    size_t len = strlen(sym->name);
-    for (postfix = postfixes; *postfix; postfix++) {
-        size_t len_postfix = strlen(*postfix);
-        if (len < len_postfix) continue;
-        continue;
-		if (!strcmp(sym->name+len-len_postfix, *postfix))
-			return 1;
-    }
+	if  (!strcmp(sym->sec->name, ".data.once"))
+		return true;
 
-	return 0;
+	for (var_name = var_names; *var_name; var_name++) {
+		size_t var_name_len = strlen(*var_name);
+		char buf[256];
+
+		snprintf(buf, 256, ".%s.", *var_name);
+
+		/* First look for gcc-style statics: '<var_name>.' */
+		if (!strncmp(sym->name, buf + 1, var_name_len + 1))
+			return true;
+
+		buf[var_name_len + 1] = '\0';
+		/* Next clang-style statics: '<function_name>.<var_name>' */
+		if (strstr(sym->name, buf))
+			return true;
+	}
+
+	return false;
+}
+
+static bool has_digit_tail(char *tail)
+{
+	if (*tail != '.')
+		return false;
+
+	while (isdigit(*++tail))
+		;
+
+	if (!*tail)
+		return true;
+
+	return false;
 }
 
 /*
@@ -397,17 +415,35 @@ static int kpatch_mangled_strcmp(char *s1, char *s2)
 			s2++;
 		}
 	}
+
+	if ((!*s1 && has_digit_tail(s2)) ||
+	    (!*s2 && has_digit_tail(s1)))
+		return 0;
+
 	return 1;
 }
 
-static int rela_equal(struct rela *rela1, struct rela *rela2)
+static bool rela_equal(struct rela *rela1, struct rela *rela2)
 {
 	struct rela *rela_toc1, *rela_toc2;
 	unsigned long toc_data1 = 0, toc_data2 = 0; /* = 0 to prevent gcc warning */
 
 	if (rela1->type != rela2->type ||
 	    rela1->offset != rela2->offset)
-		return 0;
+		return false;
+
+	/*
+	 * On x86, .altinstr_aux is used to store temporary code which allows
+	 * static_cpu_has() to work before apply_alternatives() has run.  This
+	 * code is completely inert for modules, because apply_alternatives()
+	 * runs during module init, before the module is fully formed.  Any
+	 * changed references to it (i.e. changed addend) can be ignored.  As
+	 * long as they're both references to .altinstr_aux, they can be
+	 * considered equal, even if the addends differ.
+	 */
+	if (!strcmp(rela1->sym->name, ".altinstr_aux") &&
+	    !strcmp(rela2->sym->name, ".altinstr_aux"))
+		return true;
 
 	/*
 	 * With -mcmodel=large on ppc64le, GCC might generate entries in the .toc
@@ -466,13 +502,13 @@ static int rela_equal(struct rela *rela1, struct rela *rela2)
 		return toc_data1 == toc_data2;
 
 	if (!rela_toc1 || !rela_toc2)
-		return 0;
+		return false;
 
 	if (rela_toc1->string)
 		return rela_toc2->string && !strcmp(rela_toc1->string, rela_toc2->string);
 
 	if (rela_toc1->addend != rela_toc2->addend)
-		return 0;
+		return false;
 
 	return !kpatch_mangled_strcmp(rela_toc1->sym->name, rela_toc2->sym->name);
 }
@@ -580,7 +616,7 @@ out:
  * 3) (optional) __warned.xxxxx static local rela
  * 4) warn_slowpath_* or __might_sleep or some other similar rela
  */
-static int kpatch_line_macro_change_only(struct section *sec)
+static bool kpatch_line_macro_change_only(struct section *sec)
 {
 	struct insn insn1, insn2;
 	unsigned long start1, start2, size, offset, length;
@@ -593,7 +629,7 @@ static int kpatch_line_macro_change_only(struct section *sec)
 	    sec->sh.sh_size != sec->twin->sh.sh_size ||
 	    !sec->rela ||
 	    sec->rela->status != SAME)
-		return 0;
+		return false;
 
 	start1 = (unsigned long)sec->twin->data->d_buf;
 	start2 = (unsigned long)sec->data->d_buf;
@@ -610,7 +646,7 @@ static int kpatch_line_macro_change_only(struct section *sec)
 			      sec->name, offset);
 
 		if (insn1.length != insn2.length)
-			return 0;
+			return false;
 
 		if (!memcmp((void *)start1 + offset, (void *)start2 + offset,
 			    length))
@@ -621,7 +657,7 @@ static int kpatch_line_macro_change_only(struct section *sec)
 		insn_get_opcode(&insn2);
 		if (!(insn1.opcode.value == 0xba && insn2.opcode.value == 0xba) &&
 		    !(insn1.opcode.value == 0xbe && insn2.opcode.value == 0xbe))
-			return 0;
+			return false;
 
 		/*
 		 * Verify zero or more string relas followed by a
@@ -645,10 +681,10 @@ static int kpatch_line_macro_change_only(struct section *sec)
 				found = 1;
 				break;
 			}
-			return 0;
+			return false;
 		}
 		if (!found)
-			return 0;
+			return false;
 
 		lineonly = 1;
 	}
@@ -657,13 +693,13 @@ static int kpatch_line_macro_change_only(struct section *sec)
 		ERROR("no instruction changes detected for changed section %s",
 		      sec->name);
 
-	return 1;
+	return true;
 }
 #elif __powerpc64__
 #define PPC_INSTR_LEN 4
 #define PPC_RA_OFFSET 16
 
-static int kpatch_line_macro_change_only(struct section *sec)
+static bool kpatch_line_macro_change_only(struct section *sec)
 {
 	unsigned long start1, start2, size, offset;
 	unsigned int instr1, instr2;
@@ -676,7 +712,7 @@ static int kpatch_line_macro_change_only(struct section *sec)
 	    sec->sh.sh_size != sec->twin->sh.sh_size ||
 	    !sec->rela ||
 	    sec->rela->status != SAME)
-		return 0;
+		return false;
 
 	start1 = (unsigned long)sec->twin->data->d_buf;
 	start2 = (unsigned long)sec->data->d_buf;
@@ -691,7 +727,7 @@ static int kpatch_line_macro_change_only(struct section *sec)
 
 		/* verify it's a load immediate to r5 */
 		if (!(instr1 == 0x38a0 && instr2 == 0x38a0))
-			return 0;
+			return false;
 
 		found = 0;
 		list_for_each_entry(rela, &sec->rela->relas, list) {
@@ -711,10 +747,10 @@ static int kpatch_line_macro_change_only(struct section *sec)
 				found = 1;
 				break;
 			}
-			return 0;
+			return false;
 		}
 		if (!found)
-			return 0;
+			return false;
 
 		lineonly = 1;
 	}
@@ -723,12 +759,12 @@ static int kpatch_line_macro_change_only(struct section *sec)
 		ERROR("no instruction changes detected for changed section %s",
 		      sec->name);
 
-	return 1;
+	return true;
 }
 #else
-static int kpatch_line_macro_change_only(struct section *sec)
+static bool kpatch_line_macro_change_only(struct section *sec)
 {
-	return 0;
+	return false;
 }
 #endif
 
@@ -889,87 +925,95 @@ do {								\
 	elem->twin = NULL;					\
 } while (0)
 
-static void __kpatch_correlate_section(struct section *sec1, struct section *sec2)
+static void __kpatch_correlate_section(struct section *sec_orig,
+		struct section *sec_patched)
 {
-	CORRELATE_ELEMENT(sec1, sec2, "section");
+	CORRELATE_ELEMENT(sec_orig, sec_patched, "section");
 }
 
-static void kpatch_correlate_symbol(struct symbol *sym1, struct symbol *sym2)
+static void kpatch_correlate_symbol(struct symbol *sym_orig,
+		struct symbol *sym_patched)
 {
-	CORRELATE_ELEMENT(sym1, sym2, "symbol");
+	CORRELATE_ELEMENT(sym_orig, sym_patched, "symbol");
+	if (sym_orig->lookup_table_file_sym && !sym_patched->lookup_table_file_sym)
+		sym_patched->lookup_table_file_sym = sym_orig->lookup_table_file_sym;
 }
 
-static void kpatch_correlate_static_local(struct symbol *sym1, struct symbol *sym2)
+static void kpatch_correlate_static_local(struct symbol *sym_orig,
+		struct symbol *sym_patched)
 {
-	CORRELATE_ELEMENT(sym1, sym2, "static local");
+	CORRELATE_ELEMENT(sym_orig, sym_patched, "static local");
 }
 
-static void kpatch_correlate_section(struct section *sec1, struct section *sec2)
+static void kpatch_correlate_section(struct section *sec_orig,
+		struct section *sec_patched)
 {
-	__kpatch_correlate_section(sec1, sec2);
+	__kpatch_correlate_section(sec_orig, sec_patched);
 
-	if (is_rela_section(sec1)) {
-		__kpatch_correlate_section(sec1->base, sec2->base);
-		sec1 = sec1->base;
-		sec2 = sec2->base;
-	} else if (sec1->rela && sec2->rela) {
-		__kpatch_correlate_section(sec1->rela, sec2->rela);
+	if (is_rela_section(sec_orig)) {
+		__kpatch_correlate_section(sec_orig->base, sec_patched->base);
+		sec_orig = sec_orig->base;
+		sec_patched = sec_patched->base;
+	} else if (sec_orig->rela && sec_patched->rela) {
+		__kpatch_correlate_section(sec_orig->rela, sec_patched->rela);
 	}
 
-	if (sec1->secsym)
-		kpatch_correlate_symbol(sec1->secsym, sec2->secsym);
-	if (sec1->sym)
-		kpatch_correlate_symbol(sec1->sym, sec2->sym);
+	if (sec_orig->secsym)
+		kpatch_correlate_symbol(sec_orig->secsym, sec_patched->secsym);
+	if (sec_orig->sym)
+		kpatch_correlate_symbol(sec_orig->sym, sec_patched->sym);
 }
 
-static void kpatch_correlate_sections(struct list_head *seclist1, struct list_head *seclist2)
+static void kpatch_correlate_sections(struct list_head *seclist_orig,
+		struct list_head *seclist_patched)
 {
-	struct section *sec1, *sec2;
+	struct section *sec_orig, *sec_patched;
 
-	list_for_each_entry(sec1, seclist1, list) {
-		if (sec1->twin)
+	list_for_each_entry(sec_orig, seclist_orig, list) {
+		if (sec_orig->twin)
 			continue;
-		list_for_each_entry(sec2, seclist2, list) {
-			if (kpatch_mangled_strcmp(sec1->name, sec2->name) ||
-			    sec2->twin)
+		list_for_each_entry(sec_patched, seclist_patched, list) {
+			if (kpatch_mangled_strcmp(sec_orig->name, sec_patched->name) ||
+			    sec_patched->twin)
 				continue;
 
-			if (is_special_static(is_rela_section(sec1) ?
-					      sec1->base->secsym :
-					      sec1->secsym))
+			if (is_special_static(is_rela_section(sec_orig) ?
+					      sec_orig->base->secsym :
+					      sec_orig->secsym))
 				continue;
 
 			/*
 			 * Group sections must match exactly to be correlated.
 			 * Changed group sections are currently not supported.
 			 */
-			if (sec1->sh.sh_type == SHT_GROUP) {
-				if (sec1->data->d_size != sec2->data->d_size)
+			if (sec_orig->sh.sh_type == SHT_GROUP) {
+				if (sec_orig->data->d_size != sec_patched->data->d_size)
 					continue;
-				if (memcmp(sec1->data->d_buf, sec2->data->d_buf,
-				           sec1->data->d_size))
+				if (memcmp(sec_orig->data->d_buf, sec_patched->data->d_buf,
+				           sec_orig->data->d_size))
 					continue;
 			}
 
-			kpatch_correlate_section(sec1, sec2);
+			kpatch_correlate_section(sec_orig, sec_patched);
 			break;
 		}
 	}
 }
 
-static void kpatch_correlate_symbols(struct list_head *symlist1, struct list_head *symlist2)
+static void kpatch_correlate_symbols(struct list_head *symlist_orig,
+		struct list_head *symlist_patched)
 {
-	struct symbol *sym1, *sym2;
+	struct symbol *sym_orig, *sym_patched;
 
-	list_for_each_entry(sym1, symlist1, list) {
-		if (sym1->twin)
+	list_for_each_entry(sym_orig, symlist_orig, list) {
+		if (sym_orig->twin)
 			continue;
-		list_for_each_entry(sym2, symlist2, list) {
-			if (kpatch_mangled_strcmp(sym1->name, sym2->name) ||
-			    sym1->type != sym2->type || sym2->twin)
+		list_for_each_entry(sym_patched, symlist_patched, list) {
+			if (kpatch_mangled_strcmp(sym_orig->name, sym_patched->name) ||
+			    sym_orig->type != sym_patched->type || sym_patched->twin)
 				continue;
 
-			if (is_special_static(sym1))
+			if (is_special_static(sym_orig))
 				continue;
 
 			/*
@@ -986,42 +1030,42 @@ static void kpatch_correlate_symbols(struct list_head *symlist1, struct list_hea
 			 * sure if this actually happens anywhere), any string
 			 * changes will be detected elsewhere in rela_equal().
 			 */
-			if (sym1->type == STT_NOTYPE &&
-			    !strncmp(sym1->name, ".LC", 3))
+			if (sym_orig->type == STT_NOTYPE &&
+			    !strncmp(sym_orig->name, ".LC", 3))
 				continue;
 
 			/* group section symbols must have correlated sections */
-			if (sym1->sec &&
-			    sym1->sec->sh.sh_type == SHT_GROUP &&
-			    sym1->sec->twin != sym2->sec)
+			if (sym_orig->sec &&
+			    sym_orig->sec->sh.sh_type == SHT_GROUP &&
+			    sym_orig->sec->twin != sym_patched->sec)
 				continue;
 
-			kpatch_correlate_symbol(sym1, sym2);
+			kpatch_correlate_symbol(sym_orig, sym_patched);
 			break;
 		}
 	}
 }
 
-static void kpatch_compare_elf_headers(Elf *elf1, Elf *elf2)
+static void kpatch_compare_elf_headers(Elf *elf_orig, Elf *elf_patched)
 {
-	GElf_Ehdr eh1, eh2;
+	GElf_Ehdr ehdr_orig, ehdr_patched;
 
-	if (!gelf_getehdr(elf1, &eh1))
+	if (!gelf_getehdr(elf_orig, &ehdr_orig))
 		ERROR("gelf_getehdr");
 
-	if (!gelf_getehdr(elf2, &eh2))
+	if (!gelf_getehdr(elf_patched, &ehdr_patched))
 		ERROR("gelf_getehdr");
 
-	if (memcmp(eh1.e_ident, eh2.e_ident, EI_NIDENT) ||
-	    eh1.e_type != eh2.e_type ||
-	    eh1.e_machine != eh2.e_machine ||
-	    eh1.e_version != eh2.e_version ||
-	    eh1.e_entry != eh2.e_entry ||
-	    eh1.e_phoff != eh2.e_phoff ||
-	    eh1.e_flags != eh2.e_flags ||
-	    eh1.e_ehsize != eh2.e_ehsize ||
-	    eh1.e_phentsize != eh2.e_phentsize ||
-	    eh1.e_shentsize != eh2.e_shentsize)
+	if (memcmp(ehdr_orig.e_ident, ehdr_patched.e_ident, EI_NIDENT) ||
+	    ehdr_orig.e_type != ehdr_patched.e_type ||
+	    ehdr_orig.e_machine != ehdr_patched.e_machine ||
+	    ehdr_orig.e_version != ehdr_patched.e_version ||
+	    ehdr_orig.e_entry != ehdr_patched.e_entry ||
+	    ehdr_orig.e_phoff != ehdr_patched.e_phoff ||
+	    ehdr_orig.e_flags != ehdr_patched.e_flags ||
+	    ehdr_orig.e_ehsize != ehdr_patched.e_ehsize ||
+	    ehdr_orig.e_phentsize != ehdr_patched.e_phentsize ||
+	    ehdr_orig.e_shentsize != ehdr_patched.e_shentsize)
 		DIFF_FATAL("ELF headers differ");
 }
 
@@ -1159,18 +1203,21 @@ static struct symbol *kpatch_find_static_twin(struct section *sec,
 	return NULL;
 }
 
-static int kpatch_is_normal_static_local(struct symbol *sym)
+static bool kpatch_is_normal_static_local(struct symbol *sym)
 {
 	if (sym->type != STT_OBJECT || sym->bind != STB_LOCAL)
-		return 0;
+		return false;
+
+	if (!strncmp(sym->name, ".L", 2))
+		return false;
 
 	if (!strchr(sym->name, '.'))
-		return 0;
+		return false;
 
 	if (is_special_static(sym))
-		return 0;
+		return false;
 
-	return 1;
+	return true;
 }
 
 static struct rela *kpatch_find_static_twin_ref(struct section *rela_sec, struct symbol *sym)
@@ -1219,14 +1266,14 @@ static struct rela *kpatch_find_static_twin_ref(struct section *rela_sec, struct
  *   with the same name to be used in the same function if they
  *   have different scopes.  (We have to assume that in such
  *   cases, the order in which they're referenced remains the
- *   same between the base and patched objects, as there's no
+ *   same between the orig and patched objects, as there's no
  *   other way to distinguish them.)
  *
  * - Static locals are usually referenced by functions, but
  *   they can occasionally be referenced by data sections as
  *   well.
  */
-static void kpatch_correlate_static_local_variables(struct kpatch_elf *base,
+static void kpatch_correlate_static_local_variables(struct kpatch_elf *orig,
 						    struct kpatch_elf *patched)
 {
 	struct symbol *sym, *patched_sym;
@@ -1236,10 +1283,10 @@ static void kpatch_correlate_static_local_variables(struct kpatch_elf *base,
 
 	/*
 	 * First undo the correlations for all static locals.  Two static
-	 * locals can have the same numbered suffix in the base and patched
+	 * locals can have the same numbered suffix in the orig and patched
 	 * objects by coincidence.
 	 */
-	list_for_each_entry(sym, &base->symbols, list) {
+	list_for_each_entry(sym, &orig->symbols, list) {
 
 		if (!kpatch_is_normal_static_local(sym))
 			continue;
@@ -1251,7 +1298,8 @@ static void kpatch_correlate_static_local_variables(struct kpatch_elf *base,
 		if (bundled && sym->sec->twin) {
 			UNCORRELATE_ELEMENT(sym->sec);
 
-			UNCORRELATE_ELEMENT(sym->sec->secsym);
+			if (sym->sec->secsym)
+				UNCORRELATE_ELEMENT(sym->sec->secsym);
 
 			if (sym->sec->rela)
 				UNCORRELATE_ELEMENT(sym->sec->rela);
@@ -1262,7 +1310,7 @@ static void kpatch_correlate_static_local_variables(struct kpatch_elf *base,
 	 * Do the correlations: for each section reference to a static local,
 	 * look for a corresponding reference in the section's twin.
 	 */
-	list_for_each_entry(sec, &base->sections, list) {
+	list_for_each_entry(sec, &orig->sections, list) {
 
 		if (!is_rela_section(sec) ||
 		    is_debug_section(sec) ||
@@ -1318,14 +1366,14 @@ static void kpatch_correlate_static_local_variables(struct kpatch_elf *base,
 	/*
 	 * Make sure that:
 	 *
-	 * 1. all the base object's referenced static locals have been
+	 * 1. all the orig object's referenced static locals have been
 	 *    correlated; and
 	 *
-	 * 2. each reference to a static local in the base object has a
+	 * 2. each reference to a static local in the orig object has a
 	 *    corresponding reference in the patched object (because a static
 	 *    local can be referenced by more than one section).
 	 */
-	list_for_each_entry(sec, &base->sections, list) {
+	list_for_each_entry(sec, &orig->sections, list) {
 
 		if (!is_rela_section(sec) ||
 		    is_debug_section(sec))
@@ -1386,10 +1434,11 @@ static void kpatch_correlate_static_local_variables(struct kpatch_elf *base,
 	}
 }
 
-static void kpatch_correlate_elfs(struct kpatch_elf *kelf1, struct kpatch_elf *kelf2)
+static void kpatch_correlate_elfs(struct kpatch_elf *kelf_orig,
+		struct kpatch_elf *kelf_patched)
 {
-	kpatch_correlate_sections(&kelf1->sections, &kelf2->sections);
-	kpatch_correlate_symbols(&kelf1->symbols, &kelf2->symbols);
+	kpatch_correlate_sections(&kelf_orig->sections, &kelf_patched->sections);
+	kpatch_correlate_symbols(&kelf_orig->symbols, &kelf_patched->symbols);
 }
 
 static void kpatch_compare_correlated_elements(struct kpatch_elf *kelf)
@@ -1754,7 +1803,7 @@ static int kpatch_include_callback_elements(struct kpatch_elf *kelf)
 			sym = rela->sym;
 			log_normal("found callback: %s\n",sym->name);
 			kpatch_include_symbol(sym);
-		} else {
+		} else if (sec->secsym) {
 			sec->secsym->include = 1;
 		}
 	}
@@ -1782,7 +1831,8 @@ static void kpatch_include_force_elements(struct kpatch_elf *kelf)
 			sec->include = 1;
 			if (!is_rela_section(sec)) {
 				/* .kpatch.force */
-				sec->secsym->include = 1;
+				if (sec->secsym)
+					sec->secsym->include = 1;
 				continue;
 			}
 			/* .rela.kpatch.force */
@@ -1927,7 +1977,7 @@ static void kpatch_migrate_included_elements(struct kpatch_elf *kelf, struct kpa
 		list_del(&sym->list);
 		list_add_tail(&sym->list, &out->symbols);
 		sym->index = 0;
-		sym->strip = 0;
+		sym->strip = SYMBOL_DEFAULT;
 		if (sym->sec && !sym->sec->include)
 			/* break link to non-included section */
 			sym->sec = NULL;
@@ -2000,6 +2050,21 @@ static int jump_table_group_size(struct kpatch_elf *kelf, int offset)
 	return size;
 }
 
+static int printk_index_group_size(struct kpatch_elf *kelf, int offset)
+{
+	static int size = 0;
+	char *str;
+
+	if (!size) {
+		str = getenv("PRINTK_INDEX_STRUCT_SIZE");
+		if (!str)
+			ERROR("PRINTK_INDEX_STRUCT_SIZE not set");
+		size = atoi(str);
+	}
+
+	return size;
+}
+
 #ifdef __x86_64__
 static int parainstructions_group_size(struct kpatch_elf *kelf, int offset)
 {
@@ -2035,6 +2100,21 @@ static int smp_locks_group_size(struct kpatch_elf *kelf, int offset)
 {
 	return 4;
 }
+
+static int static_call_sites_group_size(struct kpatch_elf *kelf, int offset)
+{
+	static int size = 0;
+	char *str;
+
+	if (!size) {
+		str = getenv("STATIC_CALL_STRUCT_SIZE");
+		if (!str)
+			ERROR("STATIC_CALL_STRUCT_SIZE not set");
+		size = atoi(str);
+	}
+
+	return size;
+}
 #endif
 #ifdef __powerpc64__
 static int fixup_entry_group_size(struct kpatch_elf *kelf, int offset)
@@ -2130,6 +2210,10 @@ static struct special_section special_sections[] = {
 		.name		= "__jump_table",
 		.group_size	= jump_table_group_size,
 	},
+	{
+		.name		= ".printk_index",
+		.group_size	= printk_index_group_size,
+	},
 #ifdef __x86_64__
 	{
 		.name		= ".smp_locks",
@@ -2143,6 +2227,10 @@ static struct special_section special_sections[] = {
 		.name		= ".altinstructions",
 		.group_size	= altinstructions_group_size,
 	},
+	{
+		.name		= ".static_call_sites",
+		.group_size	= static_call_sites_group_size,
+	},
 #endif
 #ifdef __powerpc64__
 	{
@@ -2175,7 +2263,7 @@ static bool should_keep_jump_label(struct lookup_table *lookup,
 				   unsigned int group_size,
 				   int *jump_labels_found)
 {
-	struct rela *code, *key, *rela;
+	struct rela *code = NULL, *key = NULL, *rela;
 	bool tracepoint = false, dynamic_debug = false;
 	struct lookup_result symbol;
 	int i = 0;
@@ -2196,7 +2284,7 @@ static bool should_keep_jump_label(struct lookup_table *lookup,
 		}
 	}
 
-	if (i != 3)
+	if (i != 3 || !key || !code)
 		ERROR("BUG: __jump_table has an unexpected format");
 
 	if (!strncmp(key->sym->name, "__tracepoint_", 13))
@@ -2221,7 +2309,7 @@ static bool should_keep_jump_label(struct lookup_table *lookup,
 		 * This will be upgraded to an error after all jump labels have
 		 * been reported.
 		 */
-		log_normal("Found a jump label at %s()+0x%lx, using key %s.  Jump labels aren't supported with this kernel.  Use static_key_enabled() instead.",
+		log_normal("Found a jump label at %s()+0x%lx, using key %s.  Jump labels aren't supported with this kernel.  Use static_key_enabled() instead.\n",
 			   code->sym->name, code->addend, key->sym->name);
 		(*jump_labels_found)++;
 		return false;
@@ -2238,7 +2326,7 @@ static bool should_keep_jump_label(struct lookup_table *lookup,
 	 * jump label init.
 	 */
 
-	if (lookup_symbol(lookup, key->sym->name, &symbol) &&
+	if (lookup_symbol(lookup, key->sym, &symbol) &&
 	    strcmp(symbol.objname, "vmlinux")) {
 
 		/* The static key lives in a module -- not supported */
@@ -2251,7 +2339,7 @@ static bool should_keep_jump_label(struct lookup_table *lookup,
 		 * This will be upgraded to an error after all jump labels have
 		 * been reported.
 		 */
-		log_normal("Found a jump label at %s()+0x%lx, using key %s, which is defined in a module.  Use static_key_enabled() instead.",
+		log_normal("Found a jump label at %s()+0x%lx, using key %s, which is defined in a module.  Use static_key_enabled() instead.\n",
 			   code->sym->name, code->addend, key->sym->name);
 		(*jump_labels_found)++;
 		return false;
@@ -2411,7 +2499,8 @@ static void kpatch_regenerate_special_section(struct kpatch_elf *kelf,
 	sec->include = 1;
 	sec->base->include = 1;
 	/* include secsym so .kpatch.arch relas can point to section symbols */
-	sec->base->secsym->include = 1;
+	if (sec->base->secsym)
+		sec->base->secsym->include = 1;
 
 	/*
 	 * Update text section data buf and size.
@@ -2528,7 +2617,8 @@ static void kpatch_check_relocations(struct kpatch_elf *kelf)
 			if (rela->sym->sec) {
 				sdata = rela->sym->sec->data;
                 // Sometimes tehre are broken relocations
-                if (rela->addend > (long)sdata->d_size) {
+                //if (rela->addend > (long)sdata->d_size) {
+				if ((long)rela->sym->sym.st_value + rela->addend > (long)sdata->d_size) {
                     // We can ignore out-of-range relocations between
                     // the .rodata and the .text section of a
                     // function. Such bad relocations happen on jump tables.
@@ -2567,7 +2657,7 @@ static void kpatch_include_debug_sections(struct kpatch_elf *kelf)
 	list_for_each_entry(sec, &kelf->sections, list) {
 		if (is_debug_section(sec)) {
 			sec->include = 1;
-			if (!is_rela_section(sec))
+			if (!is_rela_section(sec) && sec->secsym)
 				sec->secsym->include = 1;
 		}
 	}
@@ -2617,7 +2707,9 @@ static void kpatch_mark_ignored_sections(struct kpatch_elf *kelf)
 		 * from the section data comparison, but this is a simpler way.
 		 */
 		strsec->include = 1;
-		strsec->secsym->include = 1;
+		if (strsec->secsym)
+			strsec->secsym->include = 1;
+
 		name = strsec->data->d_buf + rela->addend;
 		ignoresec = find_section_by_name(&kelf->sections, name);
 		if (!ignoresec)
@@ -2836,43 +2928,6 @@ static void kpatch_process_special_sections(struct kpatch_elf *kelf,
 	kpatch_regenerate_orc_sections(kelf);
 }
 
-static struct sym_compare_type *kpatch_elf_locals(struct kpatch_elf *kelf)
-{
-	struct symbol *sym;
-	int i = 0, sym_num = 0;
-	struct sym_compare_type *sym_array;
-
-	list_for_each_entry(sym, &kelf->symbols, list) {
-		if (sym->bind != STB_LOCAL)
-			continue;
-		if (sym->type != STT_FUNC && sym->type != STT_OBJECT)
-			continue;
-
-		sym_num++;
-	}
-
-	if (!sym_num)
-		return NULL;
-
-	sym_array = malloc((sym_num + 1) * sizeof(struct sym_compare_type));
-	if (!sym_array)
-		ERROR("malloc");
-
-	list_for_each_entry(sym, &kelf->symbols, list) {
-		if (sym->bind != STB_LOCAL)
-			continue;
-		if (sym->type != STT_FUNC && sym->type != STT_OBJECT)
-			continue;
-
-		sym_array[i].type = sym->type;
-		sym_array[i++].name = strdup(sym->name);
-	}
-	sym_array[i].type = 0;
-	sym_array[i].name = NULL;
-
-	return sym_array;
-}
-
 static void kpatch_create_patches_sections(struct kpatch_elf *kelf,
 					   struct lookup_table *table,
 					   char *objname)
@@ -2913,7 +2968,7 @@ static void kpatch_create_patches_sections(struct kpatch_elf *kelf,
 		    sym->parent)
 			continue;
 
-		if (!lookup_symbol(table, sym->name, &symbol))
+		if (!lookup_symbol(table, sym, &symbol))
 			ERROR("can't find symbol '%s' in symbol table", sym->name);
 
 		if (sym->bind == STB_LOCAL && symbol.global)
@@ -2999,7 +3054,7 @@ static int function_ptr_rela(const struct rela *rela)
 		rela->type == R_PPC64_TOC16_LO_DS));
 }
 
-static bool need_dynrela(struct lookup_table *table, const struct rela *rela)
+static bool need_dynrela(struct lookup_table *table, struct section *sec, const struct rela *rela)
 {
 	struct lookup_result symbol;
 
@@ -3008,7 +3063,11 @@ static bool need_dynrela(struct lookup_table *table, const struct rela *rela)
 	 * should never be converted to dynrelas.
 	 */
 	if (rela->type == R_PPC64_REL16_HA || rela->type == R_PPC64_REL16_LO ||
-	    rela->type == R_PPC64_REL64 || rela->type == R_PPC64_ENTRY)
+	    rela->type == R_PPC64_ENTRY)
+		return false;
+
+	/* v5.13+ kernels use relative jump labels */
+	if (rela->type == R_PPC64_REL64 && strcmp(sec->name, ".rela__jump_table"))
 		return false;
 
 	/*
@@ -3074,7 +3133,7 @@ static bool need_dynrela(struct lookup_table *table, const struct rela *rela)
 			!strchr(toc_rela(rela)->sym->name, '.');
 	}
 
-	if (!lookup_symbol(table, rela->sym->name, &symbol)) {
+	if (!lookup_symbol(table, rela->sym, &symbol)) {
 		/*
 		 * Assume the symbol lives in another .o in the patch module.
 		 * A normal rela should work.
@@ -3202,8 +3261,7 @@ static void kpatch_create_intermediate_sections(struct kpatch_elf *kelf,
 			 * internal symbol function pointer check which is done
 			 * via .toc indirection in need_dynrela().
 			 */
-			if (need_dynrela(table, rela)) {
-                // printf("Need dynrela for %s\n", rela->sym->name);
+			if (need_dynrela(table, sec, rela)) {
 				toc_rela(rela)->need_dynrela = 1;
             }
 		}
@@ -3246,8 +3304,10 @@ static void kpatch_create_intermediate_sections(struct kpatch_elf *kelf,
 				special = true;
 
 		list_for_each_entry_safe(rela, safe, &sec->relas, list) {
-			if (!rela->need_dynrela)
+			if (!rela->need_dynrela) {
+				rela->sym->strip = SYMBOL_USED;
 				continue;
+			}
 
 			/*
 			 * Starting with Linux 5.8, .klp.arch sections are no
@@ -3266,7 +3326,7 @@ static void kpatch_create_intermediate_sections(struct kpatch_elf *kelf,
 				ERROR("unsupported dynrela reference to symbol '%s' in module-specific special section '%s'",
 				      rela->sym->name, sec->base->name);
 
-			if (!lookup_symbol(table, rela->sym->name, &symbol))
+			if (!lookup_symbol(table, rela->sym, &symbol))
 				ERROR("can't find symbol '%s' in symbol table",
 				      rela->sym->name);
 
@@ -3344,8 +3404,8 @@ static void kpatch_create_intermediate_sections(struct kpatch_elf *kelf,
 			 * later (for example, they may have relocations
 			 * of their own which should be processed).
 			 */
-			if (!rela->sym->sec)
-				rela->sym->strip = 1;
+			if (!rela->sym->sec && rela->sym->strip != SYMBOL_USED)
+				rela->sym->strip = SYMBOL_STRIP;
 			list_del(&rela->list);
 			free(rela);
 
@@ -3405,9 +3465,6 @@ static void kpatch_create_callbacks_objname_rela(struct kpatch_elf *kelf, char *
 }
 
 #if 0
-// def __powerpc64__ 
-// void kpatch_create_mcount_sections(struct kpatch_elf *kelf) { }
-// #else
 /*
  * This function basically reimplements the functionality of the Linux
  * recordmcount script, so that patched functions can be recognized by ftrace.
@@ -3420,9 +3477,9 @@ static void kpatch_create_mcount_sections(struct kpatch_elf *kelf)
 	int nr, index;
 	struct section *sec, *relasec;
 	struct symbol *sym;
-	struct rela *rela;
-	void *newdata;
-	unsigned char *insn;
+	struct rela *rela, *mcount_rela;
+	void **funcs;
+	unsigned long insn_offset;
 
 	nr = 0;
 	list_for_each_entry(sym, &kelf->symbols, list)
@@ -3446,36 +3503,40 @@ static void kpatch_create_mcount_sections(struct kpatch_elf *kelf)
 			continue;
 		}
 
-		/* add rela in .rela__mcount_loc to fill in function pointer */
-		ALLOC_LINK(rela, &relasec->relas);
-		rela->sym = sym;
-		rela->type = R_X86_64_64;
-		rela->addend = 0;
-		rela->offset = (unsigned int)(index * sizeof(void*));
+#ifdef __x86_64__
+
+		rela = list_first_entry(&sym->sec->rela->relas, struct rela, list);
 
 		/*
-		 * Modify the first instruction of the function to "callq
-		 * __fentry__" so that ftrace will be happy.
+		 * For "call fentry", the relocation points to 1 byte past the
+		 * beginning of the instruction.
 		 */
-		newdata = malloc(sym->sec->data->d_size);
-		if (!newdata)
-			ERROR("malloc");
+		insn_offset = rela->offset - 1;
 
-		memcpy(newdata, sym->sec->data->d_buf, sym->sec->data->d_size);
-		sym->sec->data->d_buf = newdata;
-		insn = newdata;
+		if (rela->type == R_X86_64_NONE) {
+			void *newdata;
+			unsigned char *insn;
 
-		rela = list_first_entry(&sym->sec->rela->relas, struct rela,
-					list);
+			/*
+			 * R_X86_64_NONE is only generated by older versions of
+			 * kernel/gcc which use the mcount script.  There's a
+			 * NOP instead of a call to fentry.
+			 */
 
-		/*
-		 * R_X86_64_NONE is only generated by older versions of kernel/gcc
-		 * which use the mcount script.
-		 */
-		if (rela->type == R_X86_64_NONE) {
+			/* Make a writable copy of the text section data */
+			newdata = malloc(sym->sec->data->d_size);
+			memcpy(newdata, sym->sec->data->d_buf, sym->sec->data->d_size);
+			sym->sec->data->d_buf = newdata;
+			insn = newdata;
+
+			/*
+			 * Replace the NOP with a call to fentry.  The fentry
+			 * rela symbol is already there, just need to change
+			 * the relocation type accordingly.
+			 */
+			insn = sym->sec->data->d_buf;
 			if (insn[0] != 0xf)
-				ERROR("%s: unexpected instruction at the start of the function",
-				      sym->name);
+				ERROR("%s: unexpected instruction at the start of the function", sym->name);
 			insn[0] = 0xe8;
 			insn[1] = 0;
 			insn[2] = 0;
@@ -3485,6 +3546,33 @@ static void kpatch_create_mcount_sections(struct kpatch_elf *kelf)
 			rela->type = R_X86_64_PC32;
 		}
 
+#else /* __powerpc64__ */
+{
+		bool found = false;
+
+		list_for_each_entry(rela, &sym->sec->rela->relas, list)
+			if (!strcmp(rela->sym->name, "_mcount")) {
+				found = true;
+				break;
+			}
+
+		if (!found)
+			ERROR("%s: unexpected missing call to _mcount()", __func__);
+
+		insn_offset = rela->offset;
+}
+#endif
+		/*
+		 * 'rela' points to the mcount/fentry call.
+		 *
+		 * Create a .rela__mcount_loc entry which also points to it.
+		 */
+		ALLOC_LINK(mcount_rela, &relasec->relas);
+		mcount_rela->sym = sym;
+		mcount_rela->type = ABSOLUTE_RELA_TYPE;
+		mcount_rela->addend = insn_offset - sym->sym.st_value;
+		mcount_rela->offset = (unsigned int) (index * sizeof(*funcs));
+
 		index++;
 	}
 
@@ -3505,7 +3593,7 @@ static void kpatch_strip_unneeded_syms(struct kpatch_elf *kelf,
 	struct symbol *sym, *safe;
 
 	list_for_each_entry_safe(sym, safe, &kelf->symbols, list) {
-		if (sym->strip) {
+		if (sym->strip == SYMBOL_STRIP) {
 			list_del(&sym->list);
 			free(sym);
 		}
@@ -3677,15 +3765,13 @@ static struct argp argp = { options, parse_opt, args_doc, NULL };
 
 int main(int argc, char *argv[])
 {
-	struct kpatch_elf *kelf_base, *kelf_patched, *kelf_out;
+	struct kpatch_elf *kelf_orig, *kelf_patched, *kelf_out;
 	struct arguments arguments;
 	int num_changed, callbacks_exist, new_globals_exist;
 	struct lookup_table *lookup;
 	struct section *sec, *symtab;
-	struct symbol *sym;
-	char *hint = NULL, *orig_obj, *patched_obj, *parent_name;
+	char *orig_obj, *patched_obj, *parent_name;
 	char *parent_symtab, *mod_symvers, *patch_name, *output_obj;
-	struct sym_compare_type *base_locals, *sym_comp;
 
 	memset(&arguments, 0, sizeof(arguments));
 	argp_parse (&argp, argc, argv, 0, NULL, &arguments);
@@ -3706,63 +3792,43 @@ int main(int argc, char *argv[])
 
 	childobj = basename(orig_obj);
 
-	kelf_base = kpatch_elf_open(orig_obj);
+	kelf_orig = kpatch_elf_open(orig_obj);
 	kelf_patched = kpatch_elf_open(patched_obj);
 
-	kpatch_compare_elf_headers(kelf_base->elf, kelf_patched->elf);
-	kpatch_check_program_headers(kelf_base->elf);
+	kpatch_compare_elf_headers(kelf_orig->elf, kelf_patched->elf);
+	kpatch_check_program_headers(kelf_orig->elf);
 	kpatch_check_program_headers(kelf_patched->elf);
 
-
-    // kpatch_check_relocations(kelf_base);
+    // kpatch_check_relocations(kelf_orig);
     // kpatch_check_relocations(kelf_patched);
 
-
-	kpatch_bundle_symbols(kelf_base);
+	kpatch_bundle_symbols(kelf_orig);
 	kpatch_bundle_symbols(kelf_patched);
 
-
-	kpatch_detect_child_functions(kelf_base);
+	kpatch_detect_child_functions(kelf_orig);
 	kpatch_detect_child_functions(kelf_patched);
 
-	list_for_each_entry(sym, &kelf_base->symbols, list) {
-		if (sym->type == STT_FILE) {
-			hint = strdup(sym->name);
-			break;
-		}
-	}
-	if (!hint) {
-		log_normal("WARNING: FILE symbol not found in base. Stripped object file or assembly source?\n");
-		return EXIT_STATUS_NO_CHANGE;
-	}
-
-	base_locals = kpatch_elf_locals(kelf_base);
-
-	lookup = lookup_open(parent_symtab, parent_name, mod_symvers, hint,
-			     base_locals);
+	lookup = lookup_open(parent_symtab, parent_name, mod_symvers, kelf_orig);
 
 	kpatch_mark_grouped_sections(kelf_patched);
-	kpatch_replace_sections_syms(kelf_base);
+	kpatch_replace_sections_syms(kelf_orig);
 	kpatch_replace_sections_syms(kelf_patched);
 
-
-	kpatch_correlate_elfs(kelf_base, kelf_patched);
-	kpatch_correlate_static_local_variables(kelf_base, kelf_patched);
+	kpatch_correlate_elfs(kelf_orig, kelf_patched);
+	kpatch_correlate_static_local_variables(kelf_orig, kelf_patched);
 
 	/*
-	 * After this point, we don't care about kelf_base anymore.
+	 * After this point, we don't care about kelf_orig anymore.
 	 * We access its sections via the twin pointers in the
 	 * section, symbol, and rela lists of kelf_patched.
 	 */
 	kpatch_mark_ignored_sections(kelf_patched);
 	kpatch_compare_correlated_elements(kelf_patched);
-	kpatch_check_func_profiling_calls(kelf_patched);
-	kpatch_elf_teardown(kelf_base);
-	kpatch_elf_free(kelf_base);
-
-
 	kpatch_mark_ignored_functions_same(kelf_patched);
 	kpatch_mark_ignored_sections_same(kelf_patched);
+	kpatch_check_func_profiling_calls(kelf_patched);
+	kpatch_elf_teardown(kelf_orig);
+	kpatch_elf_free(kelf_orig);
 
 	kpatch_include_standard_elements(kelf_patched);
 	num_changed = kpatch_include_changed_functions(kelf_patched);
@@ -3786,7 +3852,6 @@ int main(int argc, char *argv[])
 			log_debug("no changed functions were found, but callbacks exist\n");
 		else {
 			log_debug("no changed functions were found\n");
-			free(hint);
 			return EXIT_STATUS_NO_CHANGE;
 		}
 	}
@@ -3802,11 +3867,6 @@ int main(int argc, char *argv[])
 	 */
 	kpatch_elf_teardown(kelf_patched);
 
-	for (sym_comp = base_locals; sym_comp && sym_comp->name; sym_comp++)
-		free(sym_comp->name);
-	free(base_locals);
-	free(hint);
-
 	kpatch_no_sibling_calls_ppc64le(kelf_out);
 
 	/* create strings, patches, and dynrelas sections */
@@ -3851,7 +3911,7 @@ int main(int argc, char *argv[])
 	kpatch_create_strtab(kelf_out);
 	kpatch_create_symtab(kelf_out);
 	kpatch_dump_kelf(kelf_out);
-	kpatch_write_output_elf(kelf_out, kelf_patched->elf, output_obj);
+	kpatch_write_output_elf(kelf_out, kelf_patched->elf, output_obj, 0664);
 
 	lookup_close(lookup);
 	kpatch_elf_free(kelf_patched);
diff --git a/kpatch-build/create-klp-module.c b/kpatch-build/create-klp-module.c
index e0b62e6..d1b03fe 100644
--- a/kpatch-build/create-klp-module.c
+++ b/kpatch-build/create-klp-module.c
@@ -503,7 +503,7 @@ int main(int argc, char *argv[])
 	kpatch_create_strtab(kelf);
 	kpatch_create_symtab(kelf);
 
-	kpatch_write_output_elf(kelf, kelf->elf, arguments.args[1]);
+	kpatch_write_output_elf(kelf, kelf->elf, arguments.args[1], 0664);
 	kpatch_elf_teardown(kelf);
 	kpatch_elf_free(kelf);
 
diff --git a/kpatch-build/create-kpatch-module.c b/kpatch-build/create-kpatch-module.c
index 05978ed..2884f93 100644
--- a/kpatch-build/create-kpatch-module.c
+++ b/kpatch-build/create-kpatch-module.c
@@ -47,6 +47,9 @@ static void create_dynamic_rela_sections(struct kpatch_elf *kelf, struct section
 	struct symbol *sym;
 	struct rela *rela;
 	unsigned int index, nr, offset, dest_offset, objname_offset, name_offset;
+	unsigned int type;
+	long addend;
+	char *target_name;
 
 	ksyms = ksymsec->data->d_buf;
 	krelas = krelasec->data->d_buf;
@@ -93,9 +96,17 @@ static void create_dynamic_rela_sections(struct kpatch_elf *kelf, struct section
 		name_offset = (unsigned int)rela->addend;
 
 		/* Fill in dynrela entry */
+		type = krelas[index].type;
+		addend = krelas[index].addend;
+		if (type == R_X86_64_64 && (addend > INT_MAX || addend <= INT_MIN)) {
+			target_name = (char *)strsec->data->d_buf + name_offset;
+			ERROR("got R_X86_64_64 dynrela for '%s' with addend too large or too small for an int: %lx",
+				target_name, addend);
+		}
+
 		dynrelas[index].src = ksym->src;
-		dynrelas[index].addend = krelas[index].addend;
-		dynrelas[index].type = krelas[index].type;
+		dynrelas[index].addend = addend;
+		dynrelas[index].type = type;
 		dynrelas[index].external = krelas[index].external;
 		dynrelas[index].sympos = ksym->sympos;
 
@@ -246,7 +257,7 @@ int main(int argc, char *argv[])
 	kpatch_create_strtab(kelf);
 	kpatch_create_symtab(kelf);
 
-	kpatch_write_output_elf(kelf, kelf->elf, arguments.args[1]);
+	kpatch_write_output_elf(kelf, kelf->elf, arguments.args[1], 0664);
 	kpatch_elf_teardown(kelf);
 	kpatch_elf_free(kelf);
 
diff --git a/kpatch-build/gcc-plugins/gcc-common.h b/kpatch-build/gcc-plugins/gcc-common.h
index 501df31..443faf6 100644
--- a/kpatch-build/gcc-plugins/gcc-common.h
+++ b/kpatch-build/gcc-plugins/gcc-common.h
@@ -34,7 +34,9 @@
 #include "ggc.h"
 #include "timevar.h"
 
+#if BUILDING_GCC_VERSION < 10000
 #include "params.h"
+#endif
 
 #if BUILDING_GCC_VERSION <= 4009
 #include "pointer-set.h"
@@ -836,6 +838,7 @@ static inline gimple gimple_build_assign_with_ops(enum tree_code subcode, tree l
 	return gimple_build_assign(lhs, subcode, op1, op2 PASS_MEM_STAT);
 }
 
+#if BUILDING_GCC_VERSION < 10000
 template <>
 template <>
 inline bool is_a_helper<const ggoto *>::test(const_gimple gs)
@@ -849,6 +852,7 @@ inline bool is_a_helper<const greturn *>::test(const_gimple gs)
 {
 	return gs->code == GIMPLE_RETURN;
 }
+#endif
 
 static inline gasm *as_a_gasm(gimple stmt)
 {
diff --git a/kpatch-build/gcc-plugins/ppc64le-plugin.c b/kpatch-build/gcc-plugins/ppc64le-plugin.c
index 181438c..e3ec20f 100644
--- a/kpatch-build/gcc-plugins/ppc64le-plugin.c
+++ b/kpatch-build/gcc-plugins/ppc64le-plugin.c
@@ -3,6 +3,18 @@
 
 #define PLUGIN_NAME "ppc64le-plugin"
 
+#if BUILDING_GCC_VERSION < 10000
+#define CALL_LOCAL		"*call_local_aixdi"
+#define CALL_NONLOCAL		"*call_nonlocal_aixdi"
+#define CALL_VALUE_LOCAL	"*call_value_local_aixdi"
+#define CALL_VALUE_NONLOCAL	"*call_value_nonlocal_aixdi"
+#else
+#define CALL_LOCAL		"*call_localdi"
+#define CALL_NONLOCAL		"*call_nonlocal_aixdi"
+#define CALL_VALUE_LOCAL	"*call_value_localdi"
+#define CALL_VALUE_NONLOCAL	"*call_value_nonlocal_aixdi"
+#endif
+
 int plugin_is_GPL_compatible;
 
 struct plugin_info plugin_info = {
@@ -29,13 +41,13 @@ static unsigned int ppc64le_plugin_execute(void)
 		if (!name)
 			continue;
 
-		if (!strcmp(name , "*call_local_aixdi"))
+		if (!strcmp(name , CALL_LOCAL))
 			local_code = code;
-		else if (!strcmp(name , "*call_nonlocal_aixdi"))
+		else if (!strcmp(name , CALL_NONLOCAL))
 			nonlocal_code = code;
-		else if (!strcmp(name, "*call_value_local_aixdi"))
+		else if (!strcmp(name, CALL_VALUE_LOCAL))
 			value_local_code = code;
-		else if (!strcmp(name, "*call_value_nonlocal_aixdi"))
+		else if (!strcmp(name, CALL_VALUE_NONLOCAL))
 			value_nonlocal_code = code;
 
 		if (nonlocal_code != -1 && local_code != -1 &&
@@ -46,8 +58,7 @@ static unsigned int ppc64le_plugin_execute(void)
 found:
 	if (nonlocal_code == -1 || local_code == -1 ||
 	    value_nonlocal_code == -1 || value_local_code == -1) {
-		fprintf(stderr, PLUGIN_NAME ": can't find call instruction codes");
-		return 1;
+		error("%s: cannot find call instruction codes", PLUGIN_NAME);
 	}
 
 	/* Convert local calls to non-local */
diff --git a/kpatch-build/kpatch-build b/kpatch-build/kpatch-build
index dd490ae..eedf383 100755
--- a/kpatch-build/kpatch-build
+++ b/kpatch-build/kpatch-build
@@ -45,16 +45,18 @@ SRCDIR="$CACHEDIR/src"
 RPMTOPDIR="$CACHEDIR/buildroot"
 VERSIONFILE="$CACHEDIR/version"
 TEMPDIR="$CACHEDIR/tmp"
+ENVFILE="$TEMPDIR/kpatch-build.env"
 LOGFILE="$CACHEDIR/build.log"
 RELEASE_FILE=/etc/os-release
 DEBUG=0
 SKIPCLEANUP=0
-SKIPGCCCHECK=0
+SKIPCOMPILERCHECK=0
 ARCH_KCFLAGS=""
 DEBUG_KCFLAGS=""
 declare -a PATCH_LIST
 APPLIED_PATCHES=0
 OOT_MODULE=
+KLP_REPLACE=1
 
 warn() {
 	echo "ERROR: $1" >&2
@@ -88,6 +90,10 @@ logger() {
 	fi
 }
 
+save_env() {
+	export -p | grep -wv -e 'OLDPWD=' -e 'PWD=' > "$ENVFILE"
+}
+
 verify_patch_files() {
 	local path
 	local dir
@@ -148,6 +154,12 @@ cleanup() {
 	# restore original vmlinux if it was overwritten by sourcedir build
 	[[ -e "$TEMPDIR/vmlinux" ]] && mv -f "$TEMPDIR/vmlinux" "$SRCDIR/"
 
+	# restore original link-vmlinux.sh if we updated it for the build
+	[[ -e "$TEMPDIR/link-vmlinux.sh" ]] && mv -f "$TEMPDIR/link-vmlinux.sh" "$SRCDIR/scripts"
+
+	# restore original Makefile.modfinal if we updated it for the build
+	[[ -e "$TEMPDIR/Makefile.modfinal" ]] && mv -f "$TEMPDIR/Makefile.modfinal" "$SRCDIR/scripts"
+
 	[[ "$DEBUG" -eq 0 ]] && rm -rf "$TEMPDIR"
 	rm -rf "$RPMTOPDIR"
 	unset KCFLAGS
@@ -179,7 +191,46 @@ kernel_version_gte() {
 }
 
 kernel_is_rhel() {
-	[[ "$ARCHVERSION" =~ \.el[78]\. ]]
+	[[ "$ARCHVERSION" =~ \.el[789] ]]
+}
+
+rhel_kernel_version_gte() {
+        [  "${ARCHVERSION}" = "$(echo -e "${ARCHVERSION}\\n$1" | sort -rV | head -n1)" ]
+}
+
+# klp.arch relocations were supported prior to v5.8
+# and prior to 4.18.0-240.el8
+use_klp_arch()
+{
+	if kernel_is_rhel; then
+		! rhel_kernel_version_gte 4.18.0-240.el8
+	else
+		! kernel_version_gte 5.8.0
+	fi
+}
+
+rhel_kernel_version_gte() {
+        [  "${ARCHVERSION}" = "$(echo -e "${ARCHVERSION}\\n$1" | sort -rV | head -n1)" ]
+}
+
+# klp.arch relocations were supported prior to v5.8
+# and prior to 4.18.0-284.el8
+use_klp_arch()
+{
+	if kernel_is_rhel; then
+		! rhel_kernel_version_gte 4.18.0-284.el8
+	else
+		! kernel_version_gte 5.8.0
+	fi
+}
+
+support_klp_replace()
+{
+	if kernel_is_rhel; then
+		rhel_kernel_version_gte 4.18.0-193.el8
+	else
+		kernel_version_gte 5.1.0
+	fi
 }
 
 find_dirs() {
@@ -216,10 +267,11 @@ find_core_symvers() {
 }
 
 gcc_version_from_file() {
-	readelf -p .comment "$1" | grep -o 'GCC:.*' | head -n 1
+	readelf -p .comment "$1" | grep -m 1 -o 'GCC:.*'
 }
 
 gcc_version_check() {
+	local target="$1"
 	local c="$TEMPDIR/test.c" o="$TEMPDIR/test.o"
 	local out gccver kgccver
 
@@ -228,11 +280,7 @@ gcc_version_check() {
 	echo 'void main(void) {}' > "$c"
 	out="$(gcc -c -pg -ffunction-sections -o "$o" "$c" 2>&1)"
 	gccver="$(gcc_version_from_file "$o")"
-	if [[ -n "$OOT_MODULE" ]]; then
-		kgccver="$(gcc_version_from_file "$OOT_MODULE")"
-	else
-		kgccver="$(gcc_version_from_file "$VMLINUX")"
-	fi
+	kgccver="$(gcc_version_from_file "$target")"
 
 	if [[ -n "$out" ]]; then
 		warn "gcc >= 4.8 required for -pg -ffunction-settings"
@@ -251,7 +299,31 @@ gcc_version_check() {
 		warn "gcc/kernel version mismatch"
 		echo "gcc version:    $gccver"
 		echo "kernel version: $kgccver"
-		echo "Install the matching gcc version (recommended) or use --skip-gcc-check"
+		echo "Install the matching gcc version (recommended) or use --skip-compiler-check"
+		echo "to skip the version matching enforcement (not recommended)"
+		return 1
+	fi
+
+	return
+}
+
+clang_version_from_file() {
+	readelf -p .comment "$1" | grep -m 1 -Eo 'clang version [0-9.]+'
+}
+
+clang_version_check() {
+	local target="$1"
+	local clangver kclangver
+
+	clangver=$(clang --version | grep -m 1 -Eo 'clang version [0-9.]+')
+	kclangver="$(clang_version_from_file "$target")"
+
+	# ensure clang version matches that used to build the kernel
+	if [[ "$clangver" != "$kclangver" ]]; then
+		warn "clang/kernel version mismatch"
+		echo "clang version:    $clangver"
+		echo "kernel version:   $kclangver"
+		echo "Install the matching clang version (recommended) or use --skip-compiler-check"
 		echo "to skip the version matching enforcement (not recommended)"
 		return 1
 	fi
@@ -262,6 +334,7 @@ gcc_version_check() {
 find_special_section_data_ppc64le() {
 
 	[[ "$CONFIG_JUMP_LABEL" -eq 0 ]] && AWK_OPTIONS="-vskip_j=1"
+	[[ "$CONFIG_PRINTK_INDEX" -eq 0 ]] && AWK_OPTIONS="$AWK_OPTIONS -vskip_i=1"
 
 	SPECIAL_VARS="$(readelf -wi "$VMLINUX" |
 		gawk --non-decimal-data '
@@ -272,21 +345,24 @@ find_special_section_data_ppc64le() {
 		b == 0 && /DW_AT_name.* bug_entry[[:space:]]*$/ {b = 1; next}
 		e == 0 && /DW_AT_name.* exception_table_entry[[:space:]]*$/ {e = 1; next}
 		j == 0 && /DW_AT_name.* jump_entry[[:space:]]*$/ {j = 1; next}
+		i == 0 && /DW_AT_name.* pi_entry[[:space:]]*$/ {i = 1; next}
 
 		# Reset state unless this abbrev describes the struct size
 		f == 1 && !/DW_AT_byte_size/ { f = 0; next }
 		b == 1 && !/DW_AT_byte_size/ { b = 0; next }
 		e == 1 && !/DW_AT_byte_size/ { e = 0; next }
 		j == 1 && !/DW_AT_byte_size/ { j = 0; next }
+		i == 1 && !/DW_AT_byte_size/ { i = 0; next }
 
 		# Now that we know the size, stop parsing for it
 		f == 1 {printf("export FIXUP_STRUCT_SIZE=%d\n", $4); f = 2}
 		b == 1 {printf("export BUG_STRUCT_SIZE=%d\n", $4); b = 2}
 		e == 1 {printf("export EX_STRUCT_SIZE=%d\n", $4); e = 2}
 		j == 1 {printf("export JUMP_STRUCT_SIZE=%d\n", $4); j = 2}
+		i == 1 {printf("export PRINTK_INDEX_STRUCT_SIZE=%d\n", $4); i = 2}
 
 		# Bail out once we have everything
-		f == 2 && b == 2 && e == 2 && (j == 2 || skip_j) {exit}')"
+		f == 2 && b == 2 && e == 2 && (j == 2 || skip_j) && (i == 2 || skip_i) {exit}')"
 
 	[[ -n "$SPECIAL_VARS" ]] && eval "$SPECIAL_VARS"
 
@@ -294,6 +370,7 @@ find_special_section_data_ppc64le() {
 	[[ -z "$BUG_STRUCT_SIZE" ]] && die "can't find special struct bug_entry size"
 	[[ -z "$EX_STRUCT_SIZE" ]]  && die "can't find special struct exception_table_entry size"
 	[[ -z "$JUMP_STRUCT_SIZE" && "$CONFIG_JUMP_LABEL" -ne 0 ]]  && die "can't find special struct jump_entry size"
+	[[ -z "$PRINTK_INDEX_STRUCT_SIZE" && "$CONFIG_PRINTK_INDEX" -ne 0 ]]  && die "can't find special struct pi_entry size"
 
 	return
 }
@@ -307,12 +384,14 @@ find_special_section_data() {
 	[[ "$CONFIG_PARAVIRT" -eq 0 ]] && AWK_OPTIONS="-vskip_p=1"
 	[[ "$CONFIG_UNWINDER_ORC" -eq 0 ]] && AWK_OPTIONS="$AWK_OPTIONS -vskip_o=1"
 	[[ "$CONFIG_JUMP_LABEL" -eq 0 ]] && AWK_OPTIONS="$AWK_OPTIONS -vskip_j=1"
+	[[ "$CONFIG_PRINTK_INDEX" -eq 0 ]] && AWK_OPTIONS="$AWK_OPTIONS -vskip_i=1"
+	! kernel_version_gte 5.10.0 && AWK_OPTIONS="$AWK_OPTIONS -vskip_s=1"
 
 	# If $AWK_OPTIONS are blank gawk would treat "" as a blank script
 	# shellcheck disable=SC2086
 	SPECIAL_VARS="$(readelf -wi "$VMLINUX" |
 		gawk --non-decimal-data $AWK_OPTIONS '
-		BEGIN { a = b = p = e = o = j = 0 }
+		BEGIN { a = b = p = e = o = j = s = i = 0 }
 
 		# Set state if name matches
 		a == 0 && /DW_AT_name.* alt_instr[[:space:]]*$/ {a = 1; next}
@@ -321,6 +400,8 @@ find_special_section_data() {
 		e == 0 && /DW_AT_name.* exception_table_entry[[:space:]]*$/ {e = 1; next}
 		o == 0 && /DW_AT_name.* orc_entry[[:space:]]*$/ {o = 1; next}
 		j == 0 && /DW_AT_name.* jump_entry[[:space:]]*$/ {j = 1; next}
+		s == 0 && /DW_AT_name.* static_call_site[[:space:]]*$/ {s = 1; next}
+		i == 0 && /DW_AT_name.* pi_entry[[:space:]]*$/ {i = 1; next}
 
 		# Reset state unless this abbrev describes the struct size
 		a == 1 && !/DW_AT_byte_size/ { a = 0; next }
@@ -329,6 +410,8 @@ find_special_section_data() {
 		e == 1 && !/DW_AT_byte_size/ { e = 0; next }
 		o == 1 && !/DW_AT_byte_size/ { o = 0; next }
 		j == 1 && !/DW_AT_byte_size/ { j = 0; next }
+		s == 1 && !/DW_AT_byte_size/ { s = 0; next }
+		i == 1 && !/DW_AT_byte_size/ { i = 0; next }
 
 		# Now that we know the size, stop parsing for it
 		a == 1 {printf("export ALT_STRUCT_SIZE=%d\n", $4); a = 2}
@@ -337,9 +420,11 @@ find_special_section_data() {
 		e == 1 {printf("export EX_STRUCT_SIZE=%d\n", $4); e = 2}
 		o == 1 {printf("export ORC_STRUCT_SIZE=%d\n", $4); o = 2}
 		j == 1 {printf("export JUMP_STRUCT_SIZE=%d\n", $4); j = 2}
+		s == 1 {printf("export STATIC_CALL_STRUCT_SIZE=%d\n", $4); s = 2}
+		i == 1 {printf("export PRINTK_INDEX_STRUCT_SIZE=%d\n", $4); i = 2}
 
 		# Bail out once we have everything
-		a == 2 && b == 2 && (p == 2 || skip_p) && e == 2 && (o == 2 || skip_o) && (j == 2 || skip_j) {exit}')"
+		a == 2 && b == 2 && (p == 2 || skip_p) && e == 2 && (o == 2 || skip_o) && (j == 2 || skip_j) && (s == 2 || skip_s) && (i == 2 || skip_i) {exit}')"
 
 	[[ -n "$SPECIAL_VARS" ]] && eval "$SPECIAL_VARS"
 
@@ -349,7 +434,10 @@ find_special_section_data() {
 	[[ -z "$PARA_STRUCT_SIZE" && "$CONFIG_PARAVIRT" -ne 0 ]] && die "can't find special struct paravirt_patch_site size"
 	[[ -z "$ORC_STRUCT_SIZE" && "$CONFIG_UNWINDER_ORC" -ne 0 ]] && die "can't find special struct orc_entry size"
 	[[ -z "$JUMP_STRUCT_SIZE" && "$CONFIG_JUMP_LABEL" -ne 0 ]] && die "can't find special struct jump_entry size"
+	[[ -z "$PRINTK_INDEX_STRUCT_SIZE" && "$CONFIG_PRINTK_INDEX" -ne 0 ]] && die "can't find special struct pi_entry size"
+	[[ -z "$STATIC_CALL_STRUCT_SIZE" ]] && kernel_version_gte 5.10.0 && die "can't find special struct static_call_site size"
 
+	save_env
 	return
 }
 
@@ -436,28 +524,29 @@ module_name_string() {
 
 usage() {
 	echo "usage: $(basename "$0") [options] <patch1 ... patchN>" >&2
-	echo "		patchN             Input patchfile(s)" >&2
-	echo "		-h, --help         Show this help message" >&2
-	echo "		-a, --archversion  Specify the kernel arch version" >&2
-	echo "		-r, --sourcerpm    Specify kernel source RPM" >&2
-	echo "		-s, --sourcedir    Specify kernel source directory" >&2
-	echo "		-c, --config       Specify kernel config file" >&2
-	echo "		-v, --vmlinux      Specify original vmlinux" >&2
-	echo "		-j, --jobs         Specify the number of make jobs" >&2
-	echo "		-t, --target       Specify custom kernel build targets" >&2
-	echo "		-n, --name         Specify the name of the kpatch module" >&2
-	echo "		-o, --output       Specify output folder" >&2
-	echo "		-d, --debug        Enable 'xtrace' and keep scratch files" >&2
-	echo "		                   in <CACHEDIR>/tmp" >&2
-	echo "		                   (can be specified multiple times)" >&2
-	echo "		-e, --oot-module   Enable patching out-of-tree module," >&2
-	echo "		                   specify current version of module" >&2
-	echo "		--skip-cleanup     Skip post-build cleanup" >&2
-	echo "		--skip-gcc-check   Skip gcc version matching check" >&2
-	echo "		                   (not recommended)" >&2
+	echo "		patchN                  Input patchfile(s)" >&2
+	echo "		-h, --help              Show this help message" >&2
+	echo "		-a, --archversion       Specify the kernel arch version" >&2
+	echo "		-r, --sourcerpm         Specify kernel source RPM" >&2
+	echo "		-s, --sourcedir         Specify kernel source directory" >&2
+	echo "		-c, --config            Specify kernel config file" >&2
+	echo "		-v, --vmlinux           Specify original vmlinux" >&2
+	echo "		-j, --jobs              Specify the number of make jobs" >&2
+	echo "		-t, --target            Specify custom kernel build targets" >&2
+	echo "		-n, --name              Specify the name of the kpatch module" >&2
+	echo "		-o, --output            Specify output folder" >&2
+	echo "		-d, --debug             Enable 'xtrace' and keep scratch files" >&2
+	echo "		                        in <CACHEDIR>/tmp" >&2
+	echo "		                        (can be specified multiple times)" >&2
+	echo "		-e, --oot-module        Enable patching out-of-tree module," >&2
+	echo "		                        specify current version of module" >&2
+	echo "		-R, --non-replace       Disable replace patch (replace is on by default)" >&2
+	echo "		--skip-cleanup          Skip post-build cleanup" >&2
+	echo "		--skip-compiler-check   Skip compiler version matching check" >&2
+	echo "		                        (not recommended)" >&2
 }
 
-options="$(getopt -o ha:r:s:c:v:j:t:n:o:de: -l "help,archversion:,sourcerpm:,sourcedir:,config:,vmlinux:,jobs:,target:,name:,output:,oot-module:,debug,skip-gcc-check,skip-cleanup" -- "$@")" || die "getopt failed"
+options="$(getopt -o ha:r:s:c:v:j:t:n:o:de:R -l "help,archversion:,sourcerpm:,sourcedir:,config:,vmlinux:,jobs:,target:,name:,output:,oot-module:,debug,skip-gcc-check,skip-compiler-check,skip-cleanup,non-replace" -- "$@")" || die "getopt failed"
 
 eval set -- "$options"
 
@@ -520,13 +609,19 @@ while [[ $# -gt 0 ]]; do
 		OOT_MODULE="$(readlink -f "$2")"
 		shift
 		;;
+	-R|--non-replace)
+		KLP_REPLACE=0
+		;;
 	--skip-cleanup)
 		echo "Skipping cleanup"
 		SKIPCLEANUP=1
 		;;
 	--skip-gcc-check)
-		echo "WARNING: Skipping gcc version matching check (not recommended)"
-		SKIPGCCCHECK=1
+		echo "DEPRECATED: --skip-gcc-check is deprecated, use --skip-compiler-check instead"
+		;&
+	--skip-compiler-check)
+		echo "WARNING: Skipping compiler version matching check (not recommended)"
+		SKIPCOMPILERCHECK=1
 		;;
 	*)
 		[[ "$1" = "--" ]] && shift && continue
@@ -607,7 +702,7 @@ fi
 # shellcheck disable=SC1090
 [[ -f "$RELEASE_FILE" ]] && source "$RELEASE_FILE"
 DISTRO="$ID"
-if [[ "$DISTRO" = fedora ]] || [[ "$DISTRO" = rhel ]] || [[ "$DISTRO" = ol ]] || [[ "$DISTRO" = centos ]]; then
+if [[ "$DISTRO" = fedora ]] || [[ "$DISTRO" = rhel ]] || [[ "$DISTRO" = ol ]] || [[ "$DISTRO" = centos ]] || [[ "$DISTRO" = openEuler ]]; then
 	[[ -z "$VMLINUX" ]] && VMLINUX="/usr/lib/debug/lib/modules/$ARCHVERSION/vmlinux"
 	[[ -e "$VMLINUX" ]] || die "kernel-debuginfo-$ARCHVERSION not installed"
 
@@ -625,19 +720,16 @@ elif [[ "$DISTRO" = ubuntu ]] || [[ "$DISTRO" = debian ]]; then
 
 	export PATH="/usr/lib/ccache:$PATH"
 fi
+save_env
 
 find_dirs || die "can't find supporting tools"
 
-if [[ "$SKIPGCCCHECK" -eq 0 ]]; then
-	gcc_version_check || die
-fi
-
 if [[ -n "$USERSRCDIR" ]]; then
 	echo "Using source directory at $USERSRCDIR"
 
 	# save original vmlinux before it gets overwritten by sourcedir build
 	if [[ -z "$OOT_MODULE" ]] && [[ "$VMLINUX" -ef "$SRCDIR"/vmlinux ]]; then
-		cp -f "$VMLINUX" "$TEMPDIR/vmlinux"
+		cp -f "$VMLINUX" "$TEMPDIR/vmlinux" || die
 		VMLINUX="$TEMPDIR/vmlinux"
 	fi
 
@@ -678,7 +770,7 @@ else
 		rm -rf "$SRCDIR/.git"
 
 		if [[ "$ARCHVERSION" == *-* ]]; then
-			echo "-${ARCHVERSION##*-}" > "$SRCDIR/localversion" || die
+			sed -i "s/^EXTRAVERSION.*/EXTRAVERSION = -${ARCHVERSION##*-}/" "$SRCDIR/Makefile" || die
 		fi
 
 		echo "$ARCHVERSION" > "$VERSIONFILE" || die
@@ -731,7 +823,9 @@ fi
 
 [[ -z "$CONFIGFILE" ]] && CONFIGFILE="$SRCDIR"/.config
 [[ ! -e "$CONFIGFILE" ]] && die "can't find config file"
-[[ ! "$CONFIGFILE" -ef "$SRCDIR"/.config ]] && cp -f "$CONFIGFILE" "$SRCDIR/.config"
+if [[ ! "$CONFIGFILE" -ef "$SRCDIR"/.config ]] ; then
+	cp -f "$CONFIGFILE" "$SRCDIR/.config" || die
+fi
 
 # kernel option checking
 grep -q "CONFIG_DEBUG_INFO=y" "$CONFIGFILE" || die "kernel doesn't have 'CONFIG_DEBUG_INFO' enabled"
@@ -745,16 +839,25 @@ USE_KLP_ARCH=0
 CONFIG_PARAVIRT=0
 CONFIG_UNWINDER_ORC=0
 CONFIG_JUMP_LABEL=0
+CONFIG_MODVERSIONS=0
+CONFIG_CC_IS_CLANG=0
+CONFIG_LD_IS_LLD=0
 
 if grep -q "CONFIG_LIVEPATCH=y" "$CONFIGFILE" && (kernel_is_rhel || kernel_version_gte 4.9.0); then
 
 	USE_KLP=1
 
-	if kernel_is_rhel || ! kernel_version_gte 5.8.0; then
+	if use_klp_arch; then
 		USE_KLP_ARCH=1
 		KPATCH_LDFLAGS="--unique=.parainstructions --unique=.altinstructions"
 		CDO_FLAGS="--klp-arch"
 	fi
+
+	if [[  "$KLP_REPLACE" -eq 1 ]] ; then
+		support_klp_replace || die "The kernel doesn't support klp replace"
+	else
+		export CFLAGS_MODULE="$CFLAGS_MODULE -DKLP_REPLACE_ENABLE=false"
+	fi
 else
 	# No support for livepatch in the kernel. Kpatch core module is needed.
 
@@ -770,12 +873,46 @@ fi
 grep -q "CONFIG_PARAVIRT=y"     "$CONFIGFILE" && CONFIG_PARAVIRT=1
 grep -q "CONFIG_UNWINDER_ORC=y" "$CONFIGFILE" && CONFIG_UNWINDER_ORC=1
 grep -q "CONFIG_JUMP_LABEL=y"   "$CONFIGFILE" && CONFIG_JUMP_LABEL=1
+grep -q "CONFIG_MODVERSIONS=y"  "$CONFIGFILE" && CONFIG_MODVERSIONS=1
+grep -q "CONFIG_CC_IS_CLANG=y"  "$CONFIGFILE" && CONFIG_CC_IS_CLANG=1
+grep -q "CONFIG_LD_IS_LLD=y"    "$CONFIGFILE" && CONFIG_LD_IS_LLD=1
 
 # unsupported kernel option checking
 grep -q "CONFIG_DEBUG_INFO_SPLIT=y" "$CONFIGFILE" && die "kernel option 'CONFIG_DEBUG_INFO_SPLIT' not supported"
 grep -q "CONFIG_GCC_PLUGIN_LATENT_ENTROPY=y" "$CONFIGFILE" && die "kernel option 'CONFIG_GCC_PLUGIN_LATENT_ENTROPY' not supported"
 grep -q "CONFIG_GCC_PLUGIN_RANDSTRUCT=y" "$CONFIGFILE" && die "kernel option 'CONFIG_GCC_PLUGIN_RANDSTRUCT' not supported"
 
+# CONFIG_DEBUG_INFO_BTF invokes pahole, for which some versions don't
+# support extended ELF sections.  Disable the BTF typeinfo generation in
+# link-vmlinux.sh and Makefile.modfinal since kpatch doesn't care about
+# that anyway.
+if grep -q "CONFIG_DEBUG_INFO_BTF=y" "$CONFIGFILE" ; then
+	cp -f "$SRCDIR/scripts/link-vmlinux.sh" "$TEMPDIR/link-vmlinux.sh" || die
+	sed -i 's/CONFIG_DEBUG_INFO_BTF/DISABLED_FOR_KPATCH_BUILD/g' "$SRCDIR"/scripts/link-vmlinux.sh || die
+
+	if [[ -e "$SRCDIR/scripts/Makefile.modfinal" ]]; then
+		cp -f "$SRCDIR/scripts/Makefile.modfinal" "$TEMPDIR/Makefile.modfinal" || die
+		sed -i 's/CONFIG_DEBUG_INFO_BTF_MODULES/DISABLED_FOR_KPATCH_BUILD/g' "$SRCDIR"/scripts/Makefile.modfinal || die
+	fi
+fi
+
+if [[ "$CONFIG_CC_IS_CLANG" -eq 1 ]]; then
+	echo "WARNING: Clang support is experimental"
+fi
+
+if [[ "$SKIPCOMPILERCHECK" -eq 0 ]]; then
+	if [[ -n "$OOT_MODULE" ]]; then
+		target="$OOT_MODULE"
+	else
+		target="$VMLINUX"
+	fi
+	if [[ "$CONFIG_CC_IS_CLANG" -eq 0 ]]; then
+		gcc_version_check "$target" || die
+	else
+		clang_version_check "$target" || die
+	fi
+fi
+
 echo "Testing patch file(s)"
 cd "$SRCDIR" || die
 verify_patch_files
@@ -797,26 +934,45 @@ find_special_section_data
 if [[ $DEBUG -ge 4 ]]; then
 	export KPATCH_GCC_DEBUG=1
 fi
+save_env
 
 echo "Building original source"
 [[ -n "$OOT_MODULE" ]] || ./scripts/setlocalversion --save-scmversion || die
 unset KPATCH_GCC_TEMPDIR
+
+KPATCH_CC_PREFIX="$TOOLSDIR/kpatch-cc "
+declare -a MAKEVARS
+if [ "$CONFIG_CC_IS_CLANG" -eq 1 ]; then
+	MAKEVARS+=("CC=${KPATCH_CC_PREFIX}clang")
+	MAKEVARS+=("HOSTCC=clang")
+else
+	MAKEVARS+=("CC=${KPATCH_CC_PREFIX}gcc")
+fi
+
+if [ "$CONFIG_LD_IS_LLD" -eq 1 ]; then
+	MAKEVARS+=("LD=${KPATCH_CC_PREFIX}ld.lld")
+	MAKEVARS+=("HOSTLD=ld.lld")
+else
+	MAKEVARS+=("LD=${KPATCH_CC_PREFIX}ld")
+fi
+
+
 # $TARGETS used as list, no quotes.
 # shellcheck disable=SC2086
-CROSS_COMPILE="$TOOLSDIR/kpatch-gcc " make "-j$CPUS" $TARGETS 2>&1 | logger || die
+make "${MAKEVARS[@]}" "-j$CPUS" $TARGETS 2>&1 | logger || die
+
+# Save original module symvers
+cp -f "$SRCDIR/Module.symvers" "$TEMPDIR/Module.symvers" || die
 
 echo "Building patched source"
 apply_patches
 mkdir -p "$TEMPDIR/orig" "$TEMPDIR/patched"
-KPATCH_GCC_TEMPDIR="$TEMPDIR"
-export KPATCH_GCC_TEMPDIR
-KPATCH_GCC_SRCDIR="$SRCDIR"
-export KPATCH_GCC_SRCDIR
+export KPATCH_GCC_TEMPDIR="$TEMPDIR"
+export KPATCH_GCC_SRCDIR="$SRCDIR"
+save_env
 # $TARGETS used as list, no quotes.
 # shellcheck disable=SC2086
-CROSS_COMPILE="$TOOLSDIR/kpatch-gcc " \
-	KBUILD_MODPOST_WARN=1 \
-	make "-j$CPUS" $TARGETS 2>&1 | logger || die
+KBUILD_MODPOST_WARN=1 make "${MAKEVARS[@]}" "-j$CPUS" $TARGETS 2>&1 | logger || die
 
 # source.c:(.section+0xFF): undefined reference to `symbol'
 grep "undefined reference" "$LOGFILE" | sed -r "s/^.*\`(.*)'$/\\1/" \
@@ -831,6 +987,29 @@ fi
 
 [[ -n "$OOT_MODULE" ]] || grep -q vmlinux "$SRCDIR/Module.symvers" || die "truncated $SRCDIR/Module.symvers file"
 
+if [[ "$CONFIG_MODVERSIONS" -eq 1 ]]; then
+    while read -ra sym_line; do
+        if [[ ${#sym_line[@]} -lt 4 ]]; then
+            die "Malformed ${TEMPDIR}/Module.symvers file"
+        fi
+
+        sym=${sym_line[1]}
+
+        read -ra patched_sym_line <<< "$(grep "\s$sym\s" "$SRCDIR/Module.symvers")"
+        if [[ ${#patched_sym_line[@]} -lt 4 ]]; then
+            die "Malformed symbol entry for ${sym} in ${SRCDIR}/Module.symvers file"
+        fi
+
+        # Assume that both original and patched symvers have the same format.
+        # In both cases, the symbol should have the same CRC, belong to the same
+        # Module/Namespace and have the same export type.
+        if [[ ${#sym_line[@]} -ne ${#patched_sym_line[@]} || \
+                  "${sym_line[*]}" != "${patched_sym_line[*]}" ]]; then
+            warn "Version disagreement for symbol ${sym}"
+        fi
+    done < "${TEMPDIR}/Module.symvers"
+fi
+
 # Read as words, no quotes.
 # shellcheck disable=SC2013
 for i in $(cat "$TEMPDIR/changed_objs")
@@ -868,6 +1047,14 @@ mkdir output
 declare -a objnames
 CHANGED=0
 ERROR=0
+
+# Prepare OOT module symvers file
+if [[ -n "$OOT_MODULE" ]]; then
+    BUILDDIR="/lib/modules/$ARCHVERSION/build/"
+    cp -f "$SRCDIR/Module.symvers" "$TEMPDIR/Module.symvers" || die
+    awk '{ print $1 "\t" $2 "\t" $3 "\t" $4}' "${BUILDDIR}/Module.symvers" >> "$TEMPDIR/Module.symvers"
+fi
+
 for i in $FILES; do
 	# In RHEL 7 based kernels, copy_user_64.o misuses the .fixup section,
 	# which confuses create-diff-object.  It's fine to skip it, it's an
@@ -892,9 +1079,6 @@ for i in $FILES; do
 			KOBJFILE_PATH="$OOT_MODULE"
 			SYMTAB="${TEMPDIR}/module/${KOBJFILE_NAME}.symtab"
 			SYMVERS_FILE="$TEMPDIR/Module.symvers"
-			BUILDDIR="/lib/modules/$ARCHVERSION/build/"
-			cp "$SRCDIR/Module.symvers" "$SYMVERS_FILE"
-			awk '{ print $1 "\t" $2 "\t" $3 "\t" $4}' "${BUILDDIR}/Module.symvers" >> "$SYMVERS_FILE"
 		else
 			KOBJFILE_NAME=$(basename "${KOBJFILE%.ko}")
 			KOBJFILE_NAME="${KOBJFILE_NAME//-/_}"
@@ -922,7 +1106,7 @@ for i in $FILES; do
 			objnames[${#objnames[@]}]="$KOBJFILE"
 		fi
 	else
-		cp -f "patched/$i" "output/$i"
+		cp -f "patched/$i" "output/$i" || die
 		objnames[${#objnames[@]}]="$KOBJFILE"
 	fi
 done
@@ -946,6 +1130,7 @@ export KCFLAGS="-I$DATADIR/patch $ARCH_KCFLAGS"
 if [[ "$USE_KLP" -eq 0 ]]; then
 	export KCPPFLAGS="-D__KPATCH_MODULE__"
 fi
+save_env
 
 echo "Building patch module: $MODNAME.ko"
 
@@ -962,7 +1147,9 @@ cd "$TEMPDIR/output" || die
 ld -r $KPATCH_LDFLAGS -o ../patch/tmp_output.o $(find . -name "*.o") 2>&1 | logger || die
 
 if [[ "$USE_KLP" -eq 1 ]]; then
-	cp "$TEMPDIR"/patch/tmp_output.o "$TEMPDIR"/patch/output.o || die
+	cp -f "$TEMPDIR"/patch/tmp_output.o "$TEMPDIR"/patch/output.o || die
+	# Avoid MODPOST warning (pre-v5.8) and error (v5.8+) with an empty .cmd file
+	touch "$TEMPDIR"/patch/.output.o.cmd || die
 else
 	# Add .kpatch.checksum for kpatch script
 	md5sum ../patch/tmp_output.o | awk '{printf "%s\0", $1}' > checksum.tmp || die
@@ -970,6 +1157,7 @@ else
 	rm -f checksum.tmp
 	"$TOOLSDIR"/create-kpatch-module "$TEMPDIR"/patch/tmp_output.o "$TEMPDIR"/patch/output.o 2>&1 | logger 1
 	check_pipe_status create-kpatch-module
+	[[ "$rc" -ne 0 ]] && die "create-kpatch-module: exited with return code: $rc"
 fi
 
 cd "$TEMPDIR/patch" || die
@@ -978,18 +1166,50 @@ if [[ -z "$OOT_MODULE" ]]; then
 else
 	KPATCH_BUILD="/lib/modules/$ARCHVERSION/build"
 fi
-KPATCH_BUILD="$KPATCH_BUILD" KPATCH_NAME="$MODNAME" \
+
+# We no longer need kpatch-cc
+for ((idx=0; idx<${#MAKEVARS[@]}; idx++)); do
+    MAKEVARS[$idx]=${MAKEVARS[$idx]/${KPATCH_CC_PREFIX}/}
+done
+
+export KPATCH_BUILD="$KPATCH_BUILD" KPATCH_NAME="$MODNAME" \
 KBUILD_EXTRA_SYMBOLS="$KBUILD_EXTRA_SYMBOLS" \
-KPATCH_LDFLAGS="$KPATCH_LDFLAGS" \
-	make 2>&1 | logger || die
+KPATCH_LDFLAGS="$KPATCH_LDFLAGS"
+save_env
+
+make "${MAKEVARS[@]}" 2>&1 | logger || die
 
 if [[ "$USE_KLP" -eq 1 ]]; then
 	if [[ "$USE_KLP_ARCH" -eq 0 ]]; then
 		extra_flags="--no-klp-arch-sections"
 	fi
-	cp "$TEMPDIR/patch/$MODNAME.ko" "$TEMPDIR/patch/tmp.ko" || die
+	cp -f "$TEMPDIR/patch/$MODNAME.ko" "$TEMPDIR/patch/tmp.ko" || die
 	"$TOOLSDIR"/create-klp-module $extra_flags "$TEMPDIR/patch/tmp.ko" "$TEMPDIR/patch/$MODNAME.ko" 2>&1 | logger 1
 	check_pipe_status create-klp-module
+	[[ "$rc" -ne 0 ]] && die "create-klp-module: exited with return code: $rc"
+fi
+
+if [[ "$CONFIG_MODVERSIONS" -eq 1 ]]; then
+    # Check that final module does not reference symbols with different version
+    # than the target kernel
+    KP_MOD_VALID=true
+    # shellcheck disable=SC2086
+    while read -ra mod_symbol; do
+        if [[ ${#mod_symbol[@]} -lt 2 ]]; then
+            continue
+        fi
+
+        # Check if the symbol exists in the old Module.symvers, and if it does
+        # check that the CRCs are unchanged.
+        if ! awk -v sym="${mod_symbol[1]}" -v crc="${mod_symbol[0]}" \
+             '$2==sym && $1!=crc { exit 1 }' "$TEMPDIR/Module.symvers"; then
+            warn "Patch module references ${mod_symbol[1]} with invalid version"
+            KP_MOD_VALID=false
+        fi
+    done <<< "$(modprobe --dump-modversions $TEMPDIR/patch/$MODNAME.ko)"
+    if ! $KP_MOD_VALID; then
+        die "Patch module referencing altered exported kernel symbols cannot be loaded"
+    fi
 fi
 
 readelf --wide --symbols "$TEMPDIR/patch/$MODNAME.ko" 2>/dev/null | \
@@ -1016,6 +1236,6 @@ UNDEFINED=$(comm -23 <(sort -u "${TEMPDIR}"/undefined_references) \
 
 cp -f "$TEMPDIR/patch/$MODNAME.ko" "$BASE" || die
 
-[[ "$DEBUG" -eq 0 ]] && rm -f "$LOGFILE"
+[[ "$DEBUG" -eq 0 && "$SKIPCLEANUP" -eq 0 ]] && rm -f "$LOGFILE"
 
 echo "SUCCESS"
diff --git a/kpatch-build/kpatch-gcc b/kpatch-build/kpatch-cc
similarity index 89%
rename from kpatch-build/kpatch-gcc
rename to kpatch-build/kpatch-cc
index 9663290..476436f 100755
--- a/kpatch-build/kpatch-gcc
+++ b/kpatch-build/kpatch-cc
@@ -13,7 +13,7 @@ fi
 
 declare -a args=("$@")
 
-if [[ "$TOOLCHAINCMD" =~ "gcc" ]] ; then
+if [[ "$TOOLCHAINCMD" =~ ^(.*-)?gcc$ || "$TOOLCHAINCMD" =~ ^(.*-)?clang$ ]] ; then
 	while [ "$#" -gt 0 ]; do
 		if [ "$1" = "-o" ]; then
 			obj="$2"
@@ -42,6 +42,7 @@ if [[ "$TOOLCHAINCMD" =~ "gcc" ]] ; then
 				arch/x86/entry/vdso/*|\
 				drivers/firmware/efi/libstub/*|\
 				arch/powerpc/kernel/prom_init.o|\
+				arch/powerpc/kernel/vdso64/*|\
 				lib/*|\
 				.*.o|\
 				*/.lib_exports.o)
@@ -60,7 +61,7 @@ if [[ "$TOOLCHAINCMD" =~ "gcc" ]] ; then
 		fi
 		shift
 	done
-elif [[ "$TOOLCHAINCMD" = "ld" ]] ; then
+elif [[ "$TOOLCHAINCMD" =~ ^(.*-)?ld || "$TOOLCHAINCMD" =~ ^(.*-)?ld.lld ]] ; then
 	while [ "$#" -gt 0 ]; do
 		if [ "$1" = "-o" ]; then
 			obj="$2"
diff --git a/kpatch-build/kpatch-elf.c b/kpatch-build/kpatch-elf.c
index 6f44159..565a070 100644
--- a/kpatch-build/kpatch-elf.c
+++ b/kpatch-build/kpatch-elf.c
@@ -760,7 +760,8 @@ void kpatch_rebuild_rela_section_data(struct section *sec)
 		ERROR("size mismatch in rebuilt rela section");
 }
 
-void kpatch_write_output_elf(struct kpatch_elf *kelf, Elf *elf, char *outfile)
+void kpatch_write_output_elf(struct kpatch_elf *kelf, Elf *elf, char *outfile,
+			     mode_t mode)
 {
 	int fd;
 	struct section *sec;
@@ -771,8 +772,7 @@ void kpatch_write_output_elf(struct kpatch_elf *kelf, Elf *elf, char *outfile)
 	Elf_Data *data;
 	GElf_Shdr sh;
 
-	/* TODO make this argv */
-	fd = creat(outfile, 0777);
+	fd = creat(outfile, mode);
 	if (fd == -1)
 		ERROR("creat");
 
diff --git a/kpatch-build/kpatch-elf.h b/kpatch-build/kpatch-elf.h
index a3a3526..aeec148 100644
--- a/kpatch-build/kpatch-elf.h
+++ b/kpatch-build/kpatch-elf.h
@@ -67,6 +67,12 @@ struct section {
 	};
 };
 
+enum symbol_strip {
+	SYMBOL_DEFAULT,
+	SYMBOL_USED,
+	SYMBOL_STRIP,
+};
+
 struct symbol {
 	struct list_head list;
 	struct symbol *twin;
@@ -76,12 +82,13 @@ struct symbol {
 	struct section *sec;
 	GElf_Sym sym;
 	char *name;
+	struct object_symbol *lookup_table_file_sym;
 	unsigned int index;
 	unsigned char bind, type;
 	enum status status;
 	union {
 		int include; /* used in the patched elf */
-		int strip; /* used in the output elf */
+		enum symbol_strip strip; /* used in the output elf */
 	};
 	int has_func_profiling;
 };
@@ -165,7 +172,8 @@ struct section *create_section_pair(struct kpatch_elf *kelf, char *name,
 void kpatch_remove_and_free_section(struct kpatch_elf *kelf, char *secname);
 void kpatch_reindex_elements(struct kpatch_elf *kelf);
 void kpatch_rebuild_rela_section_data(struct section *sec);
-void kpatch_write_output_elf(struct kpatch_elf *kelf, Elf *elf, char *outfile);
+void kpatch_write_output_elf(struct kpatch_elf *kelf, Elf *elf, char *outfile,
+			     mode_t mode);
 void kpatch_elf_teardown(struct kpatch_elf *kelf);
 void kpatch_elf_free(struct kpatch_elf *kelf);
 #endif /* _KPATCH_ELF_H_ */
diff --git a/kpatch-build/lookup.c b/kpatch-build/lookup.c
index 6c558a1..5bafd1a 100644
--- a/kpatch-build/lookup.c
+++ b/kpatch-build/lookup.c
@@ -56,7 +56,6 @@ struct lookup_table {
 	int obj_nr, exp_nr;
 	struct object_symbol *obj_syms;
 	struct export_symbol *exp_syms;
-	struct object_symbol *local_syms;
 	char *objname;
 };
 
@@ -70,12 +69,12 @@ struct lookup_table {
 	for (ndx = 0, iter = table->exp_syms; ndx < table->exp_nr; ndx++, iter++)
 
 static bool lookup_exported_symbol(struct lookup_table *table, char *name,
-                                   struct lookup_result *result);
+				   struct lookup_result *result);
 
-static int maybe_discarded_sym(const char *name)
+static bool maybe_discarded_sym(const char *name)
 {
 	if (!name)
-		return 0;
+		return false;
 
 	/*
 	 * Sometimes these symbols are discarded during linking, and sometimes
@@ -86,115 +85,150 @@ static int maybe_discarded_sym(const char *name)
 	if (!strncmp(name, "__exitcall_", 11) ||
 	    !strncmp(name, "__brk_reservation_fn_", 21) ||
 	    !strncmp(name, "__func_stack_frame_non_standard_", 32) ||
-	    !strncmp(name, "__addressable_", 14))
-		return 1;
+	    strstr(name, "__addressable_") ||
+	    strstr(name, "__UNIQUE_ID_") ||
+	    !strncmp(name, ".L.str", 6))
+		return true;
 
-	return 0;
+	return false;
 }
 
-static int locals_match(struct lookup_table *table, int idx,
-                        struct sym_compare_type *child_locals)
+
+static bool locals_match(struct lookup_table *table, int idx,
+			struct symbol *file_sym, struct list_head *sym_list)
 {
-	struct sym_compare_type *child;
-	struct object_symbol *sym;
-	int i, found, ret = 1;
+	struct symbol *sym;
+	struct object_symbol *table_sym;
+	int i, found;
 
 	i = idx + 1;
-    for_each_obj_symbol_continue(i, sym, table) {
-        if (sym->type == STT_FILE)
-            break;
-        if (sym->bind != STB_LOCAL)
-            continue;
-        if (sym->type != STT_FUNC && sym->type != STT_OBJECT)
-            continue;
+	for_each_obj_symbol_continue(i, table_sym, table) {
+		if (table_sym->type == STT_FILE)
+			break;
+		if (table_sym->bind != STB_LOCAL)
+			continue;
+		if (table_sym->type != STT_FUNC && table_sym->type != STT_OBJECT)
+			continue;
 
-        found = 0;
-        for (child = child_locals; child->name; child++) {
-            if (child->type == sym->type &&
-                !strcmp(child->name, sym->name)) {
-                found = 1;
-                break;
-            }
-        }
+		found = 0;
+		sym = file_sym;
+		list_for_each_entry_continue(sym, sym_list, list) {
+			if (sym->type == STT_FILE)
+				break;
+			if (sym->bind != STB_LOCAL)
+				continue;
+
+			if (sym->type == table_sym->type &&
+			    !strcmp(sym->name, table_sym->name)) {
+				found = 1;
+				break;
+			}
+		}
 
-        if (!found) {
-            fprintf(stderr, "Could not find %s (type=%d) in patch\n\n",
+		if (!found) {
+		    fprintf(stderr, "Could not find %s (type=%d) in patch\n\n", 
                     sym->name, sym->type);
-            ret = 0;
+            return false;
         }
-    }
+	}
 
-	for (child = child_locals; child->name; child++) {
+	sym = file_sym;
+	list_for_each_entry_continue(sym, sym_list, list) {
+		if (sym->type == STT_FILE)
+			break;
+		if (sym->bind != STB_LOCAL)
+			continue;
+		if (sym->type != STT_FUNC && table_sym->type != STT_OBJECT)
+			continue;
 		/*
 		 * Symbols which get discarded at link time are missing from
 		 * the lookup table, so skip them.
 		 */
-		if (maybe_discarded_sym(child->name))
+		if (maybe_discarded_sym(sym->name))
 			continue;
 
         // Sometimes these symbols are reordered.
-        if (strstr(child->name, "__PRETTY_FUNCTION__"))
+        if (strstr(sym->name, "__PRETTY_FUNCTION__"))
             continue;
 
 		found = 0;
 		i = idx + 1;
-		for_each_obj_symbol_continue(i, sym, table) {
-			if (sym->type == STT_FILE)
+		for_each_obj_symbol_continue(i, table_sym, table) {
+			if (table_sym->type == STT_FILE)
 				break;
-			if (sym->bind != STB_LOCAL)
-				continue;
-			if (sym->type != STT_FUNC && sym->type != STT_OBJECT)
+			if (table_sym->bind != STB_LOCAL)
 				continue;
-			if (maybe_discarded_sym(sym->name))
+			if (maybe_discarded_sym(table_sym->name))
 				continue;
 
-			if (!strcmp(child->name, sym->name)) {
+			if (sym->type == table_sym->type &&
+			    !strcmp(sym->name, table_sym->name)) {
 				found = 1;
 				break;
 			}
 		}
 
 		if (!found) {
-             fprintf(stderr, "Could not find %s (type=%d) in binary\n",
-                     child->name, child->type);
-			ret = 0;
+		    fprintf(stderr, "Could not find %s (type=%d) in binary\n",
+                     sym->name, sym->type);
+			return false;
         }
 	}
 
-	return ret;
+	return true;
 }
 
-static void find_local_syms(struct lookup_table *table, char *hint,
-			    struct sym_compare_type *child_locals)
+static void find_local_syms(struct lookup_table *table, struct symbol *file_sym,
+		struct list_head *sym_list)
 {
 	struct object_symbol *sym;
+	struct object_symbol *lookup_table_file_sym = NULL;
 	int i;
 
-	if (!child_locals)
-		return;
-
 	for_each_obj_symbol(i, sym, table) {
 		if (sym->type != STT_FILE)
 			continue;
-
-		if (strcmp(hint, sym->name) != 0)
+		if (strcmp(file_sym->name, sym->name))
 			continue;
-
-        printf("Match Sections: %s <-> %s\n", hint, sym->name);
-
-		if (!locals_match(table, i, child_locals))
+        printf("Match Sections: %s <-> %s\n", file_sym->name, sym->name);
+		if (!locals_match(table, i, file_sym, sym_list))
 			continue;
-
-        if (table->local_syms)
+		if (lookup_table_file_sym)
 			ERROR("found duplicate matches for %s local symbols in %s symbol table",
-			      hint, table->objname);
+			      file_sym->name, table->objname);
 
-		table->local_syms = sym;
+		lookup_table_file_sym = sym;
 	}
 
-	if (!table->local_syms)
-		ERROR("couldn't find matching '%s' local symbols in %s symbol table",
-		      hint, table->objname);
+	if (!lookup_table_file_sym)
+		ERROR("couldn't find matching %s local symbols in %s symbol table",
+		      file_sym->name, table->objname);
+
+	list_for_each_entry_continue(file_sym, sym_list, list) {
+		if (file_sym->type == STT_FILE)
+			break;
+		file_sym->lookup_table_file_sym = lookup_table_file_sym;
+	}
+}
+
+/*
+ * Because there can be duplicate symbols and duplicate filenames we need to
+ * correlate each symbol from the elf file to it's corresponding symbol in
+ * lookup table. Both the elf file and the lookup table can be split on
+ * STT_FILE symbols into blocks of symbols originating from a single source
+ * file. We then compare local symbol lists from both blocks and store the
+ * pointer to STT_FILE symbol in lookup table for later use in
+ * lookup_local_symbol().
+ */
+static void find_local_syms_multiple(struct lookup_table *table,
+		struct kpatch_elf *kelf)
+{
+	struct symbol *sym;
+
+	list_for_each_entry(sym, &kelf->symbols, list) {
+		if (sym->type == STT_FILE)
+			find_local_syms(table, sym, &kelf->symbols);
+	}
 }
 
 /* Strip the path and replace '-' with '_' */
@@ -346,8 +380,7 @@ static void symtab_read(struct lookup_table *table, char *path)
 }
 
 struct lookup_table *lookup_open(char *symtab_path, char *objname,
-				 char *symvers_path, char *hint,
-				 struct sym_compare_type *locals)
+				 char *symvers_path, struct kpatch_elf *kelf)
 {
 	struct lookup_table *table;
 
@@ -361,7 +394,7 @@ struct lookup_table *lookup_open(char *symtab_path, char *objname,
     // wf-userlang: We no longer read the Module.symvers file.
     // Instead, we consider all undfined symbols.
     // symvers_read(table, symvers_path);
-	find_local_syms(table, hint, locals);
+	find_local_syms_multiple(table, kelf);
 
 	return table;
 }
@@ -384,22 +417,21 @@ void lookup_close(struct lookup_table *table)
 	free(table);
 }
 
-static bool lookup_local_symbol(struct lookup_table *table, char *name,
+static bool lookup_local_symbol(struct lookup_table *table,
+				struct symbol *lookup_sym,
 				struct lookup_result *result)
 {
 	struct object_symbol *sym;
 	unsigned long sympos = 0;
 	int i, in_file = 0;
 
-	if (!table->local_syms)
-		return false;
-
 	memset(result, 0, sizeof(*result));
 	for_each_obj_symbol(i, sym, table) {
-		if (sym->bind == STB_LOCAL && !strcmp(sym->name, name))
+		if (sym->bind == STB_LOCAL && !strcmp(sym->name,
+					lookup_sym->name))
 			sympos++;
 
-		if (table->local_syms == sym) {
+		if (lookup_sym->lookup_table_file_sym == sym) {
 			in_file = 1;
 			continue;
 		}
@@ -410,10 +442,11 @@ static bool lookup_local_symbol(struct lookup_table *table, char *name,
 		if (sym->type == STT_FILE)
 			break;
 
-		if (sym->bind == STB_LOCAL && !strcmp(sym->name, name)) {
-
+		if (sym->bind == STB_LOCAL && !strcmp(sym->name,
+					lookup_sym->name)) {
 			if (result->objname)
-				ERROR("duplicate local symbol found for %s", name);
+				ERROR("duplicate local symbol found for %s",
+						lookup_sym->name);
 
 			result->objname		= table->objname;
 			result->addr		= sym->addr;
@@ -488,14 +521,14 @@ static bool lookup_global_symbol(struct lookup_table *table, char *name,
 	return !!result->objname;
 }
 
-bool lookup_symbol(struct lookup_table *table, char *name,
+bool lookup_symbol(struct lookup_table *table, struct symbol *sym,
 		   struct lookup_result *result)
 {
-	if (lookup_local_symbol(table, name, result))
+	if (lookup_local_symbol(table, sym, result))
 		return true;
 
-	if (lookup_global_symbol(table, name, result))
+	if (lookup_global_symbol(table, sym->name, result))
 		return true;
 
-	return lookup_exported_symbol(table, name, result);
+	return lookup_exported_symbol(table, sym->name, result);
 }
diff --git a/kpatch-build/lookup.h b/kpatch-build/lookup.h
index 8d29900..e1277f1 100644
--- a/kpatch-build/lookup.h
+++ b/kpatch-build/lookup.h
@@ -2,6 +2,7 @@
 #define _LOOKUP_H_
 
 #include <stdbool.h>
+#include "kpatch-elf.h"
 
 struct lookup_table;
 
@@ -13,16 +14,10 @@ struct lookup_result {
 	bool global, exported;
 };
 
-struct sym_compare_type {
-	char *name;
-	int type;
-};
-
 struct lookup_table *lookup_open(char *symtab_path, char *objname,
-				 char *symvers_path, char *hint,
-				 struct sym_compare_type *locals);
+				 char *symvers_path, struct kpatch_elf *kelf);
 void lookup_close(struct lookup_table *table);
-bool lookup_symbol(struct lookup_table *table, char *name,
+bool lookup_symbol(struct lookup_table *table, struct symbol *sym,
 		   struct lookup_result *result);
 
 #endif /* _LOOKUP_H_ */
diff --git a/kpatch/kpatch b/kpatch/kpatch
index 6cd9ad0..7fecb23 100755
--- a/kpatch/kpatch
+++ b/kpatch/kpatch
@@ -25,9 +25,10 @@
 
 INSTALLDIR=/var/lib/kpatch
 SCRIPTDIR="$(readlink -f "$(dirname "$(type -p "$0")")")"
-VERSION="0.9.1"
+VERSION="0.9.5"
 POST_ENABLE_WAIT=15	# seconds
 POST_SIGNAL_WAIT=60	# seconds
+MODULE_REF_WAIT=15	# seconds
 
 # How many times to try loading the patch if activeness safety check fails.
 MAX_LOAD_ATTEMPTS=5
@@ -35,7 +36,7 @@ MAX_LOAD_ATTEMPTS=5
 RETRY_INTERVAL=2
 
 usage_cmd() {
-	printf '   %-20s\n      %s\n' "$1" "$2" >&2
+	printf '   %-20s\n%s\n' "$1" "$(fmt -w 80 <(echo "      $2"))" >&2
 }
 
 usage () {
@@ -56,7 +57,7 @@ usage () {
 	echo >&2
 	usage_cmd "list" "list installed patch modules"
 	echo >&2
-	usage_cmd "signal" "signal/poke any process stalling the current patch transition"
+	usage_cmd "signal" "signal/poke any process stalling the current patch transition. This is only useful on systems that have the sysfs livepatch signal interface. On other systems, the signaling should be done automatically by the OS and this subcommand is a no-op."
 	echo >&2
 	usage_cmd "version" "display the kpatch version"
 	exit 1
@@ -125,8 +126,12 @@ find_core_module() {
 	return 1
 }
 
+kpatch_core_loaded() {
+	[[ -d "/sys/kernel/kpatch" ]]
+}
+
 core_loaded () {
-	grep -q -e "T klp_enable_patch" -e "T kpatch_register" /proc/kallsyms
+	[[ -d "/sys/kernel/kpatch" ]] || [[ -d "/sys/kernel/livepatch" ]]
 }
 
 get_module_name () {
@@ -217,7 +222,7 @@ show_stalled_processes() {
 	echo "Stalled processes:"
 	for proc_task in /proc/[0-9]*/task/[0-9]*; do
 		tid=${proc_task#*/task/}
-		is_stalled "$module" "$tid" && echo "$tid $(cat "$proc_task"/comm 2>/dev/null)"
+		is_stalled "$module" "$tid" && echo -e "$tid $(cat "$proc_task"/comm 2>/dev/null)\nstack:\n$(cat "$proc_task"/stack 2>/dev/null)"
 	done
 }
 
@@ -232,6 +237,9 @@ signal_stalled_processes() {
 	if [[ -e "/sys/kernel/livepatch/$module/signal" ]] ; then
 		echo "signaling stalled process(es):"
 		echo 1 > "/sys/kernel/livepatch/$module/signal"
+        else
+            warn "Livepatch process signaling is performed automatically on your system."
+            warn "Skipping manual process signaling."
 	fi
 }
 
@@ -265,6 +273,31 @@ wait_for_patch_transition() {
 	return 1
 }
 
+module_ref_count() {
+	local modname="$1"
+	[[ $(cat "/sys/module/$modname/refcnt" 2>/dev/null) -gt "0" ]]
+}
+
+wait_for_zero_module_ref_count() {
+	local modname="$1"
+	local i=0
+
+	# We can't rely on a zero refcount with kpatch.ko as it
+	# implements KPATCH_FORCE_UNSAFE with an additional reference on
+	# kpatch-patch modules to avoid potential crashes.
+	kpatch_core_loaded && return 0
+
+	module_ref_count "$modname" || return 0
+
+	echo "waiting (up to $MODULE_REF_WAIT seconds) for module refcount..."
+	for (( i=0; i<MODULE_REF_WAIT; i++ )); do
+		module_ref_count "$modname" || return 0
+		sleep 1s
+	done
+
+	return 1
+}
+
 load_module () {
 	local module="$1"
 
@@ -291,6 +324,7 @@ load_module () {
 				echo "module already loaded, re-enabling"
 				echo 1 > "${moddir}/enabled" || die "failed to re-enable module $modname"
 				if ! wait_for_patch_transition "$modname" ; then
+					show_stalled_processes
 					echo "module $modname did not complete its transition, disabling..."
 					echo 0 > "${moddir}/enabled" || die "failed to disable module $modname"
 					wait_for_patch_transition "$modname"
@@ -304,6 +338,9 @@ load_module () {
 			echo "module named $modname already loaded and enabled"
 		fi
 	else
+		# Cleanup possibly loaded, but disabled patch.
+		remove_module "$modname" "quiet"
+
 		echo "loading patch module: $module"
 		local i=0
 		while true; do
@@ -327,6 +364,7 @@ load_module () {
 	fi
 
 	if ! wait_for_patch_transition "$modname" ; then
+		show_stalled_processes
 		echo "module $modname did not complete its transition, unloading..."
 		unload_module "$modname"
 		die "error: failed to load module $modname (transition stalled)"
@@ -379,10 +417,18 @@ disable_patch_strict () {
 }
 
 remove_module () {
-	echo "unloading patch module: $1"
+	local modname="$1"
+
+	if ! wait_for_zero_module_ref_count "$modname"; then
+		die "failed to unload module $modname (refcnt)"
+	fi
+
+	if [[ "$#" -lt 2 || "$2" != "quiet" ]] ; then
+		echo "unloading patch module: $modname"
+	fi
 	# ignore any error here because rmmod can fail if the module used
 	# KPATCH_FORCE_UNSAFE.
-	rmmod "$1" 2> /dev/null || return 0
+	rmmod "$modname" 2> /dev/null || return 0
 }
 
 unload_module () {
@@ -534,10 +580,12 @@ case "$1" in
 	fi
 
 	[[ ! -e "$MODULE" ]] && die "$PATCH is not installed for kernel $KVER"
-	
 
 	echo "uninstalling $PATCH ($KVER)"
 	rm -f "$MODULE" || die "failed to uninstall module $PATCH"
+	rmdir --ignore-fail-on-non-empty "$INSTALLDIR/$KVER" || die "failed to remove directory $INSTALLDIR/$KVER"
+	rmdir --ignore-fail-on-non-empty "$INSTALLDIR" || die "failed to remove directory $INSTALLDIR"
+
 	;;
 
 "list")
diff --git a/man/kpatch-build.1 b/man/kpatch-build.1
index 35bc3c3..4483a4a 100644
--- a/man/kpatch-build.1
+++ b/man/kpatch-build.1
@@ -51,15 +51,19 @@ effect.
    Enable patching out-of-tree module,
    specify current version of module
 
+-R|--non-replace
+   Disable replace flag of KLP
+   (replace is on by default)
+
 --skip-cleanup
    Skip post-build cleanup
 
---skip-gcc-check
-   Skips check that ensures that the system gcc version and
-   the gcc version that built the kernel match.  Skipping this
-   check is not recommended, but is useful if the exact gcc
+--skip-compiler-check
+   Skips check that ensures that the system compiler version and
+   the compiler version that built the kernel match.  Skipping this
+   check is not recommended, but is useful if the exact compiler
    version is not available or is not easily installed. Use
-   only when confident that the two versions of gcc output
+   only when confident that the two versions of compiler output
    identical objects for a given target.  Otherwise, use of
    this option might result in unexpected changed objects
    being detected.
diff --git a/man/kpatch.1 b/man/kpatch.1
index a30bdb7..51c9811 100644
--- a/man/kpatch.1
+++ b/man/kpatch.1
@@ -36,7 +36,10 @@ list
        list installed patch modules
 
 signal
-       signal/poke any process stalling the current patch transition
+       signal/poke any process stalling the current patch transition.
+       This is only useful on systems that have the sysfs livepatch signal interface.
+       On other systems, the signaling should be done automatically by the OS and
+       this subcommand is a no-op.
 
 version
        display the kpatch version
diff --git a/test/difftree.sh b/test/difftree.sh
index 19629e7..9a0ebf4 100755
--- a/test/difftree.sh
+++ b/test/difftree.sh
@@ -14,17 +14,18 @@
 #set -x
 
 OBJDIR="$HOME/.kpatch/obj"
-SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
+# shellcheck disable=SC2046
+SCRIPTDIR=$(readlink -f $(dirname $(type -p "$0")))
 TEMPDIR=$(mktemp -d)
 RESULTSDIR="$TEMPDIR/results"
-VMVLINUX="/usr/lib/debug/lib/modules/$(uname -r)/vmlinux" # path for F20
 
 if [[ ! -d $OBJDIR ]]; then
 	echo "please run kpatch-build to populate the object tree in $OBJDIR"
 fi
 
 cd "$OBJDIR" || exit 1
-for i in $(find * -name '*.o')
+# shellcheck disable=SC2044
+for i in $(find ./* -name '*.o')
 do
 	# copied from kpatch-build/kpatch-gcc; keep in sync
 	case $i in
@@ -46,13 +47,14 @@ do
 		;;
 	esac
 	# skip objects that are the linked product of more than one object file
-	[[ $(readelf -s $i | awk '$4=="FILE" {n++} END {print n}') -ne 1 ]] && continue
-	$SCRIPTDIR/../kpatch-build/create-diff-object $i $i /usr/lib/debug/lib/modules/$(uname -r)/vmlinux "$TEMPDIR/output.o" > "$TEMPDIR/log.txt" 2>&1
+	[[ $(readelf -s "$i" | awk '$4=="FILE" {n++} END {print n}') -ne 1 ]] && continue
+	"$SCRIPTDIR"/../kpatch-build/create-diff-object "$i" "$i" "/usr/lib/debug/lib/modules/$(uname -r)/vmlinux" "$TEMPDIR/output.o" > "$TEMPDIR/log.txt" 2>&1
 	RETCODE=$?
 	# expect RETCODE to be 3 indicating no change
 	[[ $RETCODE -eq 3 ]] && continue
 	# otherwise record error
-	mkdir -p $RESULTSDIR/$(dirname $i) || exit 1
+	# shellcheck disable=SC2046
+	mkdir -p "$RESULTSDIR"/$(dirname "$i") || exit 1
 	cp "$i" "$RESULTSDIR/$i" || exit 1
 	case $RETCODE in
 		139)
@@ -82,9 +84,10 @@ rm -f "$TEMPDIR/log.txt" > /dev/null 2>&1
 cd "$RESULTSDIR" || exit 1
 echo ""
 echo "Results:"
-for i in $(find * -iname '*.log')
+# shellcheck disable=SC2044
+for i in $(find ./* -iname '*.log')
 do
-	echo $(cat $i | head -1 | cut -f2-3 -d':')
+	head -1 "$i" | cut -f2-3 -d':'
 done | sort | uniq -c | sort -n -r | tee "$TEMPDIR/results.log"
 
 echo "results are in $TEMPDIR"
diff --git a/test/integration/Makefile b/test/integration/Makefile
index fb6e601..e18d8d0 100644
--- a/test/integration/Makefile
+++ b/test/integration/Makefile
@@ -10,13 +10,13 @@ local: slow
 remote: remote_slow
 
 slow: clean
-	./kpatch-test -d $(PATCH_DIR) $(PATCHES)
+	./kpatch-test --kpatch-build-opts="$(KPATCH_BUILD_OPTS)" -d $(PATCH_DIR) $(PATCHES)
 
 quick: clean
-	./kpatch-test -d $(PATCH_DIR) --quick $(PATCHES)
+	./kpatch-test --kpatch-build-opts="$(KPATCH_BUILD_OPTS)" -d $(PATCH_DIR) --quick $(PATCHES)
 
 cached:
-	./kpatch-test -d $(PATCH_DIR) --cached $(PATCHES)
+	./kpatch-test --kpatch-build-opts="$(KPATCH_BUILD_OPTS)" -d $(PATCH_DIR) --cached $(PATCHES)
 
 vagrant: vagrant-quick
 
diff --git a/test/integration/centos-7 b/test/integration/centos-7
new file mode 120000
index 0000000..66d70af
--- /dev/null
+++ b/test/integration/centos-7
@@ -0,0 +1 @@
+rhel-7.8/
\ No newline at end of file
diff --git a/test/integration/centos-7/README b/test/integration/centos-7/README
deleted file mode 100644
index dac0f25..0000000
--- a/test/integration/centos-7/README
+++ /dev/null
@@ -1 +0,0 @@
-3.10.0-327.36.3.el7.x86_64
diff --git a/test/integration/centos-7/data-new.patch b/test/integration/centos-7/data-new.patch
deleted file mode 100644
index 879828c..0000000
--- a/test/integration/centos-7/data-new.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
---- src.orig/fs/proc/meminfo.c	2017-09-22 15:27:21.699056179 -0400
-+++ src/fs/proc/meminfo.c	2017-09-22 15:27:24.102066130 -0400
-@@ -20,6 +20,8 @@ void __attribute__((weak)) arch_report_m
- {
- }
- 
-+static int foo = 5;
-+
- static int meminfo_proc_show(struct seq_file *m, void *v)
- {
- 	struct sysinfo i;
-@@ -106,6 +108,7 @@ static int meminfo_proc_show(struct seq_
- #ifdef CONFIG_TRANSPARENT_HUGEPAGE
- 		"AnonHugePages:  %8lu kB\n"
- #endif
-+		"kpatch: %d"
- 		,
- 		K(i.totalram),
- 		K(i.freeram),
-@@ -167,6 +170,7 @@ static int meminfo_proc_show(struct seq_
- 		,K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *
- 		   HPAGE_PMD_NR)
- #endif
-+		,foo
- 		);
- 
- 	hugetlb_report_meminfo(m);
diff --git a/test/integration/centos-7/data-read-mostly.patch.disable b/test/integration/centos-7/data-read-mostly.patch.disable
deleted file mode 100644
index 611662f..0000000
--- a/test/integration/centos-7/data-read-mostly.patch.disable
+++ /dev/null
@@ -1,11 +0,0 @@
-diff -Nupr src.orig/net/core/dev.c src/net/core/dev.c
---- src.orig/net/core/dev.c	2017-09-22 15:27:21.759056428 -0400
-+++ src/net/core/dev.c	2017-09-22 15:27:25.244070859 -0400
-@@ -4012,6 +4012,7 @@ ncls:
- 		case RX_HANDLER_PASS:
- 			break;
- 		default:
-+			printk("BUG!\n");
- 			BUG();
- 		}
- 	}
diff --git a/test/integration/centos-7/fixup-section.patch b/test/integration/centos-7/fixup-section.patch
deleted file mode 100644
index 18d13b5..0000000
--- a/test/integration/centos-7/fixup-section.patch
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/fs/readdir.c b/fs/readdir.c
-index febd02dfbe2d..064db7bd70d0 100644
---- a/fs/readdir.c
-+++ b/fs/readdir.c
-@@ -176,6 +176,7 @@ static int filldir(void * __buf, const char * name, int namlen, loff_t offset,
- 			goto efault;
- 	}
- 	dirent = buf->current_dir;
-+	asm("nop");
- 	if (__put_user(d_ino, &dirent->d_ino))
- 		goto efault;
- 	if (__put_user(reclen, &dirent->d_reclen))
diff --git a/test/integration/centos-7/gcc-static-local-var-6.patch b/test/integration/centos-7/gcc-static-local-var-6.patch
deleted file mode 100644
index bd5493c..0000000
--- a/test/integration/centos-7/gcc-static-local-var-6.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-diff --git a/net/ipv6/netfilter.c b/net/ipv6/netfilter.c
-index a9d587a..23336ed 100644
---- a/net/ipv6/netfilter.c
-+++ b/net/ipv6/netfilter.c
-@@ -106,6 +106,8 @@ static int nf_ip6_reroute(struct sk_buff *skb,
-	return 0;
- }
-
-+#include "kpatch-macros.h"
-+
- static int nf_ip6_route(struct net *net, struct dst_entry **dst,
-			struct flowi *fl, bool strict)
- {
-@@ -119,6 +121,9 @@ static int nf_ip6_route(struct net *net, struct dst_entry **dst,
-	struct dst_entry *result;
-	int err;
-
-+	if (!jiffies)
-+		printk("kpatch nf_ip6_route foo\n");
-+
-	result = ip6_route_output(net, sk, &fl->u.ip6);
-	err = result->error;
-	if (err)
diff --git a/test/integration/centos-7/gcc-static-local-var.patch b/test/integration/centos-7/gcc-static-local-var.patch
deleted file mode 100644
index 2dab9db..0000000
--- a/test/integration/centos-7/gcc-static-local-var.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-diff -Nupr src.orig/arch/x86/kernel/ldt.c src/arch/x86/kernel/ldt.c
---- src.orig/arch/x86/kernel/ldt.c	2017-09-22 15:27:20.847052651 -0400
-+++ src/arch/x86/kernel/ldt.c	2017-09-22 15:27:35.573113632 -0400
-@@ -98,6 +98,12 @@ static inline int copy_ldt(mm_context_t
- 	return 0;
- }
- 
-+void hi_there(void)
-+{
-+	if (!jiffies)
-+		printk("hi there\n");
-+}
-+
- /*
-  * we do not have to muck with descriptors here, that is
-  * done in switch_mm() as needed.
-@@ -107,6 +113,8 @@ int init_new_context(struct task_struct
- 	struct mm_struct *old_mm;
- 	int retval = 0;
- 
-+	hi_there();
-+
- 	mutex_init(&mm->context.lock);
- 	mm->context.size = 0;
- 	old_mm = current->mm;
diff --git a/test/integration/centos-7/meminfo-cmdline-rebuild-SLOW-LOADED.test.disabled b/test/integration/centos-7/meminfo-cmdline-rebuild-SLOW-LOADED.test.disabled
deleted file mode 100755
index e2b647d..0000000
--- a/test/integration/centos-7/meminfo-cmdline-rebuild-SLOW-LOADED.test.disabled
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/bash
-
-grep VMALLOCCHUNK /proc/meminfo && grep kpatch=1 /proc/cmdline
diff --git a/test/integration/centos-7/meminfo-cmdline-rebuild-SLOW.patch.disabled b/test/integration/centos-7/meminfo-cmdline-rebuild-SLOW.patch.disabled
deleted file mode 100644
index 882e15b..0000000
--- a/test/integration/centos-7/meminfo-cmdline-rebuild-SLOW.patch.disabled
+++ /dev/null
@@ -1,37 +0,0 @@
-Disabled due to CSWTITCH issue from https://github.com/dynup/kpatch/issues/876
----
-diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
---- src.orig/fs/proc/cmdline.c	2017-09-22 15:27:21.698056175 -0400
-+++ src/fs/proc/cmdline.c	2017-09-22 15:27:37.842123028 -0400
-@@ -5,7 +5,7 @@
- 
- static int cmdline_proc_show(struct seq_file *m, void *v)
- {
--	seq_printf(m, "%s\n", saved_command_line);
-+	seq_printf(m, "%s kpatch=1\n", saved_command_line);
- 	return 0;
- }
- 
-diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
---- src.orig/fs/proc/meminfo.c	2017-09-22 15:27:21.699056179 -0400
-+++ src/fs/proc/meminfo.c	2017-09-22 15:27:37.843123032 -0400
-@@ -99,7 +99,7 @@ static int meminfo_proc_show(struct seq_
- 		"Committed_AS:   %8lu kB\n"
- 		"VmallocTotal:   %8lu kB\n"
- 		"VmallocUsed:    %8lu kB\n"
--		"VmallocChunk:   %8lu kB\n"
-+		"VMALLOCCHUNK:   %8lu kB\n"
- #ifdef CONFIG_MEMORY_FAILURE
- 		"HardwareCorrupted: %5lu kB\n"
- #endif
-diff -Nupr src.orig/include/linux/kernel.h src/include/linux/kernel.h
---- src.orig/include/linux/kernel.h	2017-09-22 15:27:20.379050713 -0400
-+++ src/include/linux/kernel.h	2017-09-22 15:27:37.843123032 -0400
-@@ -2,6 +2,7 @@
- #define _LINUX_KERNEL_H
- 
- 
-+
- #include <stdarg.h>
- #include <linux/linkage.h>
- #include <linux/stddef.h>
diff --git a/test/integration/centos-7/module-kvm-fixup.patch b/test/integration/centos-7/module-kvm-fixup.patch
deleted file mode 100644
index 174ad65..0000000
--- a/test/integration/centos-7/module-kvm-fixup.patch
+++ /dev/null
@@ -1,12 +0,0 @@
-diff -Nupr src.orig/arch/x86/kvm/vmx.c src/arch/x86/kvm/vmx.c
---- src.orig/arch/x86/kvm/vmx.c	2017-09-22 15:27:20.853052676 -0400
-+++ src/arch/x86/kvm/vmx.c	2017-09-22 15:27:43.583146801 -0400
-@@ -10597,6 +10597,8 @@ static int vmx_check_intercept(struct kv
- 			       struct x86_instruction_info *info,
- 			       enum x86_intercept_stage stage)
- {
-+	if (!jiffies)
-+		printk("kpatch vmx_check_intercept\n");
- 	return X86EMUL_CONTINUE;
- }
- 
diff --git a/test/integration/centos-7/module-shadow.patch.disabled b/test/integration/centos-7/module-shadow.patch.disabled
deleted file mode 100644
index eace531..0000000
--- a/test/integration/centos-7/module-shadow.patch.disabled
+++ /dev/null
@@ -1,25 +0,0 @@
-Index: src/arch/x86/kvm/vmx.c
-===================================================================
---- src.orig/arch/x86/kvm/vmx.c
-+++ src/arch/x86/kvm/vmx.c
-@@ -11406,10 +11406,20 @@ static void vmx_leave_nested(struct kvm_
-  * It should only be called before L2 actually succeeded to run, and when
-  * vmcs01 is current (it doesn't leave_guest_mode() or switch vmcss).
-  */
-+#include <linux/livepatch.h>
- static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
- 			struct vmcs12 *vmcs12,
- 			u32 reason, unsigned long qualification)
- {
-+	int *kpatch;
-+
-+	kpatch = klp_shadow_alloc(vcpu, 0, sizeof(*kpatch),
-+				     GFP_KERNEL, NULL, NULL);
-+	if (kpatch) {
-+		klp_shadow_get(vcpu, 0);
-+		klp_shadow_free(vcpu, 0, NULL);
-+	}
-+
- 	load_vmcs12_host_state(vcpu, vmcs12);
- 	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
- 	vmcs12->exit_qualification = qualification;
diff --git a/test/integration/centos-7/remote-setup b/test/integration/centos-7/remote-setup
deleted file mode 100755
index dfcb7ae..0000000
--- a/test/integration/centos-7/remote-setup
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/bin/bash -x
-
-# install rpms on a Fedora 22 system to prepare it for kpatch integration tests
-
-set -o errexit
-
-[[ $UID != 0 ]] && sudo=sudo
-
-warn() {
-	echo "ERROR: $1" >&2
-}
-
-die() {
-	warn "$@"
-	exit 1
-}
-
-install_rpms() {
-	# crude workaround for a weird dnf bug where it fails to download
-	$sudo dnf install -y $* || $sudo dnf install -y $*
-}
-
-install_rpms gcc elfutils elfutils-devel pesign openssl numactl-devel wget patchutils
-
-$sudo dnf builddep -y kernel || $sudo dnf builddep -y kernel
-
-# install kernel debuginfo and devel RPMs for target kernel
-kverrel=$(uname -r)
-kverrel=${kverrel%.x86_64}
-kver=${kverrel%%-*}
-krel=${kverrel#*-}
-install_rpms https://kojipkgs.fedoraproject.org/packages/kernel/$kver/$krel/x86_64/kernel-debuginfo-$kver-$krel.x86_64.rpm https://kojipkgs.fedoraproject.org/packages/kernel/$kver/$krel/x86_64/kernel-debuginfo-common-x86_64-$kver-$krel.x86_64.rpm https://kojipkgs.fedoraproject.org/packages/kernel/$kver/$krel/x86_64/kernel-devel-$kver-$krel.x86_64.rpm
-
-# install version of gcc which was used to build the target kernel
-gccver=$(gcc --version |head -n1 |cut -d' ' -f3-)
-kgccver=$(readelf -p .comment /usr/lib/debug/lib/modules/$(uname -r)/vmlinux |grep GCC: | tr -s ' ' | cut -d ' ' -f6-)
-if [[ $gccver != $kgccver ]]; then
-	gver=$(echo $kgccver | awk '{print $1}')
-	grel=$(echo $kgccver | sed 's/.*-\(.*\))/\1/')
-	grel=$grel.$(rpm -q gcc |sed 's/.*\.\(.*\)\.x86_64/\1/')
-	install_rpms https://kojipkgs.fedoraproject.org/packages/gcc/$gver/$grel/x86_64/cpp-$gver-$grel.x86_64.rpm https://kojipkgs.fedoraproject.org/packages/gcc/$gver/$grel/x86_64/gcc-$gver-$grel.x86_64.rpm https://kojipkgs.fedoraproject.org/packages/gcc/$gver/$grel/x86_64/libgomp-$gver-$grel.x86_64.rpm
-fi
-
-install_rpms ccache
-ccache -M 5G
diff --git a/test/integration/centos-7/replace-section-references.patch b/test/integration/centos-7/replace-section-references.patch
deleted file mode 100644
index e41bba9..0000000
--- a/test/integration/centos-7/replace-section-references.patch
+++ /dev/null
@@ -1,12 +0,0 @@
-diff -Nupr src.orig/arch/x86/kvm/x86.c src/arch/x86/kvm/x86.c
---- src.orig/arch/x86/kvm/x86.c	2017-09-22 15:27:20.852052672 -0400
-+++ src/arch/x86/kvm/x86.c	2017-09-22 15:27:49.362170732 -0400
-@@ -248,6 +248,8 @@ static void shared_msr_update(unsigned s
- 
- void kvm_define_shared_msr(unsigned slot, u32 msr)
- {
-+	if (!jiffies)
-+		printk("kpatch kvm define shared msr\n");
- 	BUG_ON(slot >= KVM_NR_SHARED_MSRS);
- 	shared_msrs_global.msrs[slot] = msr;
- 	if (slot >= shared_msrs_global.nr)
diff --git a/test/integration/centos-7/special-static-2.patch b/test/integration/centos-7/special-static-2.patch
deleted file mode 100644
index 146d5b5..0000000
--- a/test/integration/centos-7/special-static-2.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-diff -Nupr src.orig/arch/x86/kvm/x86.c src/arch/x86/kvm/x86.c
---- src.orig/arch/x86/kvm/x86.c	2017-09-22 15:27:20.852052672 -0400
-+++ src/arch/x86/kvm/x86.c	2017-09-22 15:27:51.744180596 -0400
-@@ -2093,12 +2093,20 @@ static void record_steal_time(struct kvm
- 		&vcpu->arch.st.steal, sizeof(struct kvm_steal_time));
- }
- 
-+void kpatch_kvm_x86_foo(void)
-+{
-+	if (!jiffies)
-+		printk("kpatch kvm x86 foo\n");
-+}
-+
- int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
- {
- 	bool pr = false;
- 	u32 msr = msr_info->index;
- 	u64 data = msr_info->data;
- 
-+	kpatch_kvm_x86_foo();
-+
- 	switch (msr) {
- 	case MSR_AMD64_NB_CFG:
- 	case MSR_IA32_UCODE_REV:
diff --git a/test/integration/centos-8 b/test/integration/centos-8
new file mode 120000
index 0000000..64546c1
--- /dev/null
+++ b/test/integration/centos-8
@@ -0,0 +1 @@
+rhel-8.2
\ No newline at end of file
diff --git a/test/integration/kpatch-test b/test/integration/kpatch-test
index a781eee..ca5e783 100755
--- a/test/integration/kpatch-test
+++ b/test/integration/kpatch-test
@@ -40,16 +40,18 @@
 
 shopt -s nullglob
 
-SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
-ROOTDIR="$(readlink -f $SCRIPTDIR/../..)"
-# TODO: option to use system-installed binaries instead
+# shellcheck disable=SC2046
+SCRIPTDIR=$(readlink -f $(dirname $(type -p "$0")))
+ROOTDIR=$(readlink -f "$SCRIPTDIR/../..")
 KPATCH="sudo $ROOTDIR/kpatch/kpatch"
-RMMOD="sudo rmmod"
 unset CCACHE_HASHDIR
 KPATCHBUILD="$ROOTDIR"/kpatch-build/kpatch-build
 ERROR=0
 LOG=test.log
-rm -f *.log
+DYNDEBUG_CONTROL=/sys/kernel/debug/dynamic_debug/control
+DYNDEBUG_ENABLED=1
+ARCHVERSION="$(uname -r)"
+rm -f ./*.log
 
 PATCHDIR="${PATCHDIR:-$PWD}"
 declare -a PATCH_LIST
@@ -62,9 +64,11 @@ usage() {
 	echo "		-c, --cached	Don't rebuild patch modules" >&2
 	echo "		-d, --directory	Patch directory" >&2
 	echo "		-q, --quick	Test combined patch and -FAIL patches only" >&2
+	echo "		--system-kpatch-tools	Use kpatch tools installed in the system" >&2
+	echo "		--kpatch-build-opts	Additional options to pass to kpatch-build" >&2
 }
 
-options=$(getopt -o hcd:q -l "help,cached,directory,quick" -- "$@") || exit 1
+options=$(getopt -o hcd:q -l "help,cached,directory,quick,system-kpatch-tools,kpatch-build-opts:" -- "$@") || exit 1
 
 eval set -- "$options"
 
@@ -84,6 +88,14 @@ while [[ $# -gt 0 ]]; do
 	-q|--quick)
 		QUICK=1
 		;;
+	--system-kpatch-tools)
+		KPATCH="sudo kpatch"
+		KPATCHBUILD="kpatch-build"
+		;;
+	--kpatch-build-opts)
+		KPATCHBUILD_OPTS=$2
+		shift
+		;;
 	*)
 		[[ "$1" = "--" ]] && shift && continue
 		PATCH_LIST+=("$1")
@@ -93,8 +105,8 @@ while [[ $# -gt 0 ]]; do
 done
 
 if [[ ${#PATCH_LIST[@]} = 0 ]]; then
-	PATCH_LIST=($PATCHDIR/*.patch)
-	TEST_LIST=($PATCHDIR/*.test)
+	PATCH_LIST=("$PATCHDIR"/*.patch)
+	TEST_LIST=("$PATCHDIR"/*.test)
 	if [[ ${#PATCH_LIST[@]} = 0 ]]; then
 		echo "No patches found!"
 		exit 1
@@ -108,7 +120,7 @@ else
 fi
 
 error() {
-	echo "ERROR: $@" |tee -a $LOG >&2
+	echo "ERROR: $*" |tee -a $LOG >&2
 	ERROR=$((ERROR + 1))
 }
 
@@ -122,7 +134,7 @@ unload_all() {
 
 build_module() {
 	file=$1
-	prefix=$(basename ${file%%.patch})
+	prefix=$(basename "${file%%.patch}")
 	modname="test-$prefix"
 	module="${modname}.ko"
 
@@ -141,10 +153,13 @@ build_module() {
 
 	log "build: $prefix"
 
-	if ! $KPATCHBUILD -n $modname $file >> $LOG 2>&1; then
+	# shellcheck disable=SC2086
+	# KPATCHBUILD_OPTS may contain several space-separated options,
+	# it should remain without quotes.
+	if ! $KPATCHBUILD $KPATCHBUILD_OPTS -n "$modname" "$file" >> $LOG 2>&1; then
 		if [[ $shouldfail -eq 0 ]]; then
 			error "$prefix: build failed"
-			cp $HOME/.kpatch/build.log $prefix.log
+			cp "$HOME/.kpatch/build.log" "$prefix.log"
 		fi
 	else
 		[[ $shouldfail -eq 1 ]] && error "$prefix: build succeeded when it should have failed"
@@ -153,10 +168,10 @@ build_module() {
 
 run_load_test() {
 	file=$1
-	prefix=$(basename ${file%%.patch})
+	prefix=$(basename "${file%%.patch}")
 	modname="test-$prefix"
 	module="${modname}.ko"
-	testprog="$(dirname $1)/$prefix-LOADED.test"
+	testprog=$(dirname "$1")/"$prefix-LOADED.test"
 
 	[[ $prefix =~ -FAIL ]] && return
 
@@ -177,7 +192,7 @@ run_load_test() {
 		return
 	fi
 
-	if ! $KPATCH load $module >> $LOG 2>&1; then
+	if ! $KPATCH load "$module" >> $LOG 2>&1; then
 		error "$prefix: kpatch load failed"
 		return
 	fi
@@ -186,7 +201,7 @@ run_load_test() {
 		error "$prefix: $testprog failed after kpatch load"
 	fi
 
-	if ! $KPATCH unload $module >> $LOG 2>&1; then
+	if ! $KPATCH unload "$module" >> $LOG 2>&1; then
 		error "$prefix: kpatch unload failed"
 		return
 	fi
@@ -199,7 +214,7 @@ run_load_test() {
 
 run_custom_test() {
 	testprog=$1
-	prefix=$(basename ${testprog%%.test})
+	prefix=$(basename "${testprog%%.test}")
 
 	[[ $testprog = *-LOADED.test ]] && return
 
@@ -220,7 +235,7 @@ build_combined_module() {
 	declare -a COMBINED_LIST
 	for file in "${PATCH_LIST[@]}"; do
 		[[ $file =~ -FAIL ]] && log "combine: skipping $file" && continue
-		COMBINED_LIST+=($file)
+		COMBINED_LIST+=("$file")
 	done
 	if [[ ${#COMBINED_LIST[@]} -le 1 ]]; then
 		log "skipping build: combined (only ${#PATCH_LIST[@]} patch(es))"
@@ -229,9 +244,10 @@ build_combined_module() {
 
 	log "build: combined module"
 
-	if ! $KPATCHBUILD -n test-COMBINED "${COMBINED_LIST[@]}" >> $LOG 2>&1; then
+	# shellcheck disable=SC2086
+	if ! $KPATCHBUILD $KPATCHBUILD_OPTS -n test-COMBINED "${COMBINED_LIST[@]}" >> $LOG 2>&1; then
 		error "combined build failed"
-		cp $HOME/.kpatch/build.log combined.log
+		cp "$HOME/.kpatch/build.log" combined.log
 	fi
 }
 
@@ -260,7 +276,7 @@ run_combined_test() {
 
 	for testprog in "${TEST_LIST[@]}"; do
 		[[ $testprog != *-LOADED.test ]] && continue
-		[ -e ${testprog/"-LOADED.test"/".patch.disabled"} ] && continue
+		[ -e "${testprog/-LOADED.test/.patch.disabled}" ] && continue
 		if ! $testprog >> $LOG 2>&1; then
 			error "combined: $testprog failed after kpatch load"
 		fi
@@ -281,12 +297,54 @@ run_combined_test() {
 
 }
 
-echo "clearing printk buffer"
-sudo dmesg -C
+# save existing dmesg so we can detect new content
+save_dmesg() {
+	SAVED_DMESG="$(dmesg | tail -n1)"
+}
+
+# new dmesg entries since our saved entry
+new_dmesg() {
+	if ! dmesg | awk -v last="$SAVED_DMESG" 'p; $0 == last{p=1} END {exit !p}'; then
+		error "dmesg overflow, try increasing kernel log buffer size"
+	fi
+}
+
+kernel_version_gte() {
+	[  "${ARCHVERSION//-*/}" = "$(echo -e "${ARCHVERSION//-*}\\n$1" | sort -rV | head -n1)" ]
+}
+
+support_klp_replace()
+{
+	if kernel_is_rhel; then
+		rhel_kernel_version_gte 4.18.0-193.el8
+	else
+		kernel_version_gte 5.1.0
+	fi
+}
+
+kernel_is_rhel() {
+	[[ "$ARCHVERSION" =~ \.el[789] ]]
+}
+
+rhel_kernel_version_gte() {
+        [  "${ARCHVERSION}" = "$(echo -e "${ARCHVERSION}\\n$1" | sort -rV | head -n1)" ]
+}
+
+# shellcheck disable=SC1091
+source /etc/os-release
+if [[ "${ID}" == "rhel" && "${VERSION_ID%%.*}" == "7" && "${VERSION_ID##*.}" -le "6" ]]; then
+	DYNDEBUG_ENABLED=0
+	echo "Dynamic debug is not supported on '${PRETTY_NAME}', disabling."
+fi
+
+if ! support_klp_replace ; then
+    	KPATCHBUILD_OPTS="$KPATCHBUILD_OPTS -R"
+	echo "KLP replace is not supported on '${PRETTY_NAME}', disabling."
+fi
 
 for file in "${PATCH_LIST[@]}"; do
-	if [[ $QUICK != 1 || $file =~ -FAIL ]]; then
-		build_module $file
+	if [[ $QUICK != 1 || "$file" =~ -FAIL ]]; then
+		build_module "$file"
 	fi
 done
 
@@ -294,9 +352,16 @@ build_combined_module
 
 unload_all
 
+save_dmesg
+
+if [ "${DYNDEBUG_ENABLED}" == "1" ]; then
+	prev_dyndebug=$(grep klp_try_switch_task "${DYNDEBUG_CONTROL}" | awk '{print $3;}')
+	echo "func klp_try_switch_task +p" >"${DYNDEBUG_CONTROL}" 2>/dev/null
+fi
+
 if [[ $QUICK != 1 ]]; then
 	for file in "${PATCH_LIST[@]}"; do
-		run_load_test $file
+		run_load_test "$file"
 	done
 fi
 
@@ -306,7 +371,7 @@ if [[ $QUICK != 1 ]]; then
 	for testprog in "${TEST_LIST[@]}"; do
 		if [[ ! $testprog =~ -FAIL ]]; then
 			unload_all
-			run_custom_test $testprog
+			run_custom_test "$testprog"
 		fi
 	done
 fi
@@ -314,8 +379,12 @@ fi
 
 unload_all
 
-if dmesg | grep -q "Call Trace"; then
-	dmesg > dmesg.log
+if [ "${DYNDEBUG_ENABLED}" == "1" ]; then
+	echo "func klp_try_switch_task ${prev_dyndebug}" >"${DYNDEBUG_CONTROL}" 2>/dev/null
+fi
+
+if new_dmesg | grep -q "Call Trace"; then
+	new_dmesg > dmesg.log
 	error "kernel error detected in printk buffer"
 fi
 
diff --git a/test/integration/lib.sh b/test/integration/lib.sh
index 127b225..aff7c6e 100644
--- a/test/integration/lib.sh
+++ b/test/integration/lib.sh
@@ -18,6 +18,10 @@ kpatch_fedora_dependencies()
 	sudo dnf debuginfo-install -y "kernel-${kernel_version%.*}"
 
 	sudo dnf install -y ccache
+
+	if [[ "$(uname -m)" == "ppc64le" ]]; then
+		sudo yum install -y gcc-plugin-devel
+	fi
 }
 
 kpatch_ubuntu_dependencies()
@@ -53,18 +57,39 @@ kpatch_rhel_dependencies()
 {
 	local kernel_version
 	local arch
+	local rhel_major
+	local py_version
 	kernel_version=$(uname -r)
 	arch=$(uname -m)
+	rhel_major=${VERSION_ID%%.*}
+
+	if [ "${rhel_major}" -ge 8 ]; then
+		py_version="3"
+	else
+		py_version="2"
+	fi
 
 	sudo yum install -y git gcc gcc-c++ "kernel-devel-${kernel_version%.*}" elfutils elfutils-devel
 	sudo yum install -y yum-utils zlib-devel binutils-devel newt-devel \
-		python-devel perl-ExtUtils-Embed audit-libs-devel numactl-devel \
+		python${py_version}-devel perl-ExtUtils-Embed audit-libs-devel numactl-devel \
 		pciutils-devel bison ncurses-devel rpm-build java-devel
 	sudo yum-builddep -y "kernel-${kernel_version%.*}"
 	sudo debuginfo-install -y "kernel-${kernel_version%.*}"
 
-	[ "${arch}" == "x86_64" ] && sudo yum install -y pesign
-	[ "${arch}" == "ppc64le" ] && sudo yum install -y gcc-plugin-devel
+	case "${arch}" in
+		"x86_64")
+			sudo yum install -y pesign
+			;;
+		"ppc64le")
+			sudo yum install -y gcc-plugin-devel
+			if [ "${rhel_major}" -ge 8 ]; then
+				# yum-builddep doesn't provide everything we need :(
+				sudo yum install -y flex openssl-devel
+			fi
+			;;
+		*)
+			;;
+	esac
 
 	sudo yum install -y "https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm"
 	sudo yum install -y ccache
@@ -208,6 +233,7 @@ kpatch_install_vagrant()
 kpatch_check_install_vagrant()
 {
 	local image_path=${1}
+	# shellcheck disable=SC2230
 	[ "$(which vagrant)" == "" ] && kpatch_install_vagrant "${image_path}"
 	return 0
 }
diff --git a/test/integration/centos-7/data-new-LOADED.test b/test/integration/linux-5.10.11/data-new-LOADED.test
similarity index 100%
rename from test/integration/centos-7/data-new-LOADED.test
rename to test/integration/linux-5.10.11/data-new-LOADED.test
diff --git a/test/integration/linux-5.10.11/data-new.patch b/test/integration/linux-5.10.11/data-new.patch
new file mode 100644
index 0000000..927d088
--- /dev/null
+++ b/test/integration/linux-5.10.11/data-new.patch
@@ -0,0 +1,20 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-01-28 04:47:10.916473090 -0500
++++ src/fs/proc/meminfo.c	2021-01-28 04:47:11.459467821 -0500
+@@ -29,6 +29,8 @@ static void show_val_kb(struct seq_file
+ 	seq_write(m, " kB\n", 4);
+ }
+ 
++static int foo = 5;
++
+ static int meminfo_proc_show(struct seq_file *m, void *v)
+ {
+ 	struct sysinfo i;
+@@ -139,6 +141,7 @@ static int meminfo_proc_show(struct seq_
+ 	show_val_kb(m, "FilePmdMapped:  ",
+ 		    global_node_page_state(NR_FILE_PMDMAPPED) * HPAGE_PMD_NR);
+ #endif
++	seq_printf(m, "kpatch: %d\n", foo);
+ 
+ #ifdef CONFIG_CMA
+ 	show_val_kb(m, "CmaTotal:       ", totalcma_pages);
diff --git a/test/integration/linux-5.10.11/gcc-static-local-var-6.patch b/test/integration/linux-5.10.11/gcc-static-local-var-6.patch
new file mode 100644
index 0000000..8254b6c
--- /dev/null
+++ b/test/integration/linux-5.10.11/gcc-static-local-var-6.patch
@@ -0,0 +1,22 @@
+diff -Nupr linux-5.10.11.bak/net/ipv6/netfilter.c linux-5.10.11/net/ipv6/netfilter.c
+--- linux-5.10.11.bak/net/ipv6/netfilter.c	2021-01-28 08:18:59.575109041 -0500
++++ linux-5.10.11/net/ipv6/netfilter.c	2021-01-28 08:20:52.399053360 -0500
+@@ -89,6 +89,8 @@ static int nf_ip6_reroute(struct sk_buff
+ 	return 0;
+ }
+ 
++#include "kpatch-macros.h"
++
+ int __nf_ip6_route(struct net *net, struct dst_entry **dst,
+ 		   struct flowi *fl, bool strict)
+ {
+@@ -102,6 +104,9 @@ int __nf_ip6_route(struct net *net, stru
+ 	struct dst_entry *result;
+ 	int err;
+ 
++	if (!jiffies)
++		printk("kpatch nf_ip6_route foo\n");
++
+ 	result = ip6_route_output(net, sk, &fl->u.ip6);
+ 	err = result->error;
+ 	if (err)
diff --git a/test/integration/linux-5.10.11/macro-callbacks.patch b/test/integration/linux-5.10.11/macro-callbacks.patch
new file mode 100644
index 0000000..735ed9f
--- /dev/null
+++ b/test/integration/linux-5.10.11/macro-callbacks.patch
@@ -0,0 +1,163 @@
+kpatch/livepatch callback test patch:
+
+  vmlinux
+  pcspkr (mod)
+  joydev (mod)
+
+Note: update joydev's pre-patch callback to return -ENODEV to test failure path
+
+diff -Nupr src.orig/drivers/input/joydev.c src/drivers/input/joydev.c
+--- src.orig/drivers/input/joydev.c	2021-01-28 04:45:56.883192829 -0500
++++ src/drivers/input/joydev.c	2021-01-28 04:51:13.998114373 -0500
+@@ -1084,3 +1084,47 @@ static void __exit joydev_exit(void)
+ 
+ module_init(joydev_init);
+ module_exit(joydev_exit);
++
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0; /* return -ENODEV; */
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/drivers/input/misc/pcspkr.c src/drivers/input/misc/pcspkr.c
+--- src.orig/drivers/input/misc/pcspkr.c	2021-01-28 04:45:56.892192742 -0500
++++ src/drivers/input/misc/pcspkr.c	2021-01-28 04:51:14.086113519 -0500
+@@ -133,3 +133,46 @@ static struct platform_driver pcspkr_pla
+ };
+ module_platform_driver(pcspkr_platform_driver);
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2021-01-28 04:47:10.885473391 -0500
++++ src/fs/aio.c	2021-01-28 04:51:14.115113237 -0500
+@@ -51,6 +51,50 @@
+ 
+ #define KIOCB_KEY		0
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
++
+ #define AIO_RING_MAGIC			0xa10a10a1
+ #define AIO_RING_COMPAT_FEATURES	1
+ #define AIO_RING_INCOMPAT_FEATURES	0
diff --git a/test/integration/centos-7/module-call-external.patch b/test/integration/linux-5.10.11/module-call-external.patch
similarity index 57%
rename from test/integration/centos-7/module-call-external.patch
rename to test/integration/linux-5.10.11/module-call-external.patch
index 754d725..9081967 100644
--- a/test/integration/centos-7/module-call-external.patch
+++ b/test/integration/linux-5.10.11/module-call-external.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
---- src.orig/fs/nfsd/export.c	2017-09-22 15:27:21.705056204 -0400
-+++ src/fs/nfsd/export.c	2017-09-22 15:27:42.411141948 -0400
-@@ -1184,6 +1184,8 @@ static void exp_flags(struct seq_file *m
+--- src.orig/fs/nfsd/export.c	2021-01-28 04:47:10.905473196 -0500
++++ src/fs/nfsd/export.c	2021-01-28 04:55:55.117394790 -0500
+@@ -1234,6 +1234,8 @@ static void exp_flags(struct seq_file *m
  	}
  }
  
@@ -10,7 +10,7 @@ diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
  static int e_show(struct seq_file *m, void *p)
  {
  	struct cache_head *cp = p;
-@@ -1193,6 +1195,7 @@ static int e_show(struct seq_file *m, vo
+@@ -1243,6 +1245,7 @@ static int e_show(struct seq_file *m, vo
  	if (p == SEQ_START_TOKEN) {
  		seq_puts(m, "# Version 1.1\n");
  		seq_puts(m, "# Path Client(Flags) # IPs\n");
@@ -19,9 +19,9 @@ diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
  	}
  
 diff -Nupr src.orig/net/netlink/af_netlink.c src/net/netlink/af_netlink.c
---- src.orig/net/netlink/af_netlink.c	2017-09-22 15:27:21.754056407 -0400
-+++ src/net/netlink/af_netlink.c	2017-09-22 15:27:42.412141952 -0400
-@@ -3260,4 +3260,9 @@ panic:
+--- src.orig/net/netlink/af_netlink.c	2021-01-28 04:45:47.818280959 -0500
++++ src/net/netlink/af_netlink.c	2021-01-28 04:55:55.134394639 -0500
+@@ -2898,4 +2898,9 @@ panic:
  	panic("netlink_init: Cannot allocate nl_table\n");
  }
  
diff --git a/test/integration/linux-5.10.11/multiple.test b/test/integration/linux-5.10.11/multiple.test
new file mode 100755
index 0000000..a7ea608
--- /dev/null
+++ b/test/integration/linux-5.10.11/multiple.test
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
+
+declare -a blacklist=(meminfo-cmdline-rebuild-SLOW-LOADED.test)
+
+source ${SCRIPTDIR}/../common/multiple.template
diff --git a/test/integration/centos-7/new-function.patch b/test/integration/linux-5.10.11/new-function.patch
similarity index 72%
rename from test/integration/centos-7/new-function.patch
rename to test/integration/linux-5.10.11/new-function.patch
index cf47c83..ca79e3a 100644
--- a/test/integration/centos-7/new-function.patch
+++ b/test/integration/linux-5.10.11/new-function.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/drivers/tty/n_tty.c src/drivers/tty/n_tty.c
---- src.orig/drivers/tty/n_tty.c	2017-09-22 15:27:21.084053633 -0400
-+++ src/drivers/tty/n_tty.c	2017-09-22 15:27:45.888156346 -0400
-@@ -2016,7 +2016,7 @@ do_it_again:
+--- src.orig/drivers/tty/n_tty.c	2021-01-28 04:45:56.804193597 -0500
++++ src/drivers/tty/n_tty.c	2021-01-28 04:59:56.004262703 -0500
+@@ -2295,7 +2295,7 @@ static ssize_t n_tty_read(struct tty_str
   *		  lock themselves)
   */
  
@@ -10,7 +10,7 @@ diff -Nupr src.orig/drivers/tty/n_tty.c src/drivers/tty/n_tty.c
  			   const unsigned char *buf, size_t nr)
  {
  	const unsigned char *b = buf;
-@@ -2098,6 +2098,12 @@ break_out:
+@@ -2382,6 +2382,12 @@ break_out:
  	return (b - buf) ? b - buf : retval;
  }
  
diff --git a/test/integration/linux-5.10.11/new-globals.patch b/test/integration/linux-5.10.11/new-globals.patch
new file mode 100644
index 0000000..18a234e
--- /dev/null
+++ b/test/integration/linux-5.10.11/new-globals.patch
@@ -0,0 +1,34 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2021-01-28 04:47:10.915473099 -0500
++++ src/fs/proc/cmdline.c	2021-01-28 05:04:23.106898578 -0500
+@@ -17,3 +17,10 @@ static int __init proc_cmdline_init(void
+ 	return 0;
+ }
+ fs_initcall(proc_cmdline_init);
++
++#include <linux/printk.h>
++void kpatch_print_message(void)
++{
++	if (!jiffies)
++		printk("hello there!\n");
++}
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-01-28 04:47:10.916473090 -0500
++++ src/fs/proc/meminfo.c	2021-01-28 05:04:23.141898268 -0500
+@@ -19,6 +19,8 @@
+ #include <asm/page.h>
+ #include "internal.h"
+ 
++void kpatch_print_message(void);
++
+ void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
+ {
+ }
+@@ -55,6 +57,7 @@ static int meminfo_proc_show(struct seq_
+ 	sreclaimable = global_node_page_state_pages(NR_SLAB_RECLAIMABLE_B);
+ 	sunreclaim = global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B);
+ 
++	kpatch_print_message();
+ 	show_val_kb(m, "MemTotal:       ", i.totalram);
+ 	show_val_kb(m, "MemFree:        ", i.freeram);
+ 	show_val_kb(m, "MemAvailable:   ", available);
diff --git a/test/integration/linux-5.10.11/warn-detect-FAIL.patch b/test/integration/linux-5.10.11/warn-detect-FAIL.patch
new file mode 100644
index 0000000..940590f
--- /dev/null
+++ b/test/integration/linux-5.10.11/warn-detect-FAIL.patch
@@ -0,0 +1,9 @@
+diff -Nupr linux-5.10.11.bak/net/core/dev.c linux-5.10.11/net/core/dev.c
+--- linux-5.10.11.bak/net/core/dev.c	2021-01-28 08:18:59.936105663 -0500
++++ linux-5.10.11/net/core/dev.c	2021-01-28 08:34:03.120655935 -0500
+@@ -1,4 +1,5 @@
+ // SPDX-License-Identifier: GPL-2.0-or-later
++
+ /*
+  *      NET3    Protocol independent device support routines.
+  *
diff --git a/test/integration/rhel-7.6/symvers-disagreement-FAIL.patch b/test/integration/rhel-7.6/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..d8ef754
--- /dev/null
+++ b/test/integration/rhel-7.6/symvers-disagreement-FAIL.patch
@@ -0,0 +1,51 @@
+From bcb86fa4e9c31379a9e2716eae29cd53ccca064f Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index b9a71137208..4af27e069c2 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -31,6 +31,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index f9db3660999..bece0bf4f5a 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -691,6 +691,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.1
+
diff --git a/test/integration/rhel-7.7/symvers-disagreement-FAIL.patch b/test/integration/rhel-7.7/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..e940645
--- /dev/null
+++ b/test/integration/rhel-7.7/symvers-disagreement-FAIL.patch
@@ -0,0 +1,51 @@
+From d5513eae5155c6e7e884554d5e3e2c65a7b39cbe Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index b9a71137208..4af27e069c2 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -31,6 +31,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index d6337db2164..0ff9722dfa2 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -693,6 +693,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/rhel-7.8/symvers-disagreement-FAIL.patch b/test/integration/rhel-7.8/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..300f8b9
--- /dev/null
+++ b/test/integration/rhel-7.8/symvers-disagreement-FAIL.patch
@@ -0,0 +1,49 @@
+From da109d66a890373d0aa831f97b49aaffcc4eeb45 Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes a function referencing a function whose CRC has changed,
+   causing the symbol and the new CRC to be included in the __version
+   section of the final module.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index b9a71137208..4af27e069c2 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -31,6 +31,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index 8b1c4a5ee78..1b7997b58c0 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -693,6 +693,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/centos-7/bug-table-section.patch b/test/integration/rhel-7.9/bug-table-section.patch
similarity index 62%
rename from test/integration/centos-7/bug-table-section.patch
rename to test/integration/rhel-7.9/bug-table-section.patch
index 71f8c1b..92e66d4 100644
--- a/test/integration/centos-7/bug-table-section.patch
+++ b/test/integration/rhel-7.9/bug-table-section.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
---- src.orig/fs/proc/proc_sysctl.c	2017-09-22 15:27:21.698056175 -0400
-+++ src/fs/proc/proc_sysctl.c	2017-09-22 15:27:21.769056469 -0400
-@@ -266,6 +266,8 @@ void sysctl_head_put(struct ctl_table_he
+--- src.orig/fs/proc/proc_sysctl.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/proc_sysctl.c	2020-09-03 11:48:31.009727724 -0400
+@@ -331,6 +331,8 @@ static void start_unregistering(struct c
  
  static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)
  {
diff --git a/test/integration/centos-7/cmdline-string-LOADED.test b/test/integration/rhel-7.9/cmdline-string-LOADED.test
similarity index 100%
rename from test/integration/centos-7/cmdline-string-LOADED.test
rename to test/integration/rhel-7.9/cmdline-string-LOADED.test
diff --git a/test/integration/centos-7/cmdline-string.patch b/test/integration/rhel-7.9/cmdline-string.patch
similarity index 67%
rename from test/integration/centos-7/cmdline-string.patch
rename to test/integration/rhel-7.9/cmdline-string.patch
index 749861f..719445d 100644
--- a/test/integration/centos-7/cmdline-string.patch
+++ b/test/integration/rhel-7.9/cmdline-string.patch
@@ -1,6 +1,6 @@
 diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
---- src.orig/fs/proc/cmdline.c	2017-09-22 15:27:21.698056175 -0400
-+++ src/fs/proc/cmdline.c	2017-09-22 15:27:22.955061380 -0400
+--- src.orig/fs/proc/cmdline.c	2020-09-03 11:48:30.496726119 -0400
++++ src/fs/proc/cmdline.c	2020-09-03 11:48:33.073734181 -0400
 @@ -5,7 +5,7 @@
  
  static int cmdline_proc_show(struct seq_file *m, void *v)
diff --git a/test/integration/rhel-7.9/data-new-LOADED.test b/test/integration/rhel-7.9/data-new-LOADED.test
new file mode 100755
index 0000000..598b6bb
--- /dev/null
+++ b/test/integration/rhel-7.9/data-new-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep "kpatch: 5" /proc/meminfo
diff --git a/test/integration/rhel-7.9/data-new.patch b/test/integration/rhel-7.9/data-new.patch
new file mode 100644
index 0000000..2e4e824
--- /dev/null
+++ b/test/integration/rhel-7.9/data-new.patch
@@ -0,0 +1,28 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/meminfo.c	2020-09-03 11:48:35.069740426 -0400
+@@ -21,6 +21,8 @@ void __attribute__((weak)) arch_report_m
+ {
+ }
+ 
++static int foo = 5;
++
+ static int meminfo_proc_show(struct seq_file *m, void *v)
+ {
+ 	struct sysinfo i;
+@@ -112,6 +114,7 @@ static int meminfo_proc_show(struct seq_
+ 		"CmaTotal:       %8lu kB\n"
+ 		"CmaFree:        %8lu kB\n"
+ #endif
++		"kpatch: %d"
+ 		,
+ 		K(i.totalram),
+ 		K(i.freeram),
+@@ -178,6 +181,7 @@ static int meminfo_proc_show(struct seq_
+ 		, K(totalcma_pages)
+ 		, K(global_page_state(NR_FREE_CMA_PAGES))
+ #endif
++		,foo
+ 		);
+ 
+ 	hugetlb_report_meminfo(m);
diff --git a/test/integration/rhel-7.9/data-read-mostly.patch.disabled b/test/integration/rhel-7.9/data-read-mostly.patch.disabled
new file mode 100644
index 0000000..50f4c9b
--- /dev/null
+++ b/test/integration/rhel-7.9/data-read-mostly.patch.disabled
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/net/core/dev.c src/net/core/dev.c
+--- src.orig/net/core/dev.c	2020-09-03 11:48:30.763726955 -0400
++++ src/net/core/dev.c	2020-09-03 11:49:21.514885728 -0400
+@@ -4327,6 +4327,7 @@ skip_classify:
+ 		case RX_HANDLER_PASS:
+ 			break;
+ 		default:
++			printk("BUG!\n");
+ 			BUG();
+ 		}
+ 	}
diff --git a/test/integration/rhel-7.9/fixup-section.patch b/test/integration/rhel-7.9/fixup-section.patch
new file mode 100644
index 0000000..465e23a
--- /dev/null
+++ b/test/integration/rhel-7.9/fixup-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/readdir.c src/fs/readdir.c
+--- src.orig/fs/readdir.c	2020-09-03 11:48:30.499726129 -0400
++++ src/fs/readdir.c	2020-09-03 11:48:37.119746839 -0400
+@@ -176,6 +176,7 @@ static int filldir(void * __buf, const c
+ 			goto efault;
+ 	}
+ 	dirent = buf->current_dir;
++	asm("nop");
+ 	if (__put_user(d_ino, &dirent->d_ino))
+ 		goto efault;
+ 	if (__put_user(reclen, &dirent->d_reclen))
diff --git a/test/integration/centos-7/gcc-constprop.patch b/test/integration/rhel-7.9/gcc-constprop.patch
similarity index 52%
rename from test/integration/centos-7/gcc-constprop.patch
rename to test/integration/rhel-7.9/gcc-constprop.patch
index 63ba45d..4ab8c1b 100644
--- a/test/integration/centos-7/gcc-constprop.patch
+++ b/test/integration/rhel-7.9/gcc-constprop.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/kernel/time/timekeeping.c src/kernel/time/timekeeping.c
---- src.orig/kernel/time/timekeeping.c	2017-09-22 15:27:21.602055778 -0400
-+++ src/kernel/time/timekeeping.c	2017-09-22 15:27:27.522080292 -0400
-@@ -877,6 +877,9 @@ void do_gettimeofday(struct timeval *tv)
+--- src.orig/kernel/time/timekeeping.c	2020-09-03 11:48:30.726726839 -0400
++++ src/kernel/time/timekeeping.c	2020-09-03 11:49:23.433891731 -0400
+@@ -852,6 +852,9 @@ void do_gettimeofday(struct timeval *tv)
  {
  	struct timespec64 now;
  
diff --git a/test/integration/centos-7/gcc-isra.patch b/test/integration/rhel-7.9/gcc-isra.patch
similarity index 56%
rename from test/integration/centos-7/gcc-isra.patch
rename to test/integration/rhel-7.9/gcc-isra.patch
index a869797..6996eeb 100644
--- a/test/integration/centos-7/gcc-isra.patch
+++ b/test/integration/rhel-7.9/gcc-isra.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
---- src.orig/fs/proc/proc_sysctl.c	2017-09-22 15:27:21.698056175 -0400
-+++ src/fs/proc/proc_sysctl.c	2017-09-22 15:27:28.670085046 -0400
-@@ -24,6 +24,7 @@ void proc_sys_poll_notify(struct ctl_tab
+--- src.orig/fs/proc/proc_sysctl.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/proc_sysctl.c	2020-09-03 11:48:39.089753002 -0400
+@@ -46,6 +46,7 @@ void proc_sys_poll_notify(struct ctl_tab
  	if (!poll)
  		return;
  
diff --git a/test/integration/centos-7/gcc-mangled-3.patch b/test/integration/rhel-7.9/gcc-mangled-3.patch
similarity index 54%
rename from test/integration/centos-7/gcc-mangled-3.patch
rename to test/integration/rhel-7.9/gcc-mangled-3.patch
index 5828680..5a7904e 100644
--- a/test/integration/centos-7/gcc-mangled-3.patch
+++ b/test/integration/rhel-7.9/gcc-mangled-3.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/mm/slub.c src/mm/slub.c
---- src.orig/mm/slub.c	2017-09-22 15:27:21.618055844 -0400
-+++ src/mm/slub.c	2017-09-22 15:27:29.830089850 -0400
-@@ -5528,6 +5528,9 @@ void get_slabinfo(struct kmem_cache *s,
+--- src.orig/mm/slub.c	2020-09-03 11:48:30.747726905 -0400
++++ src/mm/slub.c	2020-09-03 11:48:41.106759312 -0400
+@@ -5716,6 +5716,9 @@ void get_slabinfo(struct kmem_cache *s,
  	unsigned long nr_free = 0;
  	int node;
  
diff --git a/test/integration/centos-7/gcc-static-local-var-2.patch b/test/integration/rhel-7.9/gcc-static-local-var-2.patch
similarity index 61%
rename from test/integration/centos-7/gcc-static-local-var-2.patch
rename to test/integration/rhel-7.9/gcc-static-local-var-2.patch
index 4f653d7..a3e8366 100644
--- a/test/integration/centos-7/gcc-static-local-var-2.patch
+++ b/test/integration/rhel-7.9/gcc-static-local-var-2.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/mm/mmap.c src/mm/mmap.c
---- src.orig/mm/mmap.c	2017-09-22 15:27:21.618055844 -0400
-+++ src/mm/mmap.c	2017-09-22 15:27:31.024094794 -0400
-@@ -1687,6 +1688,9 @@ unsigned long mmap_region(struct file *f
+--- src.orig/mm/mmap.c	2020-09-03 11:48:30.745726898 -0400
++++ src/mm/mmap.c	2020-09-03 11:48:43.078765482 -0400
+@@ -1721,6 +1721,9 @@ unsigned long mmap_region(struct file *f
  	struct rb_node **rb_link, *rb_parent;
  	unsigned long charged = 0;
  
diff --git a/test/integration/centos-7/gcc-static-local-var-3.patch b/test/integration/rhel-7.9/gcc-static-local-var-3.patch
similarity index 57%
rename from test/integration/centos-7/gcc-static-local-var-3.patch
rename to test/integration/rhel-7.9/gcc-static-local-var-3.patch
index d87677b..6d8ae91 100644
--- a/test/integration/centos-7/gcc-static-local-var-3.patch
+++ b/test/integration/rhel-7.9/gcc-static-local-var-3.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/kernel/sys.c src/kernel/sys.c
---- src.orig/kernel/sys.c	2017-09-22 15:27:21.601055773 -0400
-+++ src/kernel/sys.c	2017-09-22 15:27:32.170099540 -0400
-@@ -554,8 +554,15 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
+--- src.orig/kernel/sys.c	2020-09-03 11:48:30.725726836 -0400
++++ src/kernel/sys.c	2020-09-03 11:48:45.101771811 -0400
+@@ -559,8 +559,15 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
  	return ret;
  }
  
diff --git a/test/integration/centos-7/gcc-static-local-var-4.patch b/test/integration/rhel-7.9/gcc-static-local-var-4.patch
similarity index 67%
rename from test/integration/centos-7/gcc-static-local-var-4.patch
rename to test/integration/rhel-7.9/gcc-static-local-var-4.patch
index e22ead7..d63af5b 100644
--- a/test/integration/centos-7/gcc-static-local-var-4.patch
+++ b/test/integration/rhel-7.9/gcc-static-local-var-4.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/fs/aio.c src/fs/aio.c
---- src.orig/fs/aio.c	2017-09-22 15:27:21.702056192 -0400
-+++ src/fs/aio.c	2017-09-22 15:27:33.299104215 -0400
-@@ -219,9 +219,16 @@ static int __init aio_setup(void)
+--- src.orig/fs/aio.c	2020-09-03 11:48:30.426725900 -0400
++++ src/fs/aio.c	2020-09-03 11:48:47.163778261 -0400
+@@ -223,9 +223,16 @@ static int __init aio_setup(void)
  }
  __initcall(aio_setup);
  
diff --git a/test/integration/centos-7/gcc-static-local-var-4.test b/test/integration/rhel-7.9/gcc-static-local-var-4.test
similarity index 100%
rename from test/integration/centos-7/gcc-static-local-var-4.test
rename to test/integration/rhel-7.9/gcc-static-local-var-4.test
diff --git a/test/integration/centos-7/gcc-static-local-var-5.patch b/test/integration/rhel-7.9/gcc-static-local-var-5.patch
similarity index 89%
rename from test/integration/centos-7/gcc-static-local-var-5.patch
rename to test/integration/rhel-7.9/gcc-static-local-var-5.patch
index 540affa..52d7f8b 100644
--- a/test/integration/centos-7/gcc-static-local-var-5.patch
+++ b/test/integration/rhel-7.9/gcc-static-local-var-5.patch
@@ -1,6 +1,6 @@
 diff -Nupr src.orig/kernel/audit.c src/kernel/audit.c
---- src.orig/kernel/audit.c	2017-09-22 15:27:21.602055778 -0400
-+++ src/kernel/audit.c	2017-09-22 15:27:34.429108894 -0400
+--- src.orig/kernel/audit.c	2020-09-03 11:48:30.713726798 -0400
++++ src/kernel/audit.c	2020-09-03 11:48:49.166784528 -0400
 @@ -205,6 +205,12 @@ void audit_panic(const char *message)
  	}
  }
diff --git a/test/integration/rhel-7.9/gcc-static-local-var-6.patch b/test/integration/rhel-7.9/gcc-static-local-var-6.patch
new file mode 100644
index 0000000..2b33da4
--- /dev/null
+++ b/test/integration/rhel-7.9/gcc-static-local-var-6.patch
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/net/ipv6/netfilter.c src/net/ipv6/netfilter.c
+--- src.orig/net/ipv6/netfilter.c	2020-09-03 11:48:30.779727005 -0400
++++ src/net/ipv6/netfilter.c	2020-09-03 11:48:51.172790803 -0400
+@@ -112,6 +112,8 @@ static int nf_ip6_reroute(struct sk_buff
+ 	return 0;
+ }
+ 
++#include "kpatch-macros.h"
++
+ static int nf_ip6_route(struct net *net, struct dst_entry **dst,
+ 			struct flowi *fl, bool strict)
+ {
+@@ -125,6 +127,9 @@ static int nf_ip6_route(struct net *net,
+ 	struct dst_entry *result;
+ 	int err;
+ 
++	if (!jiffies)
++		printk("kpatch nf_ip6_route foo\n");
++
+ 	result = ip6_route_output(net, sk, &fl->u.ip6);
+ 	err = result->error;
+ 	if (err)
diff --git a/test/integration/centos-7/macro-callbacks.patch b/test/integration/rhel-7.9/macro-callbacks.patch
similarity index 87%
rename from test/integration/centos-7/macro-callbacks.patch
rename to test/integration/rhel-7.9/macro-callbacks.patch
index 0d6831b..96c1a3f 100644
--- a/test/integration/centos-7/macro-callbacks.patch
+++ b/test/integration/rhel-7.9/macro-callbacks.patch
@@ -6,12 +6,14 @@ kpatch/livepatch callback test patch:
 
 Note: update joydev's pre-patch callback to return -ENODEV to test failure path
 
---- src.old/fs/aio.c	2018-02-26 11:07:51.522610407 -0500
-+++ src/fs/aio.c	2018-03-05 11:17:21.560015449 -0500
-@@ -42,6 +42,50 @@
- #include <asm/kmap_types.h>
- #include <asm/uaccess.h>
+diff -Nupr src.orig/drivers/input/joydev.c src/drivers/input/joydev.c
+--- src.orig/drivers/input/joydev.c	2020-09-03 11:48:29.019721499 -0400
++++ src/drivers/input/joydev.c	2020-09-03 11:48:53.152796998 -0400
+@@ -954,3 +954,47 @@ static void __exit joydev_exit(void)
  
+ module_init(joydev_init);
+ module_exit(joydev_exit);
++
 +#include <linux/module.h>
 +#include "kpatch-macros.h"
 +
@@ -34,7 +36,7 @@ Note: update joydev's pre-patch callback to return -ENODEV to test failure path
 +static int pre_patch_callback(patch_object *obj)
 +{
 +	callback_info(__func__, obj);
-+	return 0;
++	return 0; /* return -ENODEV; */
 +}
 +KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
 +
@@ -55,17 +57,13 @@ Note: update joydev's pre-patch callback to return -ENODEV to test failure path
 +	callback_info(__func__, obj);
 +}
 +KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
-+
- #define AIO_RING_MAGIC			0xa10a10a1
- #define AIO_RING_COMPAT_FEATURES	1
- #define AIO_RING_INCOMPAT_FEATURES	0
---- src.old/drivers/input/joydev.c	2018-02-26 11:07:49.470610407 -0500
-+++ src/drivers/input/joydev.c	2018-03-05 11:18:13.998015449 -0500
-@@ -954,3 +954,47 @@ static void __exit joydev_exit(void)
+diff -Nupr src.orig/drivers/input/misc/pcspkr.c src/drivers/input/misc/pcspkr.c
+--- src.orig/drivers/input/misc/pcspkr.c	2020-09-03 11:48:29.025721517 -0400
++++ src/drivers/input/misc/pcspkr.c	2020-09-03 11:48:53.152796998 -0400
+@@ -136,3 +136,46 @@ static struct platform_driver pcspkr_pla
+ };
+ module_platform_driver(pcspkr_platform_driver);
  
- module_init(joydev_init);
- module_exit(joydev_exit);
-+
 +#include <linux/module.h>
 +#include "kpatch-macros.h"
 +
@@ -88,7 +86,7 @@ Note: update joydev's pre-patch callback to return -ENODEV to test failure path
 +static int pre_patch_callback(patch_object *obj)
 +{
 +	callback_info(__func__, obj);
-+	return 0; /* return -ENODEV; */
++	return 0;
 +}
 +KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
 +
@@ -109,11 +107,12 @@ Note: update joydev's pre-patch callback to return -ENODEV to test failure path
 +	callback_info(__func__, obj);
 +}
 +KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
---- src.old/drivers/input/misc/pcspkr.c	2018-02-26 11:07:49.477610407 -0500
-+++ src/drivers/input/misc/pcspkr.c	2018-03-05 11:18:23.411015449 -0500
-@@ -136,3 +136,46 @@ static struct platform_driver pcspkr_pla
- };
- module_platform_driver(pcspkr_platform_driver);
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2020-09-03 11:48:30.426725900 -0400
++++ src/fs/aio.c	2020-09-03 11:48:53.153797001 -0400
+@@ -42,6 +42,50 @@
+ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
  
 +#include <linux/module.h>
 +#include "kpatch-macros.h"
@@ -158,3 +157,7 @@ Note: update joydev's pre-patch callback to return -ENODEV to test failure path
 +	callback_info(__func__, obj);
 +}
 +KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
++
+ #define AIO_RING_MAGIC			0xa10a10a1
+ #define AIO_RING_COMPAT_FEATURES	1
+ #define AIO_RING_INCOMPAT_FEATURES	0
diff --git a/test/integration/centos-7/macro-printk.patch b/test/integration/rhel-7.9/macro-printk.patch
similarity index 71%
rename from test/integration/centos-7/macro-printk.patch
rename to test/integration/rhel-7.9/macro-printk.patch
index ccdfc2f..28e618d 100644
--- a/test/integration/centos-7/macro-printk.patch
+++ b/test/integration/rhel-7.9/macro-printk.patch
@@ -1,8 +1,7 @@
-Index: src/net/ipv4/fib_frontend.c
-===================================================================
---- src.orig/net/ipv4/fib_frontend.c
-+++ src/net/ipv4/fib_frontend.c
-@@ -685,6 +685,7 @@ errout:
+diff -Nupr src.orig/net/ipv4/fib_frontend.c src/net/ipv4/fib_frontend.c
+--- src.orig/net/ipv4/fib_frontend.c	2020-09-03 11:48:30.771726980 -0400
++++ src/net/ipv4/fib_frontend.c	2020-09-03 11:48:55.130803186 -0400
+@@ -690,6 +690,7 @@ errout:
  	return err;
  }
  
@@ -10,7 +9,7 @@ Index: src/net/ipv4/fib_frontend.c
  static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)
  {
  	struct net *net = sock_net(skb->sk);
-@@ -703,6 +704,7 @@ static int inet_rtm_newroute(struct sk_b
+@@ -708,6 +709,7 @@ static int inet_rtm_newroute(struct sk_b
  	}
  
  	err = fib_table_insert(net, tb, &cfg);
@@ -18,11 +17,10 @@ Index: src/net/ipv4/fib_frontend.c
  errout:
  	return err;
  }
-Index: src/net/ipv4/fib_semantics.c
-===================================================================
---- src.orig/net/ipv4/fib_semantics.c
-+++ src/net/ipv4/fib_semantics.c
-@@ -969,6 +969,7 @@ fib_convert_metrics(struct fib_info *fi,
+diff -Nupr src.orig/net/ipv4/fib_semantics.c src/net/ipv4/fib_semantics.c
+--- src.orig/net/ipv4/fib_semantics.c	2020-09-03 11:48:30.771726980 -0400
++++ src/net/ipv4/fib_semantics.c	2020-09-03 11:48:55.130803186 -0400
+@@ -985,6 +985,7 @@ fib_convert_metrics(struct fib_info *fi,
  	return 0;
  }
  
@@ -30,7 +28,7 @@ Index: src/net/ipv4/fib_semantics.c
  struct fib_info *fib_create_info(struct fib_config *cfg)
  {
  	int err;
-@@ -993,6 +994,7 @@ struct fib_info *fib_create_info(struct
+@@ -1009,6 +1010,7 @@ struct fib_info *fib_create_info(struct
  #endif
  
  	err = -ENOBUFS;
@@ -38,7 +36,7 @@ Index: src/net/ipv4/fib_semantics.c
  	if (fib_info_cnt >= fib_info_hash_size) {
  		unsigned int new_size = fib_info_hash_size << 1;
  		struct hlist_head *new_info_hash;
-@@ -1013,6 +1015,7 @@ struct fib_info *fib_create_info(struct
+@@ -1029,6 +1031,7 @@ struct fib_info *fib_create_info(struct
  		if (!fib_info_hash_size)
  			goto failure;
  	}
@@ -46,15 +44,16 @@ Index: src/net/ipv4/fib_semantics.c
  
  	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
  	if (fi == NULL)
-@@ -1028,6 +1031,7 @@ struct fib_info *fib_create_info(struct
+@@ -1044,6 +1047,8 @@ struct fib_info *fib_create_info(struct
  		fi->fib_metrics = (struct dst_metrics *)&dst_default_metrics;
  	}
  	fib_info_cnt++;
 +	KPATCH_PRINTK("[fib_create_info]: 3 create error err is %d\n",err);
++
  	fi->fib_net = net;
  	fi->fib_protocol = cfg->fc_protocol;
  	fi->fib_scope = cfg->fc_scope;
-@@ -1043,8 +1047,10 @@ struct fib_info *fib_create_info(struct
+@@ -1059,8 +1064,10 @@ struct fib_info *fib_create_info(struct
  		if (!nexthop_nh->nh_pcpu_rth_output)
  			goto failure;
  	} endfor_nexthops(fi)
@@ -65,7 +64,7 @@ Index: src/net/ipv4/fib_semantics.c
  	if (err)
  		goto failure;
  
-@@ -1095,6 +1101,7 @@ struct fib_info *fib_create_info(struct
+@@ -1111,6 +1118,7 @@ struct fib_info *fib_create_info(struct
  		nh->nh_weight = 1;
  #endif
  	}
@@ -73,7 +72,7 @@ Index: src/net/ipv4/fib_semantics.c
  
  	if (fib_props[cfg->fc_type].error) {
  		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp)
-@@ -1112,6 +1119,7 @@ struct fib_info *fib_create_info(struct
+@@ -1128,6 +1136,7 @@ struct fib_info *fib_create_info(struct
  			goto err_inval;
  		}
  	}
@@ -81,7 +80,7 @@ Index: src/net/ipv4/fib_semantics.c
  
  	if (cfg->fc_scope > RT_SCOPE_HOST)
  		goto err_inval;
-@@ -1134,6 +1142,7 @@ struct fib_info *fib_create_info(struct
+@@ -1150,6 +1159,7 @@ struct fib_info *fib_create_info(struct
  				goto failure;
  		} endfor_nexthops(fi)
  	}
@@ -89,7 +88,7 @@ Index: src/net/ipv4/fib_semantics.c
  
  	if (fi->fib_prefsrc) {
  		if (cfg->fc_type != RTN_LOCAL || !cfg->fc_dst ||
-@@ -1146,6 +1155,7 @@ struct fib_info *fib_create_info(struct
+@@ -1162,6 +1172,7 @@ struct fib_info *fib_create_info(struct
  		fib_info_update_nh_saddr(net, nexthop_nh);
  		fib_add_weight(fi, nexthop_nh);
  	} endfor_nexthops(fi)
@@ -97,7 +96,7 @@ Index: src/net/ipv4/fib_semantics.c
  
  	fib_rebalance(fi);
  
-@@ -1157,6 +1167,7 @@ link_it:
+@@ -1173,6 +1184,7 @@ link_it:
  		ofi->fib_treeref++;
  		return ofi;
  	}
@@ -105,7 +104,7 @@ Index: src/net/ipv4/fib_semantics.c
  
  	fi->fib_treeref++;
  	atomic_inc(&fi->fib_clntref);
-@@ -1180,6 +1191,7 @@ link_it:
+@@ -1196,6 +1208,7 @@ link_it:
  		hlist_add_head(&nexthop_nh->nh_hash, head);
  	} endfor_nexthops(fi)
  	spin_unlock_bh(&fib_info_lock);
@@ -113,7 +112,7 @@ Index: src/net/ipv4/fib_semantics.c
  	return fi;
  
  err_inval:
-@@ -1190,6 +1202,7 @@ failure:
+@@ -1206,6 +1219,7 @@ failure:
  		fi->fib_dead = 1;
  		free_fib_info(fi);
  	}
@@ -121,10 +120,9 @@ Index: src/net/ipv4/fib_semantics.c
  
  	return ERR_PTR(err);
  }
-Index: src/net/ipv4/fib_trie.c
-===================================================================
---- src.orig/net/ipv4/fib_trie.c
-+++ src/net/ipv4/fib_trie.c
+diff -Nupr src.orig/net/ipv4/fib_trie.c src/net/ipv4/fib_trie.c
+--- src.orig/net/ipv4/fib_trie.c	2020-09-03 11:48:30.771726980 -0400
++++ src/net/ipv4/fib_trie.c	2020-09-03 11:48:55.131803189 -0400
 @@ -1105,6 +1105,7 @@ static int fib_insert_alias(struct trie
  }
  
diff --git a/test/integration/centos-7/meminfo-init-FAIL.patch b/test/integration/rhel-7.9/meminfo-init-FAIL.patch
similarity index 51%
rename from test/integration/centos-7/meminfo-init-FAIL.patch
rename to test/integration/rhel-7.9/meminfo-init-FAIL.patch
index 5df5225..ad677ca 100644
--- a/test/integration/centos-7/meminfo-init-FAIL.patch
+++ b/test/integration/rhel-7.9/meminfo-init-FAIL.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
---- src.orig/fs/proc/meminfo.c	2017-09-22 15:27:21.699056179 -0400
-+++ src/fs/proc/meminfo.c	2017-09-22 15:27:40.130132502 -0400
-@@ -191,6 +191,7 @@ static const struct file_operations memi
+--- src.orig/fs/proc/meminfo.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/meminfo.c	2020-09-03 11:48:59.106815625 -0400
+@@ -202,6 +202,7 @@ static const struct file_operations memi
  
  static int __init proc_meminfo_init(void)
  {
diff --git a/test/integration/centos-7/meminfo-init2-FAIL.patch b/test/integration/rhel-7.9/meminfo-init2-FAIL.patch
similarity index 54%
rename from test/integration/centos-7/meminfo-init2-FAIL.patch
rename to test/integration/rhel-7.9/meminfo-init2-FAIL.patch
index c030f61..792028e 100644
--- a/test/integration/centos-7/meminfo-init2-FAIL.patch
+++ b/test/integration/rhel-7.9/meminfo-init2-FAIL.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
---- src.orig/fs/proc/meminfo.c	2017-09-22 15:27:21.699056179 -0400
-+++ src/fs/proc/meminfo.c	2017-09-22 15:27:38.972127707 -0400
-@@ -30,6 +30,7 @@ static int meminfo_proc_show(struct seq_
+--- src.orig/fs/proc/meminfo.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/meminfo.c	2020-09-03 11:48:57.163809546 -0400
+@@ -31,6 +31,7 @@ static int meminfo_proc_show(struct seq_
  	unsigned long pages[NR_LRU_LISTS];
  	int lru;
  
@@ -9,7 +9,7 @@ diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
  /*
   * display in kilobytes.
   */
-@@ -191,6 +192,7 @@ static const struct file_operations memi
+@@ -202,6 +203,7 @@ static const struct file_operations memi
  
  static int __init proc_meminfo_init(void)
  {
diff --git a/test/integration/centos-7/meminfo-string-LOADED.test b/test/integration/rhel-7.9/meminfo-string-LOADED.test
similarity index 100%
rename from test/integration/centos-7/meminfo-string-LOADED.test
rename to test/integration/rhel-7.9/meminfo-string-LOADED.test
diff --git a/test/integration/centos-7/meminfo-string.patch b/test/integration/rhel-7.9/meminfo-string.patch
similarity index 56%
rename from test/integration/centos-7/meminfo-string.patch
rename to test/integration/rhel-7.9/meminfo-string.patch
index afdc5d0..7c8114e 100644
--- a/test/integration/centos-7/meminfo-string.patch
+++ b/test/integration/rhel-7.9/meminfo-string.patch
@@ -1,12 +1,12 @@
 diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
---- src.orig/fs/proc/meminfo.c	2017-09-22 15:27:21.699056179 -0400
-+++ src/fs/proc/meminfo.c	2017-09-22 15:27:41.274137239 -0400
-@@ -99,7 +99,7 @@ static int meminfo_proc_show(struct seq_
+--- src.orig/fs/proc/meminfo.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/meminfo.c	2020-09-03 11:49:01.546823258 -0400
+@@ -100,7 +100,7 @@ static int meminfo_proc_show(struct seq_
  		"Committed_AS:   %8lu kB\n"
  		"VmallocTotal:   %8lu kB\n"
  		"VmallocUsed:    %8lu kB\n"
 -		"VmallocChunk:   %8lu kB\n"
 +		"VMALLOCCHUNK:   %8lu kB\n"
+ 		"Percpu:         %8lu kB\n"
  #ifdef CONFIG_MEMORY_FAILURE
  		"HardwareCorrupted: %5lu kB\n"
- #endif
diff --git a/test/integration/rhel-7.9/module-call-external.patch b/test/integration/rhel-7.9/module-call-external.patch
new file mode 100644
index 0000000..e346edc
--- /dev/null
+++ b/test/integration/rhel-7.9/module-call-external.patch
@@ -0,0 +1,38 @@
+diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
+--- src.orig/fs/nfsd/export.c	2020-09-03 11:48:30.477726060 -0400
++++ src/fs/nfsd/export.c	2020-09-03 11:49:03.743830132 -0400
+@@ -1184,7 +1184,13 @@ static void exp_flags(struct seq_file *m
+ 	}
+ }
+ 
++extern char *kpatch_string(void);
++
++#ifdef CONFIG_PPC64
++static int __attribute__((optimize("-fno-optimize-sibling-calls"))) e_show(struct seq_file *m, void *p)
++#else
+ static int e_show(struct seq_file *m, void *p)
++#endif
+ {
+ 	struct cache_head *cp = p;
+ 	struct svc_export *exp = container_of(cp, struct svc_export, h);
+@@ -1193,6 +1199,7 @@ static int e_show(struct seq_file *m, vo
+ 	if (p == SEQ_START_TOKEN) {
+ 		seq_puts(m, "# Version 1.1\n");
+ 		seq_puts(m, "# Path Client(Flags) # IPs\n");
++		seq_puts(m, kpatch_string());
+ 		return 0;
+ 	}
+ 
+diff -Nupr src.orig/net/netlink/af_netlink.c src/net/netlink/af_netlink.c
+--- src.orig/net/netlink/af_netlink.c	2020-09-03 11:48:30.802727077 -0400
++++ src/net/netlink/af_netlink.c	2020-09-03 11:49:03.743830132 -0400
+@@ -2573,4 +2573,9 @@ panic:
+ 	panic("netlink_init: Cannot allocate nl_table\n");
+ }
+ 
++char *kpatch_string(void)
++{
++	return "# kpatch\n";
++}
++
+ core_initcall(netlink_proto_init);
diff --git a/test/integration/centos-7/multiple.test b/test/integration/rhel-7.9/multiple.test
similarity index 69%
rename from test/integration/centos-7/multiple.test
rename to test/integration/rhel-7.9/multiple.test
index b9cf7f9..7e4b352 100755
--- a/test/integration/centos-7/multiple.test
+++ b/test/integration/rhel-7.9/multiple.test
@@ -2,6 +2,6 @@
 
 SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
 
-declare -a blacklist=(data-new-LOADED.test)
+declare -a blacklist=(meminfo-string-LOADED.test)
 
 source ${SCRIPTDIR}/../common/multiple.template
diff --git a/test/integration/rhel-7.9/new-function.patch b/test/integration/rhel-7.9/new-function.patch
new file mode 100644
index 0000000..e83487a
--- /dev/null
+++ b/test/integration/rhel-7.9/new-function.patch
@@ -0,0 +1,25 @@
+diff -Nupr src.orig/drivers/tty/n_tty.c src/drivers/tty/n_tty.c
+--- src.orig/drivers/tty/n_tty.c	2020-09-03 11:48:29.609723344 -0400
++++ src/drivers/tty/n_tty.c	2020-09-03 11:49:05.751836414 -0400
+@@ -2175,7 +2175,7 @@ do_it_again:
+  *		  lock themselves)
+  */
+ 
+-static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
++static ssize_t noinline kpatch_n_tty_write(struct tty_struct *tty, struct file *file,
+ 			   const unsigned char *buf, size_t nr)
+ {
+ 	const unsigned char *b = buf;
+@@ -2264,6 +2264,12 @@ break_out:
+ 	return (b - buf) ? b - buf : retval;
+ }
+ 
++static ssize_t __attribute__((optimize("-fno-optimize-sibling-calls"))) n_tty_write(struct tty_struct *tty, struct file *file,
++			   const unsigned char *buf, size_t nr)
++{
++	return kpatch_n_tty_write(tty, file, buf, nr);
++}
++
+ /**
+  *	n_tty_poll		-	poll method for N_TTY
+  *	@tty: terminal device
diff --git a/test/integration/centos-7/new-globals.patch b/test/integration/rhel-7.9/new-globals.patch
similarity index 67%
rename from test/integration/centos-7/new-globals.patch
rename to test/integration/rhel-7.9/new-globals.patch
index 3d9d349..4840c97 100644
--- a/test/integration/centos-7/new-globals.patch
+++ b/test/integration/rhel-7.9/new-globals.patch
@@ -1,6 +1,6 @@
 diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
---- src.orig/fs/proc/cmdline.c	2017-09-22 15:27:21.698056175 -0400
-+++ src/fs/proc/cmdline.c	2017-09-22 15:27:47.028161067 -0400
+--- src.orig/fs/proc/cmdline.c	2020-09-03 11:48:30.496726119 -0400
++++ src/fs/proc/cmdline.c	2020-09-03 11:49:07.740842636 -0400
 @@ -27,3 +27,10 @@ static int __init proc_cmdline_init(void
  	return 0;
  }
@@ -13,9 +13,9 @@ diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
 +		printk("hello there!\n");
 +}
 diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
---- src.orig/fs/proc/meminfo.c	2017-09-22 15:27:21.699056179 -0400
-+++ src/fs/proc/meminfo.c	2017-09-22 15:27:47.029161071 -0400
-@@ -16,6 +16,8 @@
+--- src.orig/fs/proc/meminfo.c	2020-09-03 11:48:30.497726123 -0400
++++ src/fs/proc/meminfo.c	2020-09-03 11:49:07.740842636 -0400
+@@ -17,6 +17,8 @@
  #include <asm/pgtable.h>
  #include "internal.h"
  
@@ -24,7 +24,7 @@ diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
  void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
  {
  }
-@@ -53,6 +55,7 @@ static int meminfo_proc_show(struct seq_
+@@ -54,6 +56,7 @@ static int meminfo_proc_show(struct seq_
  	/*
  	 * Tagged format, for easy grepping and expansion.
  	 */
diff --git a/test/integration/centos-7/parainstructions-section.patch b/test/integration/rhel-7.9/parainstructions-section.patch
similarity index 70%
rename from test/integration/centos-7/parainstructions-section.patch
rename to test/integration/rhel-7.9/parainstructions-section.patch
index 809dce4..d7a02f9 100644
--- a/test/integration/centos-7/parainstructions-section.patch
+++ b/test/integration/rhel-7.9/parainstructions-section.patch
@@ -1,6 +1,6 @@
 diff -Nupr src.orig/fs/proc/generic.c src/fs/proc/generic.c
---- src.orig/fs/proc/generic.c	2017-09-22 15:27:21.698056175 -0400
-+++ src/fs/proc/generic.c	2017-09-22 15:27:48.190165879 -0400
+--- src.orig/fs/proc/generic.c	2020-09-03 11:48:30.496726119 -0400
++++ src/fs/proc/generic.c	2020-09-03 11:49:09.715848815 -0400
 @@ -194,6 +194,7 @@ int proc_alloc_inum(unsigned int *inum)
  	unsigned int i;
  	int error;
diff --git a/test/integration/centos-7/shadow-newpid-LOADED.test b/test/integration/rhel-7.9/shadow-newpid-LOADED.test
similarity index 100%
rename from test/integration/centos-7/shadow-newpid-LOADED.test
rename to test/integration/rhel-7.9/shadow-newpid-LOADED.test
diff --git a/test/integration/centos-7/shadow-newpid.patch b/test/integration/rhel-7.9/shadow-newpid.patch
similarity index 62%
rename from test/integration/centos-7/shadow-newpid.patch
rename to test/integration/rhel-7.9/shadow-newpid.patch
index 2184208..2c4ae45 100644
--- a/test/integration/centos-7/shadow-newpid.patch
+++ b/test/integration/rhel-7.9/shadow-newpid.patch
@@ -1,8 +1,7 @@
-Index: src/fs/proc/array.c
-===================================================================
---- src.orig/fs/proc/array.c
-+++ src/fs/proc/array.c
-@@ -394,13 +394,20 @@ static inline void task_seccomp(struct s
+diff -Nupr src.orig/fs/proc/array.c src/fs/proc/array.c
+--- src.orig/fs/proc/array.c	2020-09-03 11:48:30.496726119 -0400
++++ src/fs/proc/array.c	2020-09-03 11:49:11.696855012 -0400
+@@ -395,13 +395,20 @@ static inline void task_seccomp(struct s
  	seq_putc(m, '\n');
  }
  
@@ -23,10 +22,9 @@ Index: src/fs/proc/array.c
  }
  
  static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
-Index: src/kernel/exit.c
-===================================================================
---- src.orig/kernel/exit.c
-+++ src/kernel/exit.c
+diff -Nupr src.orig/kernel/exit.c src/kernel/exit.c
+--- src.orig/kernel/exit.c	2020-09-03 11:48:30.717726811 -0400
++++ src/kernel/exit.c	2020-09-03 11:49:11.696855012 -0400
 @@ -791,6 +791,7 @@ static void check_stack_usage(void)
  static inline void check_stack_usage(void) {}
  #endif
@@ -44,11 +42,10 @@ Index: src/kernel/exit.c
  	/*
  	 * Flush inherited counters to the parent - before the parent
  	 * gets woken up by child-exit notifications.
-Index: src/kernel/fork.c
-===================================================================
---- src.orig/kernel/fork.c
-+++ src/kernel/fork.c
-@@ -1757,6 +1757,7 @@ struct task_struct *fork_idle(int cpu)
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2020-09-03 11:48:30.717726811 -0400
++++ src/kernel/fork.c	2020-09-03 11:49:11.697855015 -0400
+@@ -1784,6 +1784,7 @@ struct task_struct *fork_idle(int cpu)
   * It copies the process, and if successful kick-starts
   * it and waits for it to finish using the VM if required.
   */
@@ -56,15 +53,15 @@ Index: src/kernel/fork.c
  long do_fork(unsigned long clone_flags,
  	      unsigned long stack_start,
  	      unsigned long stack_size,
-@@ -1794,6 +1795,13 @@ long do_fork(unsigned long clone_flags,
+@@ -1821,6 +1822,13 @@ long do_fork(unsigned long clone_flags,
  	if (!IS_ERR(p)) {
  		struct completion vfork;
  		struct pid *pid;
 +		int *newpid;
 +		static int ctr = 0;
 +
-+		newpid = klp_shadow_get_or_alloc(p, 0, sizeof(*newpid),
-+					     GFP_KERNEL, NULL, NULL);
++		newpid = klp_shadow_get_or_alloc(p, 0, sizeof(*newpid), GFP_KERNEL,
++						NULL, NULL);
 +		if (newpid)
 +			*newpid = ctr++;
  
diff --git a/test/integration/centos-7/smp-locks-section.patch b/test/integration/rhel-7.9/smp-locks-section.patch
similarity index 76%
rename from test/integration/centos-7/smp-locks-section.patch
rename to test/integration/rhel-7.9/smp-locks-section.patch
index 6f39d53..a044e41 100644
--- a/test/integration/centos-7/smp-locks-section.patch
+++ b/test/integration/rhel-7.9/smp-locks-section.patch
@@ -1,6 +1,6 @@
 diff -Nupr src.orig/drivers/tty/tty_buffer.c src/drivers/tty/tty_buffer.c
---- src.orig/drivers/tty/tty_buffer.c	2017-09-22 15:27:21.077053604 -0400
-+++ src/drivers/tty/tty_buffer.c	2017-09-22 15:27:50.542175618 -0400
+--- src.orig/drivers/tty/tty_buffer.c	2020-09-03 11:48:29.616723366 -0400
++++ src/drivers/tty/tty_buffer.c	2020-09-03 11:49:13.626861050 -0400
 @@ -217,6 +217,10 @@ int tty_buffer_request_room(struct tty_p
  	/* OPTIMISATION: We could keep a per tty "zero" sized buffer to
  	   remove this conditional if its worth it. This would be invisible
diff --git a/test/integration/centos-7/special-static.patch b/test/integration/rhel-7.9/special-static.patch
similarity index 65%
rename from test/integration/centos-7/special-static.patch
rename to test/integration/rhel-7.9/special-static.patch
index 84647ec..c098331 100644
--- a/test/integration/centos-7/special-static.patch
+++ b/test/integration/rhel-7.9/special-static.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
---- src.orig/kernel/fork.c	2017-09-22 15:27:21.600055769 -0400
-+++ src/kernel/fork.c	2017-09-22 15:27:53.052186012 -0400
-@@ -1129,10 +1129,18 @@ static void posix_cpu_timers_init_group(
+--- src.orig/kernel/fork.c	2020-09-03 11:48:30.717726811 -0400
++++ src/kernel/fork.c	2020-09-03 11:49:15.602867232 -0400
+@@ -1153,10 +1153,18 @@ static void posix_cpu_timers_init_group(
  	INIT_LIST_HEAD(&sig->cpu_timers[2]);
  }
  
diff --git a/test/integration/rhel-7.9/symvers-disagreement-FAIL.patch b/test/integration/rhel-7.9/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..300f8b9
--- /dev/null
+++ b/test/integration/rhel-7.9/symvers-disagreement-FAIL.patch
@@ -0,0 +1,49 @@
+From da109d66a890373d0aa831f97b49aaffcc4eeb45 Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes a function referencing a function whose CRC has changed,
+   causing the symbol and the new CRC to be included in the __version
+   section of the final module.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index b9a71137208..4af27e069c2 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -31,6 +31,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index 8b1c4a5ee78..1b7997b58c0 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -693,6 +693,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/centos-7/tracepoints-section.patch b/test/integration/rhel-7.9/tracepoints-section.patch
similarity index 59%
rename from test/integration/centos-7/tracepoints-section.patch
rename to test/integration/rhel-7.9/tracepoints-section.patch
index b770f9e..33a15ed 100644
--- a/test/integration/centos-7/tracepoints-section.patch
+++ b/test/integration/rhel-7.9/tracepoints-section.patch
@@ -1,7 +1,7 @@
 diff -Nupr src.orig/kernel/timer.c src/kernel/timer.c
---- src.orig/kernel/timer.c	2017-09-22 15:27:21.600055769 -0400
-+++ src/kernel/timer.c	2017-09-22 15:27:54.288191131 -0400
-@@ -1390,6 +1390,9 @@ static void run_timer_softirq(struct sof
+--- src.orig/kernel/timer.c	2020-09-03 11:48:30.726726839 -0400
++++ src/kernel/timer.c	2020-09-03 11:49:17.588873445 -0400
+@@ -1454,6 +1454,9 @@ static void run_timer_softirq(struct sof
  {
  	struct tvec_base *base = __this_cpu_read(tvec_bases);
  
diff --git a/test/integration/centos-7/warn-detect-FAIL.patch b/test/integration/rhel-7.9/warn-detect-FAIL.patch
similarity index 52%
rename from test/integration/centos-7/warn-detect-FAIL.patch
rename to test/integration/rhel-7.9/warn-detect-FAIL.patch
index 8efa782..2f51ba7 100644
--- a/test/integration/centos-7/warn-detect-FAIL.patch
+++ b/test/integration/rhel-7.9/warn-detect-FAIL.patch
@@ -1,6 +1,6 @@
 diff -Nupr src.orig/arch/x86/kvm/x86.c src/arch/x86/kvm/x86.c
---- src.orig/arch/x86/kvm/x86.c	2017-09-22 15:27:20.852052672 -0400
-+++ src/arch/x86/kvm/x86.c	2017-09-22 15:27:55.489196104 -0400
+--- src.orig/arch/x86/kvm/x86.c	2020-09-03 11:48:30.386725775 -0400
++++ src/arch/x86/kvm/x86.c	2020-09-03 11:49:19.587879699 -0400
 @@ -1,3 +1,4 @@
 +
  /*
diff --git a/test/integration/rhel-8.0/gcc-static-local-var-4.test b/test/integration/rhel-8.0/gcc-static-local-var-4.test.disabled
similarity index 100%
rename from test/integration/rhel-8.0/gcc-static-local-var-4.test
rename to test/integration/rhel-8.0/gcc-static-local-var-4.test.disabled
diff --git a/test/integration/rhel-8.0/symvers-disagreement-FAIL.patch b/test/integration/rhel-8.0/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..e3a672a
--- /dev/null
+++ b/test/integration/rhel-8.0/symvers-disagreement-FAIL.patch
@@ -0,0 +1,51 @@
+From 7085a655b8d665b6314e8dab2f803bac0aea04ec Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index df3e1a44707a..15c9d6e2e1e0 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -29,6 +29,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index 623be3174fb3..4ddd74ae0bb9 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -685,6 +685,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/rhel-8.1/module.patch b/test/integration/rhel-8.1/module.patch
index 5ee8704..8bfb621 100644
--- a/test/integration/rhel-8.1/module.patch
+++ b/test/integration/rhel-8.1/module.patch
@@ -37,9 +37,9 @@ index a1143f7c2201..253c15ad82b2 100644
  	struct cache_head *cp = p;
  	struct svc_export *exp = container_of(cp, struct svc_export, h);
  	struct cache_detail *cd = m->private;
++#ifdef CONFIG_X86_64
 +	unsigned long long sched_clock;
 +
-+#ifdef CONFIG_X86_64
 +	alternative("ud2", "call yield", X86_FEATURE_ALWAYS);
 +	alternative("call yield", "ud2", X86_FEATURE_IA64);
 +
diff --git a/test/integration/rhel-8.1/shadow-newpid-LOADED.test b/test/integration/rhel-8.1/shadow-newpid-LOADED.test.disabled
similarity index 100%
rename from test/integration/rhel-8.1/shadow-newpid-LOADED.test
rename to test/integration/rhel-8.1/shadow-newpid-LOADED.test.disabled
diff --git a/test/integration/rhel-8.1/symvers-disagreement-FAIL.patch b/test/integration/rhel-8.1/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..9527641
--- /dev/null
+++ b/test/integration/rhel-8.1/symvers-disagreement-FAIL.patch
@@ -0,0 +1,51 @@
+From c63702554e54b992793fe3598ea8c8c415bef908 Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index 2ab316d85651..2ef19920f6ab 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -29,6 +29,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index 0a2b261a27c9..51a1868c9cea 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -685,6 +685,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/rhel-8.2/bug-table-section.patch b/test/integration/rhel-8.2/bug-table-section.patch
new file mode 100644
index 0000000..5bc1e11
--- /dev/null
+++ b/test/integration/rhel-8.2/bug-table-section.patch
@@ -0,0 +1,12 @@
+diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
+--- src.orig/fs/proc/proc_sysctl.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/proc_sysctl.c	2020-05-12 11:14:36.220489794 -0400
+@@ -338,6 +338,8 @@ static void start_unregistering(struct c
+ 
+ static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)
+ {
++	if (jiffies == 0)
++		printk("kpatch-test: testing __bug_table section changes\n");
+ 	BUG_ON(!head);
+ 	spin_lock(&sysctl_lock);
+ 	if (!use_table(head))
diff --git a/test/integration/rhel-8.2/cmdline-string-LOADED.test b/test/integration/rhel-8.2/cmdline-string-LOADED.test
new file mode 100755
index 0000000..a8e0a08
--- /dev/null
+++ b/test/integration/rhel-8.2/cmdline-string-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep kpatch=1 /proc/cmdline
diff --git a/test/integration/rhel-8.2/cmdline-string.patch b/test/integration/rhel-8.2/cmdline-string.patch
new file mode 100644
index 0000000..4838935
--- /dev/null
+++ b/test/integration/rhel-8.2/cmdline-string.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/cmdline.c	2020-05-12 11:14:40.110321212 -0400
+@@ -6,8 +6,7 @@
+ 
+ static int cmdline_proc_show(struct seq_file *m, void *v)
+ {
+-	seq_puts(m, saved_command_line);
+-	seq_putc(m, '\n');
++	seq_printf(m, "%s kpatch=1\n", saved_command_line);
+ 	return 0;
+ }
+ 
diff --git a/test/integration/rhel-8.2/data-new-LOADED.test b/test/integration/rhel-8.2/data-new-LOADED.test
new file mode 100755
index 0000000..9f25744
--- /dev/null
+++ b/test/integration/rhel-8.2/data-new-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep "kpatch:         5" /proc/meminfo
diff --git a/test/integration/rhel-8.2/data-new.patch b/test/integration/rhel-8.2/data-new.patch
new file mode 100644
index 0000000..6978e52
--- /dev/null
+++ b/test/integration/rhel-8.2/data-new.patch
@@ -0,0 +1,20 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/meminfo.c	2020-05-12 11:14:43.210186867 -0400
+@@ -31,6 +31,8 @@ static void show_val_kb(struct seq_file
+ 	seq_write(m, " kB\n", 4);
+ }
+ 
++static int foo = 5;
++
+ static int meminfo_proc_show(struct seq_file *m, void *v)
+ {
+ 	struct sysinfo i;
+@@ -143,6 +145,7 @@ static int meminfo_proc_show(struct seq_
+ 	show_val_kb(m, "CmaFree:        ",
+ 		    global_zone_page_state(NR_FREE_CMA_PAGES));
+ #endif
++	seq_printf(m, "kpatch:         %d\n", foo);
+ 
+ 	hugetlb_report_meminfo(m);
+ 
diff --git a/test/integration/rhel-8.2/data-read-mostly.patch.disabled b/test/integration/rhel-8.2/data-read-mostly.patch.disabled
new file mode 100644
index 0000000..5b1c87a
--- /dev/null
+++ b/test/integration/rhel-8.2/data-read-mostly.patch.disabled
@@ -0,0 +1,13 @@
+Disabled due to https:/github.com/dynup/kpatch/issues/940
+---
+diff -Nupr src.orig/net/core/dev.c src/net/core/dev.c
+--- src.orig/net/core/dev.c	2020-05-12 11:14:29.800768017 -0400
++++ src/net/core/dev.c	2020-05-12 11:15:38.827776462 -0400
+@@ -4893,6 +4893,7 @@ skip_classify:
+ 		case RX_HANDLER_PASS:
+ 			break;
+ 		default:
++			printk("BUG!\n");
+ 			BUG();
+ 		}
+ 	}
diff --git a/test/integration/rhel-8.2/fixup-section.patch b/test/integration/rhel-8.2/fixup-section.patch
new file mode 100644
index 0000000..6632001
--- /dev/null
+++ b/test/integration/rhel-8.2/fixup-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/readdir.c src/fs/readdir.c
+--- src.orig/fs/readdir.c	2020-05-12 11:14:29.170795319 -0400
++++ src/fs/readdir.c	2020-05-12 11:14:46.280053823 -0400
+@@ -189,6 +189,7 @@ static int filldir(struct dir_context *c
+ 			goto efault;
+ 	}
+ 	dirent = buf->current_dir;
++	asm("nop");
+ 	if (__put_user(d_ino, &dirent->d_ino))
+ 		goto efault;
+ 	if (__put_user(reclen, &dirent->d_reclen))
diff --git a/test/integration/rhel-8.2/gcc-constprop.patch b/test/integration/rhel-8.2/gcc-constprop.patch
new file mode 100644
index 0000000..1a17df4
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-constprop.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/kernel/time/timekeeping.c src/kernel/time/timekeeping.c
+--- src.orig/kernel/time/timekeeping.c	2020-05-12 11:14:29.670773651 -0400
++++ src/kernel/time/timekeeping.c	2020-05-12 11:15:41.897643417 -0400
+@@ -1221,6 +1221,9 @@ void do_gettimeofday(struct timeval *tv)
+ {
+ 	struct timespec64 now;
+ 
++	if (!tv)
++		return;
++
+ 	getnstimeofday64(&now);
+ 	tv->tv_sec = now.tv_sec;
+ 	tv->tv_usec = now.tv_nsec/1000;
diff --git a/test/integration/rhel-8.2/gcc-isra.patch b/test/integration/rhel-8.2/gcc-isra.patch
new file mode 100644
index 0000000..073b60f
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-isra.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
+--- src.orig/fs/proc/proc_sysctl.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/proc_sysctl.c	2020-05-12 11:14:49.359920345 -0400
+@@ -53,6 +53,7 @@ void proc_sys_poll_notify(struct ctl_tab
+ 	if (!poll)
+ 		return;
+ 
++	printk("kpatch-test: testing gcc .isra function name mangling\n");
+ 	atomic_inc(&poll->event);
+ 	wake_up_interruptible(&poll->wait);
+ }
diff --git a/test/integration/rhel-8.2/gcc-mangled-3.patch b/test/integration/rhel-8.2/gcc-mangled-3.patch
new file mode 100644
index 0000000..8d096e4
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-mangled-3.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/mm/slub.c src/mm/slub.c
+--- src.orig/mm/slub.c	2020-05-12 11:14:32.110667908 -0400
++++ src/mm/slub.c	2020-05-12 11:14:52.439786867 -0400
+@@ -5852,6 +5852,9 @@ void get_slabinfo(struct kmem_cache *s,
+ 	int node;
+ 	struct kmem_cache_node *n;
+ 
++	if (!jiffies)
++		printk("slabinfo\n");
++
+ 	for_each_kmem_cache_node(s, node, n) {
+ 		nr_slabs += node_nr_slabs(n);
+ 		nr_objs += node_nr_objs(n);
diff --git a/test/integration/rhel-8.2/gcc-static-local-var-2.patch b/test/integration/rhel-8.2/gcc-static-local-var-2.patch
new file mode 100644
index 0000000..a735a1f
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-static-local-var-2.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/mm/mmap.c src/mm/mmap.c
+--- src.orig/mm/mmap.c	2020-05-12 11:14:32.110667908 -0400
++++ src/mm/mmap.c	2020-05-12 11:14:55.529652955 -0400
+@@ -1679,6 +1679,9 @@ unsigned long mmap_region(struct file *f
+ 	struct rb_node **rb_link, *rb_parent;
+ 	unsigned long charged = 0;
+ 
++	if (!jiffies)
++		printk("kpatch mmap foo\n");
++
+ 	/* Check against address space limit. */
+ 	if (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {
+ 		unsigned long nr_pages;
diff --git a/test/integration/rhel-8.2/gcc-static-local-var-3.patch b/test/integration/rhel-8.2/gcc-static-local-var-3.patch
new file mode 100644
index 0000000..2b7af0f
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-static-local-var-3.patch
@@ -0,0 +1,19 @@
+diff -Nupr src.orig/kernel/reboot.c src/kernel/reboot.c
+--- src.orig/kernel/reboot.c	2020-05-12 11:14:29.670773651 -0400
++++ src/kernel/reboot.c	2020-05-12 11:14:58.579520777 -0400
+@@ -393,8 +393,15 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
+ 	return ret;
+ }
+ 
++void kpatch_bar(void)
++{
++	if (!jiffies)
++		printk("kpatch_foo\n");
++}
++
+ static void deferred_cad(struct work_struct *dummy)
+ {
++	kpatch_bar();
+ 	kernel_restart(NULL);
+ }
+ 
diff --git a/test/integration/rhel-8.2/gcc-static-local-var-4.patch.disabled b/test/integration/rhel-8.2/gcc-static-local-var-4.patch.disabled
new file mode 100644
index 0000000..783f598
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-static-local-var-4.patch.disabled
@@ -0,0 +1,24 @@
+Disabled due to https:/github.com/dynup/kpatch/issues/940
+---
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2020-05-12 11:14:29.130797053 -0400
++++ src/fs/aio.c	2020-05-12 11:15:44.967510372 -0400
+@@ -251,11 +251,18 @@ static int __init aio_setup(void)
+ }
+ __initcall(aio_setup);
+ 
++void kpatch_aio_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch aio foo\n");
++}
++
+ static void put_aio_ring_file(struct kioctx *ctx)
+ {
+ 	struct file *aio_ring_file = ctx->aio_ring_file;
+ 	struct address_space *i_mapping;
+ 
++	kpatch_aio_foo();
+ 	if (aio_ring_file) {
+ 		truncate_setsize(file_inode(aio_ring_file), 0);
+ 
diff --git a/test/integration/rhel-8.2/gcc-static-local-var-4.test.disabled b/test/integration/rhel-8.2/gcc-static-local-var-4.test.disabled
new file mode 100755
index 0000000..e085f93
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-static-local-var-4.test.disabled
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+set -o pipefail
+if ! $(eu-readelf --wide --symbols test-gcc-static-local-var-4.ko | awk '$NF == "free_ioctx" { exit 1 }'); then
+	exit 1
+else
+	exit 0
+fi
diff --git a/test/integration/rhel-8.2/gcc-static-local-var-5.patch b/test/integration/rhel-8.2/gcc-static-local-var-5.patch
new file mode 100644
index 0000000..b6f492b
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-static-local-var-5.patch
@@ -0,0 +1,45 @@
+diff -Nupr src.orig/kernel/audit.c src/kernel/audit.c
+--- src.orig/kernel/audit.c	2020-05-12 11:24:26.314915742 -0400
++++ src/kernel/audit.c	2020-05-12 11:24:37.024451603 -0400
+@@ -321,6 +321,12 @@ void audit_panic(const char *message)
+ 	}
+ }
+ 
++void kpatch_audit_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch audit foo\n");
++}
++
+ static inline int audit_rate_check(void)
+ {
+ 	static unsigned long	last_check = 0;
+@@ -331,6 +337,7 @@ static inline int audit_rate_check(void)
+ 	unsigned long		elapsed;
+ 	int			retval	   = 0;
+ 
++	kpatch_audit_foo();
+ 	if (!audit_rate_limit) return 1;
+ 
+ 	spin_lock_irqsave(&lock, flags);
+@@ -350,6 +357,11 @@ static inline int audit_rate_check(void)
+ 	return retval;
+ }
+ 
++noinline void kpatch_audit_check(void)
++{
++	audit_rate_check();
++}
++
+ /**
+  * audit_log_lost - conditionally log lost audit message event
+  * @message: the message stating reason for lost audit message
+@@ -396,6 +408,8 @@ static int audit_log_config_change(char
+ 	struct audit_buffer *ab;
+ 	int rc = 0;
+ 
++	kpatch_audit_check();
++
+ 	ab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);
+ 	if (unlikely(!ab))
+ 		return rc;
diff --git a/test/integration/rhel-8.2/gcc-static-local-var-6.patch b/test/integration/rhel-8.2/gcc-static-local-var-6.patch
new file mode 100644
index 0000000..378433e
--- /dev/null
+++ b/test/integration/rhel-8.2/gcc-static-local-var-6.patch
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/net/ipv6/netfilter.c src/net/ipv6/netfilter.c
+--- src.orig/net/ipv6/netfilter.c	2020-05-12 11:14:29.820767150 -0400
++++ src/net/ipv6/netfilter.c	2020-05-12 11:15:01.659387299 -0400
+@@ -87,6 +87,8 @@ static int nf_ip6_reroute(struct sk_buff
+ 	return 0;
+ }
+ 
++#include "kpatch-macros.h"
++
+ static int nf_ip6_route(struct net *net, struct dst_entry **dst,
+ 			struct flowi *fl, bool strict)
+ {
+@@ -100,6 +102,9 @@ static int nf_ip6_route(struct net *net,
+ 	struct dst_entry *result;
+ 	int err;
+ 
++	if (!jiffies)
++		printk("kpatch nf_ip6_route foo\n");
++
+ 	result = ip6_route_output(net, sk, &fl->u.ip6);
+ 	err = result->error;
+ 	if (err)
diff --git a/test/integration/rhel-8.2/macro-callbacks.patch b/test/integration/rhel-8.2/macro-callbacks.patch
new file mode 100644
index 0000000..e2c7df9
--- /dev/null
+++ b/test/integration/rhel-8.2/macro-callbacks.patch
@@ -0,0 +1,155 @@
+diff -Nupr src.orig/drivers/input/joydev.c src/drivers/input/joydev.c
+--- src.orig/drivers/input/joydev.c	2020-05-12 11:14:32.580647540 -0400
++++ src/drivers/input/joydev.c	2020-05-12 11:15:04.909246454 -0400
+@@ -1084,3 +1084,47 @@ static void __exit joydev_exit(void)
+ 
+ module_init(joydev_init);
+ module_exit(joydev_exit);
++
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0; /* return -ENODEV; */
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/drivers/input/misc/pcspkr.c src/drivers/input/misc/pcspkr.c
+--- src.orig/drivers/input/misc/pcspkr.c	2020-05-12 11:14:32.590647107 -0400
++++ src/drivers/input/misc/pcspkr.c	2020-05-12 11:15:04.909246454 -0400
+@@ -133,3 +133,46 @@ static struct platform_driver pcspkr_pla
+ };
+ module_platform_driver(pcspkr_platform_driver);
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2020-05-12 11:14:29.130797053 -0400
++++ src/fs/aio.c	2020-05-12 11:15:04.909246454 -0400
+@@ -49,6 +49,50 @@
+ 
+ #define KIOCB_KEY		0
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
++
+ #define AIO_RING_MAGIC			0xa10a10a1
+ #define AIO_RING_COMPAT_FEATURES	1
+ #define AIO_RING_INCOMPAT_FEATURES	0
diff --git a/test/integration/rhel-8.2/macro-printk.patch b/test/integration/rhel-8.2/macro-printk.patch
new file mode 100644
index 0000000..f2d2d4b
--- /dev/null
+++ b/test/integration/rhel-8.2/macro-printk.patch
@@ -0,0 +1,148 @@
+diff -Nupr src.orig/net/ipv4/fib_frontend.c src/net/ipv4/fib_frontend.c
+--- src.orig/net/ipv4/fib_frontend.c	2020-05-12 11:14:29.710771918 -0400
++++ src/net/ipv4/fib_frontend.c	2020-05-12 11:15:48.047376894 -0400
+@@ -789,6 +789,7 @@ errout:
+ 	return err;
+ }
+ 
++#include "kpatch-macros.h"
+ static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			     struct netlink_ext_ack *extack)
+ {
+@@ -810,6 +811,7 @@ static int inet_rtm_newroute(struct sk_b
+ 	err = fib_table_insert(net, tb, &cfg, extack);
+ 	if (!err && cfg.fc_type == RTN_LOCAL)
+ 		net->ipv4.fib_has_custom_local_routes = true;
++	KPATCH_PRINTK("[inet_rtm_newroute]: err is %d\n", err);
+ errout:
+ 	return err;
+ }
+diff -Nupr src.orig/net/ipv4/fib_semantics.c src/net/ipv4/fib_semantics.c
+--- src.orig/net/ipv4/fib_semantics.c	2020-05-12 11:14:29.710771918 -0400
++++ src/net/ipv4/fib_semantics.c	2020-05-12 11:15:48.047376894 -0400
+@@ -1025,6 +1025,7 @@ fib_convert_metrics(struct fib_info *fi,
+ 				  fi->fib_metrics->metrics);
+ }
+ 
++#include "kpatch-macros.h"
+ struct fib_info *fib_create_info(struct fib_config *cfg,
+ 				 struct netlink_ext_ack *extack)
+ {
+@@ -1058,6 +1059,7 @@ struct fib_info *fib_create_info(struct
+ #endif
+ 
+ 	err = -ENOBUFS;
++	KPATCH_PRINTK("[fib_create_info]: create error err is %d\n",err);
+ 	if (fib_info_cnt >= fib_info_hash_size) {
+ 		unsigned int new_size = fib_info_hash_size << 1;
+ 		struct hlist_head *new_info_hash;
+@@ -1078,6 +1080,7 @@ struct fib_info *fib_create_info(struct
+ 		if (!fib_info_hash_size)
+ 			goto failure;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 2 create error err is %d\n",err);
+ 
+ 	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
+ 	if (!fi)
+@@ -1093,6 +1096,8 @@ struct fib_info *fib_create_info(struct
+ 		fi->fib_metrics = (struct dst_metrics *)&dst_default_metrics;
+ 	}
+ 	fib_info_cnt++;
++	KPATCH_PRINTK("[fib_create_info]: 3 create error err is %d\n",err);
++
+ 	fi->fib_net = net;
+ 	fi->fib_protocol = cfg->fc_protocol;
+ 	fi->fib_scope = cfg->fc_scope;
+@@ -1109,8 +1114,10 @@ struct fib_info *fib_create_info(struct
+ 		if (!nexthop_nh->nh_pcpu_rth_output)
+ 			goto failure;
+ 	} endfor_nexthops(fi)
++	KPATCH_PRINTK("[fib_create_info]: 4 create error err is %d\n",err);
+ 
+ 	err = fib_convert_metrics(fi, cfg);
++	KPATCH_PRINTK("[fib_create_info]: 5 create error err is %d\n",err);
+ 	if (err)
+ 		goto failure;
+ 
+@@ -1172,6 +1179,7 @@ struct fib_info *fib_create_info(struct
+ 		nh->nh_weight = 1;
+ #endif
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 6 create error err is %d\n",err);
+ 
+ 	if (fib_props[cfg->fc_type].error) {
+ 		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp) {
+@@ -1193,6 +1201,7 @@ struct fib_info *fib_create_info(struct
+ 			goto err_inval;
+ 		}
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 7 create error err is %d\n",err);
+ 
+ 	if (cfg->fc_scope > RT_SCOPE_HOST) {
+ 		NL_SET_ERR_MSG(extack, "Invalid scope");
+@@ -1231,6 +1240,7 @@ struct fib_info *fib_create_info(struct
+ 		if (linkdown == fi->fib_nhs)
+ 			fi->fib_flags |= RTNH_F_LINKDOWN;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 8 create error err is %d\n",err);
+ 
+ 	if (fi->fib_prefsrc && !fib_valid_prefsrc(cfg, fi->fib_prefsrc)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid prefsrc address");
+@@ -1240,6 +1250,7 @@ struct fib_info *fib_create_info(struct
+ 	change_nexthops(fi) {
+ 		fib_info_update_nh_saddr(net, nexthop_nh);
+ 	} endfor_nexthops(fi)
++	KPATCH_PRINTK("[fib_create_info]: 9 create error err is %d\n",err);
+ 
+ 	fib_rebalance(fi);
+ 
+@@ -1251,6 +1262,7 @@ link_it:
+ 		ofi->fib_treeref++;
+ 		return ofi;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 10 create error err is %d\n",err);
+ 
+ 	fi->fib_treeref++;
+ 	refcount_set(&fi->fib_clntref, 1);
+@@ -1274,6 +1286,7 @@ link_it:
+ 		hlist_add_head(&nexthop_nh->nh_hash, head);
+ 	} endfor_nexthops(fi)
+ 	spin_unlock_bh(&fib_info_lock);
++	KPATCH_PRINTK("[fib_create_info]: 11 create error err is %d\n",err);
+ 	return fi;
+ 
+ err_inval:
+@@ -1284,6 +1297,7 @@ failure:
+ 		fi->fib_dead = 1;
+ 		free_fib_info(fi);
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 12 create error err is %d\n",err);
+ 
+ 	return ERR_PTR(err);
+ }
+diff -Nupr src.orig/net/ipv4/fib_trie.c src/net/ipv4/fib_trie.c
+--- src.orig/net/ipv4/fib_trie.c	2020-05-12 11:14:29.710771918 -0400
++++ src/net/ipv4/fib_trie.c	2020-05-12 11:15:48.047376894 -0400
+@@ -1121,6 +1121,7 @@ static bool fib_valid_key_len(u32 key, u
+ }
+ 
+ /* Caller must hold RTNL. */
++#include "kpatch-macros.h"
+ int fib_table_insert(struct net *net, struct fib_table *tb,
+ 		     struct fib_config *cfg, struct netlink_ext_ack *extack)
+ {
+@@ -1143,11 +1144,14 @@ int fib_table_insert(struct net *net, st
+ 
+ 	pr_debug("Insert table=%u %08x/%d\n", tb->tb_id, key, plen);
+ 
++	KPATCH_PRINTK("[fib_table_insert]: start\n");
+ 	fi = fib_create_info(cfg, extack);
+ 	if (IS_ERR(fi)) {
+ 		err = PTR_ERR(fi);
++		KPATCH_PRINTK("[fib_table_insert]: create error err is %d\n",err);
+ 		goto err;
+ 	}
++	KPATCH_PRINTK("[fib_table_insert]: cross\n");
+ 
+ 	l = fib_find_node(t, &tp, key);
+ 	fa = l ? fib_find_alias(&l->leaf, slen, tos, fi->fib_priority,
diff --git a/test/integration/rhel-8.2/meminfo-init-FAIL.patch b/test/integration/rhel-8.2/meminfo-init-FAIL.patch
new file mode 100644
index 0000000..6f58adb
--- /dev/null
+++ b/test/integration/rhel-8.2/meminfo-init-FAIL.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/meminfo.c	2020-05-12 11:15:13.848859021 -0400
+@@ -153,6 +153,7 @@ static int meminfo_proc_show(struct seq_
+ 
+ static int __init proc_meminfo_init(void)
+ {
++	printk("a\n");
+ 	proc_create_single("meminfo", 0, NULL, meminfo_proc_show);
+ 	return 0;
+ }
diff --git a/test/integration/rhel-8.2/meminfo-init2-FAIL.patch b/test/integration/rhel-8.2/meminfo-init2-FAIL.patch
new file mode 100644
index 0000000..28ba5bc
--- /dev/null
+++ b/test/integration/rhel-8.2/meminfo-init2-FAIL.patch
@@ -0,0 +1,19 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/meminfo.c	2020-05-12 11:15:10.778992066 -0400
+@@ -41,6 +41,7 @@ static int meminfo_proc_show(struct seq_
+ 	unsigned long sreclaimable, sunreclaim;
+ 	int lru;
+ 
++	printk("a\n");
+ 	si_meminfo(&i);
+ 	si_swapinfo(&i);
+ 	committed = percpu_counter_read_positive(&vm_committed_as);
+@@ -153,6 +154,7 @@ static int meminfo_proc_show(struct seq_
+ 
+ static int __init proc_meminfo_init(void)
+ {
++	printk("a\n");
+ 	proc_create_single("meminfo", 0, NULL, meminfo_proc_show);
+ 	return 0;
+ }
diff --git a/test/integration/rhel-8.2/meminfo-string-LOADED.test b/test/integration/rhel-8.2/meminfo-string-LOADED.test
new file mode 100755
index 0000000..10dc20b
--- /dev/null
+++ b/test/integration/rhel-8.2/meminfo-string-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep VMALLOCCHUNK /proc/meminfo
diff --git a/test/integration/rhel-8.2/meminfo-string.patch b/test/integration/rhel-8.2/meminfo-string.patch
new file mode 100644
index 0000000..278e0e5
--- /dev/null
+++ b/test/integration/rhel-8.2/meminfo-string.patch
@@ -0,0 +1,12 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-05-12 11:24:25.954931343 -0400
++++ src/fs/proc/meminfo.c	2020-05-12 11:24:33.774592448 -0400
+@@ -121,7 +121,7 @@ static int meminfo_proc_show(struct seq_
+ 	seq_printf(m, "VmallocTotal:   %8lu kB\n",
+ 		   (unsigned long)VMALLOC_TOTAL >> 10);
+ 	show_val_kb(m, "VmallocUsed:    ", 0ul);
+-	show_val_kb(m, "VmallocChunk:   ", 0ul);
++	show_val_kb(m, "VMALLOCCHUNK:   ", 0ul);
+ 	show_val_kb(m, "Percpu:         ", pcpu_nr_pages());
+ 
+ #ifdef CONFIG_MEMORY_FAILURE
diff --git a/test/integration/rhel-8.2/module-LOADED.test b/test/integration/rhel-8.2/module-LOADED.test
new file mode 100755
index 0000000..72bb852
--- /dev/null
+++ b/test/integration/rhel-8.2/module-LOADED.test
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+set -o errexit
+
+sudo modprobe nfsd
+sleep 5
+grep -q kpatch /proc/fs/nfs/exports
+
+# TODO: This will trigger a printk on newer kernels which have the .klp.arch
+# removal.  Don't actually do the grep until running on a newer kernel.
+echo "file fs/nfsd/export.c +p" > /sys/kernel/debug/dynamic_debug/control
+cat /proc/fs/nfs/exports > /dev/null
+# dmesg | grep -q "kpatch: pr_debug"
diff --git a/test/integration/rhel-8.2/module.patch b/test/integration/rhel-8.2/module.patch
new file mode 100644
index 0000000..5dcee19
--- /dev/null
+++ b/test/integration/rhel-8.2/module.patch
@@ -0,0 +1,85 @@
+From 08078d00ab1749a6f84148a00d8d26572af4ec97 Mon Sep 17 00:00:00 2001
+Message-Id: <08078d00ab1749a6f84148a00d8d26572af4ec97.1586900628.git.jpoimboe@redhat.com>
+From: Josh Poimboeuf <jpoimboe@redhat.com>
+Date: Tue, 14 Apr 2020 15:17:51 -0500
+Subject: [PATCH] kpatch module integration test
+
+This tests several things related to the patching of modules:
+
+- 'kpatch_string' tests the referencing of a symbol which is outside the
+  .o, but inside the patch module.
+
+- alternatives patching (.altinstructions)
+
+- paravirt patching (.parainstructions)
+
+- jump labels (5.8+ kernels only) -- including dynamic printk
+
+Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
+---
+ fs/nfsd/export.c         | 30 ++++++++++++++++++++++++++++++
+ net/netlink/af_netlink.c |  5 +++++
+ 2 files changed, 35 insertions(+)
+
+diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
+--- src.orig/fs/nfsd/export.c	2020-05-12 11:14:29.230792719 -0400
++++ src/fs/nfsd/export.c	2020-05-12 11:15:17.078719042 -0400
+@@ -1196,15 +1196,45 @@ static void exp_flags(struct seq_file *m
+ 	}
+ }
+ 
++#include <linux/version.h>
++extern char *kpatch_string(void);
++
+ static int e_show(struct seq_file *m, void *p)
+ {
+ 	struct cache_head *cp = p;
+ 	struct svc_export *exp = container_of(cp, struct svc_export, h);
+ 	struct cache_detail *cd = m->private;
++#ifdef CONFIG_X86_64
++	unsigned long long sched_clock;
++
++	alternative("ud2", "call yield", X86_FEATURE_ALWAYS);
++	alternative("call yield", "ud2", X86_FEATURE_IA64);
++
++	sched_clock = paravirt_sched_clock();
++	if (!jiffies)
++		printk("kpatch: sched_clock: %llu\n", sched_clock);
++#endif
++
++	pr_debug("kpatch: pr_debug() test\n");
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
++{
++	static DEFINE_STATIC_KEY_TRUE(kpatch_key);
++
++	if (static_branch_unlikely(&mcsafe_key))
++		printk("kpatch: mcsafe_key\n");
++
++	BUG_ON(!static_branch_likely(&kpatch_key));
++	static_branch_disable(&kpatch_key);
++	BUG_ON(static_branch_likely(&kpatch_key));
++	static_branch_enable(&kpatch_key);
++}
++#endif
+ 
+ 	if (p == SEQ_START_TOKEN) {
+ 		seq_puts(m, "# Version 1.1\n");
+ 		seq_puts(m, "# Path Client(Flags) # IPs\n");
++		seq_puts(m, kpatch_string());
+ 		return 0;
+ 	}
+ 
+diff -Nupr src.orig/net/netlink/af_netlink.c src/net/netlink/af_netlink.c
+--- src.orig/net/netlink/af_netlink.c	2020-05-12 11:14:29.780768884 -0400
++++ src/net/netlink/af_netlink.c	2020-05-12 11:15:17.078719042 -0400
+@@ -2788,4 +2788,9 @@ panic:
+ 	panic("netlink_init: Cannot allocate nl_table\n");
+ }
+ 
++char *kpatch_string(void)
++{
++	return "# kpatch\n";
++}
++
+ core_initcall(netlink_proto_init);
diff --git a/test/integration/rhel-8.2/multiple.test b/test/integration/rhel-8.2/multiple.test
new file mode 100755
index 0000000..7e4b352
--- /dev/null
+++ b/test/integration/rhel-8.2/multiple.test
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
+
+declare -a blacklist=(meminfo-string-LOADED.test)
+
+source ${SCRIPTDIR}/../common/multiple.template
diff --git a/test/integration/rhel-8.2/new-function.patch b/test/integration/rhel-8.2/new-function.patch
new file mode 100644
index 0000000..079065d
--- /dev/null
+++ b/test/integration/rhel-8.2/new-function.patch
@@ -0,0 +1,25 @@
+diff -Nupr src.orig/drivers/tty/n_tty.c src/drivers/tty/n_tty.c
+--- src.orig/drivers/tty/n_tty.c	2020-05-12 11:14:32.770639306 -0400
++++ src/drivers/tty/n_tty.c	2020-05-12 11:15:20.398575163 -0400
+@@ -2296,7 +2296,7 @@ static ssize_t n_tty_read(struct tty_str
+  *		  lock themselves)
+  */
+ 
+-static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
++static ssize_t noinline kpatch_n_tty_write(struct tty_struct *tty, struct file *file,
+ 			   const unsigned char *buf, size_t nr)
+ {
+ 	const unsigned char *b = buf;
+@@ -2383,6 +2383,12 @@ break_out:
+ 	return (b - buf) ? b - buf : retval;
+ }
+ 
++static ssize_t __attribute__((optimize("-fno-optimize-sibling-calls"))) n_tty_write(struct tty_struct *tty, struct file *file,
++			   							     const unsigned char *buf, size_t nr)
++{
++	return kpatch_n_tty_write(tty, file, buf, nr);
++}
++
+ /**
+  *	n_tty_poll		-	poll method for N_TTY
+  *	@tty: terminal device
diff --git a/test/integration/rhel-8.2/new-globals.patch b/test/integration/rhel-8.2/new-globals.patch
new file mode 100644
index 0000000..1f75685
--- /dev/null
+++ b/test/integration/rhel-8.2/new-globals.patch
@@ -0,0 +1,34 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/cmdline.c	2020-05-12 11:15:23.488441252 -0400
+@@ -17,3 +17,10 @@ static int __init proc_cmdline_init(void
+ 	return 0;
+ }
+ fs_initcall(proc_cmdline_init);
++
++#include <linux/printk.h>
++void kpatch_print_message(void)
++{
++	if (!jiffies)
++		printk("hello there!\n");
++}
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/meminfo.c	2020-05-12 11:15:23.488441252 -0400
+@@ -21,6 +21,8 @@
+ #include <asm/pgtable.h>
+ #include "internal.h"
+ 
++void kpatch_print_message(void);
++
+ void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
+ {
+ }
+@@ -57,6 +59,7 @@ static int meminfo_proc_show(struct seq_
+ 	sreclaimable = global_node_page_state(NR_SLAB_RECLAIMABLE);
+ 	sunreclaim = global_node_page_state(NR_SLAB_UNRECLAIMABLE);
+ 
++	kpatch_print_message();
+ 	show_val_kb(m, "MemTotal:       ", i.totalram);
+ 	show_val_kb(m, "MemFree:        ", i.freeram);
+ 	show_val_kb(m, "MemAvailable:   ", available);
diff --git a/test/integration/rhel-8.2/parainstructions-section.patch b/test/integration/rhel-8.2/parainstructions-section.patch
new file mode 100644
index 0000000..185bf97
--- /dev/null
+++ b/test/integration/rhel-8.2/parainstructions-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/generic.c src/fs/proc/generic.c
+--- src.orig/fs/proc/generic.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/generic.c	2020-05-12 11:15:26.558308207 -0400
+@@ -205,6 +205,7 @@ int proc_alloc_inum(unsigned int *inum)
+ {
+ 	int i;
+ 
++	printk("kpatch-test: testing change to .parainstructions section\n");
+ 	i = ida_simple_get(&proc_inum_ida, 0, UINT_MAX - PROC_DYNAMIC_FIRST + 1,
+ 			   GFP_KERNEL);
+ 	if (i < 0)
diff --git a/test/integration/rhel-8.2/shadow-newpid-LOADED.test.disabled b/test/integration/rhel-8.2/shadow-newpid-LOADED.test.disabled
new file mode 100755
index 0000000..c07d112
--- /dev/null
+++ b/test/integration/rhel-8.2/shadow-newpid-LOADED.test.disabled
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep -q newpid: /proc/$$/status
diff --git a/test/integration/rhel-8.2/shadow-newpid.patch.disabled b/test/integration/rhel-8.2/shadow-newpid.patch.disabled
new file mode 100644
index 0000000..18ae4c5
--- /dev/null
+++ b/test/integration/rhel-8.2/shadow-newpid.patch.disabled
@@ -0,0 +1,77 @@
+Disabled due to https:/github.com/dynup/kpatch/issues/940
+---
+diff -Nupr src.orig/fs/proc/array.c src/fs/proc/array.c
+--- src.orig/fs/proc/array.c	2020-05-12 11:14:29.250791853 -0400
++++ src/fs/proc/array.c	2020-05-12 11:15:51.127243416 -0400
+@@ -370,12 +370,19 @@ static inline void task_seccomp(struct s
+ 	seq_putc(m, '\n');
+ }
+ 
++#include <linux/livepatch.h>
+ static inline void task_context_switch_counts(struct seq_file *m,
+ 						struct task_struct *p)
+ {
++	int *newpid;
++
+ 	seq_put_decimal_ull(m, "voluntary_ctxt_switches:\t", p->nvcsw);
+ 	seq_put_decimal_ull(m, "\nnonvoluntary_ctxt_switches:\t", p->nivcsw);
+ 	seq_putc(m, '\n');
++
++	newpid = klp_shadow_get(p, 0);
++	if (newpid)
++		seq_printf(m, "newpid:\t%d\n", *newpid);
+ }
+ 
+ static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
+diff -Nupr src.orig/kernel/exit.c src/kernel/exit.c
+--- src.orig/kernel/exit.c	2020-05-12 11:14:29.670773651 -0400
++++ src/kernel/exit.c	2020-05-12 11:15:51.127243416 -0400
+@@ -762,6 +762,7 @@ static void check_stack_usage(void)
+ static inline void check_stack_usage(void) {}
+ #endif
+ 
++#include <linux/livepatch.h>
+ void __noreturn do_exit(long code)
+ {
+ 	struct task_struct *tsk = current;
+@@ -868,6 +869,8 @@ void __noreturn do_exit(long code)
+ 	exit_thread(tsk);
+ 	exit_umh(tsk);
+ 
++	klp_shadow_free(tsk, 0, NULL);
++
+ 	/*
+ 	 * Flush inherited counters to the parent - before the parent
+ 	 * gets woken up by child-exit notifications.
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2020-05-12 11:14:29.670773651 -0400
++++ src/kernel/fork.c	2020-05-12 11:15:51.127243416 -0400
+@@ -2206,6 +2206,7 @@ struct task_struct *fork_idle(int cpu)
+  * It copies the process, and if successful kick-starts
+  * it and waits for it to finish using the VM if required.
+  */
++#include <linux/livepatch.h>
+ long _do_fork(unsigned long clone_flags,
+ 	      unsigned long stack_start,
+ 	      unsigned long stack_size,
+@@ -2218,6 +2219,8 @@ long _do_fork(unsigned long clone_flags,
+ 	struct task_struct *p;
+ 	int trace = 0;
+ 	long nr;
++	int *newpid;
++	static int ctr = 0;
+ 
+ 	/*
+ 	 * Determine whether and which event to report to ptracer.  When
+@@ -2244,6 +2247,11 @@ long _do_fork(unsigned long clone_flags,
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
++	newpid = klp_shadow_get_or_alloc(p, 0, sizeof(*newpid), GFP_KERNEL,
++					 NULL, NULL);
++	if (newpid)
++		*newpid = ctr++;
++
+ 	/*
+ 	 * Do this prior waking up the new thread - the thread pointer
+ 	 * might get invalid after that point, if the thread exits quickly.
diff --git a/test/integration/rhel-8.2/smp-locks-section.patch b/test/integration/rhel-8.2/smp-locks-section.patch
new file mode 100644
index 0000000..562be3e
--- /dev/null
+++ b/test/integration/rhel-8.2/smp-locks-section.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/drivers/tty/tty_buffer.c src/drivers/tty/tty_buffer.c
+--- src.orig/drivers/tty/tty_buffer.c	2020-05-12 11:14:32.780638873 -0400
++++ src/drivers/tty/tty_buffer.c	2020-05-12 11:15:29.618175596 -0400
+@@ -256,6 +256,9 @@ static int __tty_buffer_request_room(str
+ 	struct tty_buffer *b, *n;
+ 	int left, change;
+ 
++	if (!size)
++		printk("kpatch-test: testing .smp_locks section changes\n");
++
+ 	b = buf->tail;
+ 	if (b->flags & TTYB_NORMAL)
+ 		left = 2 * b->size - b->used;
diff --git a/test/integration/rhel-8.2/special-static.patch.disabled b/test/integration/rhel-8.2/special-static.patch.disabled
new file mode 100644
index 0000000..a58cbbc
--- /dev/null
+++ b/test/integration/rhel-8.2/special-static.patch.disabled
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2020-05-12 11:14:29.670773651 -0400
++++ src/kernel/fork.c	2020-05-12 11:15:54.197110372 -0400
+@@ -1523,10 +1523,18 @@ static void posix_cpu_timers_init_group(
+ static inline void posix_cpu_timers_init_group(struct signal_struct *sig) { }
+ #endif
+ 
++void kpatch_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch copy signal\n");
++}
++
+ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
+ {
+ 	struct signal_struct *sig;
+ 
++	kpatch_foo();
++
+ 	if (clone_flags & CLONE_THREAD)
+ 		return 0;
+ 
diff --git a/test/integration/rhel-8.2/symvers-disagreement-FAIL.patch b/test/integration/rhel-8.2/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..798d21f
--- /dev/null
+++ b/test/integration/rhel-8.2/symvers-disagreement-FAIL.patch
@@ -0,0 +1,51 @@
+From 2d6b7bce089e52563bd9c67df62f48e90b48047d Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index 26bae20f0553..506ebbf0a210 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -30,6 +30,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index f74e6bda1788..86f7d453549c 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -685,6 +685,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/rhel-8.2/tracepoints-section.patch b/test/integration/rhel-8.2/tracepoints-section.patch
new file mode 100644
index 0000000..a15d065
--- /dev/null
+++ b/test/integration/rhel-8.2/tracepoints-section.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/kernel/time/timer.c src/kernel/time/timer.c
+--- src.orig/kernel/time/timer.c	2020-05-12 11:14:29.670773651 -0400
++++ src/kernel/time/timer.c	2020-05-12 11:15:32.688042552 -0400
+@@ -1696,6 +1696,9 @@ static __latent_entropy void run_timer_s
+ {
+ 	struct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);
+ 
++	if (!base)
++		printk("kpatch-test: testing __tracepoints section changes\n");
++
+ 	__run_timers(base);
+ 	if (IS_ENABLED(CONFIG_NO_HZ_COMMON))
+ 		__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));
diff --git a/test/integration/rhel-8.2/warn-detect-FAIL.patch b/test/integration/rhel-8.2/warn-detect-FAIL.patch
new file mode 100644
index 0000000..5686019
--- /dev/null
+++ b/test/integration/rhel-8.2/warn-detect-FAIL.patch
@@ -0,0 +1,8 @@
+diff -Nupr src.orig/arch/x86/kvm/x86.c src/arch/x86/kvm/x86.c
+--- src.orig/arch/x86/kvm/x86.c	2020-05-12 11:14:30.610732914 -0400
++++ src/arch/x86/kvm/x86.c	2020-05-12 11:15:35.767909073 -0400
+@@ -1,3 +1,4 @@
++
+ /*
+  * Kernel-based Virtual Machine driver for Linux
+  *
diff --git a/test/integration/rhel-8.3/bug-table-section.patch b/test/integration/rhel-8.3/bug-table-section.patch
new file mode 100644
index 0000000..cc2cca0
--- /dev/null
+++ b/test/integration/rhel-8.3/bug-table-section.patch
@@ -0,0 +1,12 @@
+diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
+--- src.orig/fs/proc/proc_sysctl.c	2020-03-17 01:12:55.155895808 -0400
++++ src/fs/proc/proc_sysctl.c	2020-03-17 01:12:59.269209033 -0400
+@@ -338,6 +338,8 @@ static void start_unregistering(struct c
+ 
+ static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)
+ {
++	if (jiffies == 0)
++		printk("kpatch-test: testing __bug_table section changes\n");
+ 	BUG_ON(!head);
+ 	spin_lock(&sysctl_lock);
+ 	if (!use_table(head))
diff --git a/test/integration/rhel-8.3/cmdline-string-LOADED.test b/test/integration/rhel-8.3/cmdline-string-LOADED.test
new file mode 100755
index 0000000..a8e0a08
--- /dev/null
+++ b/test/integration/rhel-8.3/cmdline-string-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep kpatch=1 /proc/cmdline
diff --git a/test/integration/rhel-8.3/cmdline-string.patch b/test/integration/rhel-8.3/cmdline-string.patch
new file mode 100644
index 0000000..06117f7
--- /dev/null
+++ b/test/integration/rhel-8.3/cmdline-string.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2020-03-17 01:12:55.154895731 -0400
++++ src/fs/proc/cmdline.c	2020-03-17 01:13:02.339442827 -0400
+@@ -6,8 +6,7 @@
+ 
+ static int cmdline_proc_show(struct seq_file *m, void *v)
+ {
+-	seq_puts(m, saved_command_line);
+-	seq_putc(m, '\n');
++	seq_printf(m, "%s kpatch=1\n", saved_command_line);
+ 	return 0;
+ }
+ 
diff --git a/test/integration/rhel-8.3/data-new-LOADED.test b/test/integration/rhel-8.3/data-new-LOADED.test
new file mode 100755
index 0000000..9f25744
--- /dev/null
+++ b/test/integration/rhel-8.3/data-new-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep "kpatch:         5" /proc/meminfo
diff --git a/test/integration/rhel-8.3/data-new.patch b/test/integration/rhel-8.3/data-new.patch
new file mode 100644
index 0000000..773c6c0
--- /dev/null
+++ b/test/integration/rhel-8.3/data-new.patch
@@ -0,0 +1,20 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-03-17 01:12:55.155895808 -0400
++++ src/fs/proc/meminfo.c	2020-03-17 01:13:05.297668094 -0400
+@@ -31,6 +31,8 @@ static void show_val_kb(struct seq_file
+ 	seq_write(m, " kB\n", 4);
+ }
+ 
++static int foo = 5;
++
+ static int meminfo_proc_show(struct seq_file *m, void *v)
+ {
+ 	struct sysinfo i;
+@@ -143,6 +145,7 @@ static int meminfo_proc_show(struct seq_
+ 	show_val_kb(m, "CmaFree:        ",
+ 		    global_zone_page_state(NR_FREE_CMA_PAGES));
+ #endif
++	seq_printf(m, "kpatch:         %d\n", foo);
+ 
+ 	hugetlb_report_meminfo(m);
+ 
diff --git a/test/integration/rhel-8.3/data-read-mostly.patch.disabled b/test/integration/rhel-8.3/data-read-mostly.patch.disabled
new file mode 100644
index 0000000..9ad7022
--- /dev/null
+++ b/test/integration/rhel-8.3/data-read-mostly.patch.disabled
@@ -0,0 +1,13 @@
+Disabled due to https://github.com/dynup/kpatch/issues/940
+---
+diff -Nupr src.orig/net/core/dev.c src/net/core/dev.c
+--- src.orig/net/core/dev.c	2020-03-17 01:12:55.619931143 -0400
++++ src/net/core/dev.c	2020-03-17 01:13:57.999681305 -0400
+@@ -4893,6 +4893,7 @@ skip_classify:
+ 		case RX_HANDLER_PASS:
+ 			break;
+ 		default:
++			printk("BUG!\n");
+ 			BUG();
+ 		}
+ 	}
diff --git a/test/integration/rhel-8.3/fixup-section.patch b/test/integration/rhel-8.3/fixup-section.patch
new file mode 100644
index 0000000..845d27d
--- /dev/null
+++ b/test/integration/rhel-8.3/fixup-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/readdir.c src/fs/readdir.c
+--- src.orig/fs/readdir.c	2020-03-17 01:12:55.087890628 -0400
++++ src/fs/readdir.c	2020-03-17 01:13:08.214890238 -0400
+@@ -189,6 +189,7 @@ static int filldir(struct dir_context *c
+ 			goto efault;
+ 	}
+ 	dirent = buf->current_dir;
++	asm("nop");
+ 	if (__put_user(d_ino, &dirent->d_ino))
+ 		goto efault;
+ 	if (__put_user(reclen, &dirent->d_reclen))
diff --git a/test/integration/rhel-8.3/gcc-constprop.patch b/test/integration/rhel-8.3/gcc-constprop.patch
new file mode 100644
index 0000000..1524b3f
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-constprop.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/kernel/time/timekeeping.c src/kernel/time/timekeeping.c
+--- src.orig/kernel/time/timekeeping.c	2020-03-17 01:12:55.498921929 -0400
++++ src/kernel/time/timekeeping.c	2020-03-17 01:14:00.935904896 -0400
+@@ -1221,6 +1221,9 @@ void do_gettimeofday(struct timeval *tv)
+ {
+ 	struct timespec64 now;
+ 
++	if (!tv)
++		return;
++
+ 	getnstimeofday64(&now);
+ 	tv->tv_sec = now.tv_sec;
+ 	tv->tv_usec = now.tv_nsec/1000;
diff --git a/test/integration/rhel-8.3/gcc-isra.patch b/test/integration/rhel-8.3/gcc-isra.patch
new file mode 100644
index 0000000..cabe41b
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-isra.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
+--- src.orig/fs/proc/proc_sysctl.c	2020-03-17 01:12:55.155895808 -0400
++++ src/fs/proc/proc_sysctl.c	2020-03-17 01:13:11.117111239 -0400
+@@ -53,6 +53,7 @@ void proc_sys_poll_notify(struct ctl_tab
+ 	if (!poll)
+ 		return;
+ 
++	printk("kpatch-test: testing gcc .isra function name mangling\n");
+ 	atomic_inc(&poll->event);
+ 	wake_up_interruptible(&poll->wait);
+ }
diff --git a/test/integration/rhel-8.3/gcc-mangled-3.patch b/test/integration/rhel-8.3/gcc-mangled-3.patch
new file mode 100644
index 0000000..4b53f1c
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-mangled-3.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/mm/slub.c src/mm/slub.c
+--- src.orig/mm/slub.c	2020-03-17 01:12:57.341062206 -0400
++++ src/mm/slub.c	2020-03-17 01:13:14.023332546 -0400
+@@ -5852,6 +5852,9 @@ void get_slabinfo(struct kmem_cache *s,
+ 	int node;
+ 	struct kmem_cache_node *n;
+ 
++	if (!jiffies)
++		printk("slabinfo\n");
++
+ 	for_each_kmem_cache_node(s, node, n) {
+ 		nr_slabs += node_nr_slabs(n);
+ 		nr_objs += node_nr_objs(n);
diff --git a/test/integration/rhel-8.3/gcc-static-local-var-2.patch b/test/integration/rhel-8.3/gcc-static-local-var-2.patch
new file mode 100644
index 0000000..98a883e
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-static-local-var-2.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/mm/mmap.c src/mm/mmap.c
+--- src.orig/mm/mmap.c	2020-03-17 01:12:57.337061902 -0400
++++ src/mm/mmap.c	2020-03-17 01:13:16.949555374 -0400
+@@ -1679,6 +1679,9 @@ unsigned long mmap_region(struct file *f
+ 	struct rb_node **rb_link, *rb_parent;
+ 	unsigned long charged = 0;
+ 
++	if (!jiffies)
++		printk("kpatch mmap foo\n");
++
+ 	/* Check against address space limit. */
+ 	if (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {
+ 		unsigned long nr_pages;
diff --git a/test/integration/rhel-8.3/gcc-static-local-var-3.patch b/test/integration/rhel-8.3/gcc-static-local-var-3.patch
new file mode 100644
index 0000000..aa93ab8
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-static-local-var-3.patch
@@ -0,0 +1,19 @@
+diff -Nupr src.orig/kernel/reboot.c src/kernel/reboot.c
+--- src.orig/kernel/reboot.c	2020-03-17 01:12:55.495921700 -0400
++++ src/kernel/reboot.c	2020-03-17 01:13:19.875778203 -0400
+@@ -393,8 +393,15 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
+ 	return ret;
+ }
+ 
++void kpatch_bar(void)
++{
++	if (!jiffies)
++		printk("kpatch_foo\n");
++}
++
+ static void deferred_cad(struct work_struct *dummy)
+ {
++	kpatch_bar();
+ 	kernel_restart(NULL);
+ }
+ 
diff --git a/test/integration/rhel-8.3/gcc-static-local-var-4.patch.disabled b/test/integration/rhel-8.3/gcc-static-local-var-4.patch.disabled
new file mode 100644
index 0000000..1b4f072
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-static-local-var-4.patch.disabled
@@ -0,0 +1,24 @@
+Disabled due to https://github.com/dynup/kpatch/issues/940
+---
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2020-03-17 01:12:55.092891009 -0400
++++ src/fs/aio.c	2020-03-17 01:14:03.844126354 -0400
+@@ -251,11 +251,18 @@ static int __init aio_setup(void)
+ }
+ __initcall(aio_setup);
+ 
++void kpatch_aio_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch aio foo\n");
++}
++
+ static void put_aio_ring_file(struct kioctx *ctx)
+ {
+ 	struct file *aio_ring_file = ctx->aio_ring_file;
+ 	struct address_space *i_mapping;
+ 
++	kpatch_aio_foo();
+ 	if (aio_ring_file) {
+ 		truncate_setsize(file_inode(aio_ring_file), 0);
+ 
diff --git a/test/integration/rhel-8.3/gcc-static-local-var-4.test.disabled b/test/integration/rhel-8.3/gcc-static-local-var-4.test.disabled
new file mode 100755
index 0000000..e085f93
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-static-local-var-4.test.disabled
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+set -o pipefail
+if ! $(eu-readelf --wide --symbols test-gcc-static-local-var-4.ko | awk '$NF == "free_ioctx" { exit 1 }'); then
+	exit 1
+else
+	exit 0
+fi
diff --git a/test/integration/rhel-8.3/gcc-static-local-var-5.patch b/test/integration/rhel-8.3/gcc-static-local-var-5.patch
new file mode 100644
index 0000000..23be980
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-static-local-var-5.patch
@@ -0,0 +1,45 @@
+diff -Nupr src.orig/kernel/audit.c src/kernel/audit.c
+--- src.orig/kernel/audit.c	2020-03-17 13:21:09.547745268 -0400
++++ src/kernel/audit.c	2020-03-17 13:57:21.709885683 -0400
+@@ -321,6 +321,12 @@ void audit_panic(const char *message)
+ 	}
+ }
+ 
++void kpatch_audit_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch audit foo\n");
++}
++
+ static inline int audit_rate_check(void)
+ {
+ 	static unsigned long	last_check = 0;
+@@ -331,6 +337,7 @@ static inline int audit_rate_check(void)
+ 	unsigned long		elapsed;
+ 	int			retval	   = 0;
+ 
++	kpatch_audit_foo();
+ 	if (!audit_rate_limit) return 1;
+ 
+ 	spin_lock_irqsave(&lock, flags);
+@@ -350,6 +357,11 @@ static inline int audit_rate_check(void)
+ 	return retval;
+ }
+ 
++noinline void kpatch_audit_check(void)
++{
++	audit_rate_check();
++}
++
+ /**
+  * audit_log_lost - conditionally log lost audit message event
+  * @message: the message stating reason for lost audit message
+@@ -396,6 +408,8 @@ static int audit_log_config_change(char
+ 	struct audit_buffer *ab;
+ 	int rc = 0;
+ 
++	kpatch_audit_check();
++
+ 	ab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);
+ 	if (unlikely(!ab))
+ 		return rc;
diff --git a/test/integration/rhel-8.3/gcc-static-local-var-6.patch b/test/integration/rhel-8.3/gcc-static-local-var-6.patch
new file mode 100644
index 0000000..7c418df
--- /dev/null
+++ b/test/integration/rhel-8.3/gcc-static-local-var-6.patch
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/net/ipv6/netfilter.c src/net/ipv6/netfilter.c
+--- src.orig/net/ipv6/netfilter.c	2020-10-21 11:19:40.261740227 -0400
++++ src/net/ipv6/netfilter.c	2020-10-21 11:21:09.055020262 -0400
+@@ -86,6 +86,8 @@ static int nf_ip6_reroute(struct sk_buff
+ 	return 0;
+ }
+ 
++#include "kpatch-macros.h"
++
+ int __nf_ip6_route(struct net *net, struct dst_entry **dst,
+ 		   struct flowi *fl, bool strict)
+ {
+@@ -99,6 +101,9 @@ int __nf_ip6_route(struct net *net, stru
+ 	struct dst_entry *result;
+ 	int err;
+ 
++	if (!jiffies)
++		printk("kpatch nf_ip6_route foo\n");
++
+ 	result = ip6_route_output(net, sk, &fl->u.ip6);
+ 	err = result->error;
+ 	if (err)
diff --git a/test/integration/rhel-8.3/macro-callbacks.patch b/test/integration/rhel-8.3/macro-callbacks.patch
new file mode 100644
index 0000000..ff41d17
--- /dev/null
+++ b/test/integration/rhel-8.3/macro-callbacks.patch
@@ -0,0 +1,155 @@
+diff -Nupr src.orig/drivers/input/joydev.c src/drivers/input/joydev.c
+--- src.orig/drivers/input/joydev.c	2020-03-17 01:12:57.827099217 -0400
++++ src/drivers/input/joydev.c	2020-03-17 01:13:25.725223634 -0400
+@@ -1084,3 +1084,47 @@ static void __exit joydev_exit(void)
+ 
+ module_init(joydev_init);
+ module_exit(joydev_exit);
++
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0; /* return -ENODEV; */
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/drivers/input/misc/pcspkr.c src/drivers/input/misc/pcspkr.c
+--- src.orig/drivers/input/misc/pcspkr.c	2020-03-17 01:12:57.831099522 -0400
++++ src/drivers/input/misc/pcspkr.c	2020-03-17 01:13:25.725223634 -0400
+@@ -133,3 +133,46 @@ static struct platform_driver pcspkr_pla
+ };
+ module_platform_driver(pcspkr_platform_driver);
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2020-03-17 01:12:55.092891009 -0400
++++ src/fs/aio.c	2020-03-17 01:13:25.726223710 -0400
+@@ -49,6 +49,50 @@
+ 
+ #define KIOCB_KEY		0
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
++
+ #define AIO_RING_MAGIC			0xa10a10a1
+ #define AIO_RING_COMPAT_FEATURES	1
+ #define AIO_RING_INCOMPAT_FEATURES	0
diff --git a/test/integration/rhel-8.3/macro-printk.patch b/test/integration/rhel-8.3/macro-printk.patch
new file mode 100644
index 0000000..1713578
--- /dev/null
+++ b/test/integration/rhel-8.3/macro-printk.patch
@@ -0,0 +1,148 @@
+diff -Nupr src.orig/net/ipv4/fib_frontend.c src/net/ipv4/fib_frontend.c
+--- src.orig/net/ipv4/fib_frontend.c	2020-03-17 01:12:55.534924670 -0400
++++ src/net/ipv4/fib_frontend.c	2020-03-17 01:14:06.756348118 -0400
+@@ -789,6 +789,7 @@ errout:
+ 	return err;
+ }
+ 
++#include "kpatch-macros.h"
+ static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			     struct netlink_ext_ack *extack)
+ {
+@@ -810,6 +811,7 @@ static int inet_rtm_newroute(struct sk_b
+ 	err = fib_table_insert(net, tb, &cfg, extack);
+ 	if (!err && cfg.fc_type == RTN_LOCAL)
+ 		net->ipv4.fib_has_custom_local_routes = true;
++	KPATCH_PRINTK("[inet_rtm_newroute]: err is %d\n", err);
+ errout:
+ 	return err;
+ }
+diff -Nupr src.orig/net/ipv4/fib_semantics.c src/net/ipv4/fib_semantics.c
+--- src.orig/net/ipv4/fib_semantics.c	2020-03-17 01:12:55.534924670 -0400
++++ src/net/ipv4/fib_semantics.c	2020-03-17 01:14:06.756348118 -0400
+@@ -1025,6 +1025,7 @@ fib_convert_metrics(struct fib_info *fi,
+ 				  fi->fib_metrics->metrics);
+ }
+ 
++#include "kpatch-macros.h"
+ struct fib_info *fib_create_info(struct fib_config *cfg,
+ 				 struct netlink_ext_ack *extack)
+ {
+@@ -1058,6 +1059,7 @@ struct fib_info *fib_create_info(struct
+ #endif
+ 
+ 	err = -ENOBUFS;
++	KPATCH_PRINTK("[fib_create_info]: create error err is %d\n",err);
+ 	if (fib_info_cnt >= fib_info_hash_size) {
+ 		unsigned int new_size = fib_info_hash_size << 1;
+ 		struct hlist_head *new_info_hash;
+@@ -1078,6 +1080,7 @@ struct fib_info *fib_create_info(struct
+ 		if (!fib_info_hash_size)
+ 			goto failure;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 2 create error err is %d\n",err);
+ 
+ 	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
+ 	if (!fi)
+@@ -1093,6 +1096,8 @@ struct fib_info *fib_create_info(struct
+ 		fi->fib_metrics = (struct dst_metrics *)&dst_default_metrics;
+ 	}
+ 	fib_info_cnt++;
++	KPATCH_PRINTK("[fib_create_info]: 3 create error err is %d\n",err);
++
+ 	fi->fib_net = net;
+ 	fi->fib_protocol = cfg->fc_protocol;
+ 	fi->fib_scope = cfg->fc_scope;
+@@ -1109,8 +1114,10 @@ struct fib_info *fib_create_info(struct
+ 		if (!nexthop_nh->nh_pcpu_rth_output)
+ 			goto failure;
+ 	} endfor_nexthops(fi)
++	KPATCH_PRINTK("[fib_create_info]: 4 create error err is %d\n",err);
+ 
+ 	err = fib_convert_metrics(fi, cfg);
++	KPATCH_PRINTK("[fib_create_info]: 5 create error err is %d\n",err);
+ 	if (err)
+ 		goto failure;
+ 
+@@ -1172,6 +1179,7 @@ struct fib_info *fib_create_info(struct
+ 		nh->nh_weight = 1;
+ #endif
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 6 create error err is %d\n",err);
+ 
+ 	if (fib_props[cfg->fc_type].error) {
+ 		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp) {
+@@ -1193,6 +1201,7 @@ struct fib_info *fib_create_info(struct
+ 			goto err_inval;
+ 		}
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 7 create error err is %d\n",err);
+ 
+ 	if (cfg->fc_scope > RT_SCOPE_HOST) {
+ 		NL_SET_ERR_MSG(extack, "Invalid scope");
+@@ -1231,6 +1240,7 @@ struct fib_info *fib_create_info(struct
+ 		if (linkdown == fi->fib_nhs)
+ 			fi->fib_flags |= RTNH_F_LINKDOWN;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 8 create error err is %d\n",err);
+ 
+ 	if (fi->fib_prefsrc && !fib_valid_prefsrc(cfg, fi->fib_prefsrc)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid prefsrc address");
+@@ -1240,6 +1250,7 @@ struct fib_info *fib_create_info(struct
+ 	change_nexthops(fi) {
+ 		fib_info_update_nh_saddr(net, nexthop_nh);
+ 	} endfor_nexthops(fi)
++	KPATCH_PRINTK("[fib_create_info]: 9 create error err is %d\n",err);
+ 
+ 	fib_rebalance(fi);
+ 
+@@ -1251,6 +1262,7 @@ link_it:
+ 		ofi->fib_treeref++;
+ 		return ofi;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 10 create error err is %d\n",err);
+ 
+ 	fi->fib_treeref++;
+ 	refcount_set(&fi->fib_clntref, 1);
+@@ -1274,6 +1286,7 @@ link_it:
+ 		hlist_add_head(&nexthop_nh->nh_hash, head);
+ 	} endfor_nexthops(fi)
+ 	spin_unlock_bh(&fib_info_lock);
++	KPATCH_PRINTK("[fib_create_info]: 11 create error err is %d\n",err);
+ 	return fi;
+ 
+ err_inval:
+@@ -1284,6 +1297,7 @@ failure:
+ 		fi->fib_dead = 1;
+ 		free_fib_info(fi);
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 12 create error err is %d\n",err);
+ 
+ 	return ERR_PTR(err);
+ }
+diff -Nupr src.orig/net/ipv4/fib_trie.c src/net/ipv4/fib_trie.c
+--- src.orig/net/ipv4/fib_trie.c	2020-03-17 01:12:55.541925203 -0400
++++ src/net/ipv4/fib_trie.c	2020-03-17 01:14:06.756348118 -0400
+@@ -1121,6 +1121,7 @@ static bool fib_valid_key_len(u32 key, u
+ }
+ 
+ /* Caller must hold RTNL. */
++#include "kpatch-macros.h"
+ int fib_table_insert(struct net *net, struct fib_table *tb,
+ 		     struct fib_config *cfg, struct netlink_ext_ack *extack)
+ {
+@@ -1143,11 +1144,14 @@ int fib_table_insert(struct net *net, st
+ 
+ 	pr_debug("Insert table=%u %08x/%d\n", tb->tb_id, key, plen);
+ 
++	KPATCH_PRINTK("[fib_table_insert]: start\n");
+ 	fi = fib_create_info(cfg, extack);
+ 	if (IS_ERR(fi)) {
+ 		err = PTR_ERR(fi);
++		KPATCH_PRINTK("[fib_table_insert]: create error err is %d\n",err);
+ 		goto err;
+ 	}
++	KPATCH_PRINTK("[fib_table_insert]: cross\n");
+ 
+ 	l = fib_find_node(t, &tp, key);
+ 	fa = l ? fib_find_alias(&l->leaf, slen, tos, fi->fib_priority,
diff --git a/test/integration/rhel-8.3/meminfo-init-FAIL.patch b/test/integration/rhel-8.3/meminfo-init-FAIL.patch
new file mode 100644
index 0000000..8f4bf4a
--- /dev/null
+++ b/test/integration/rhel-8.3/meminfo-init-FAIL.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-03-17 01:12:55.155895808 -0400
++++ src/fs/proc/meminfo.c	2020-03-17 01:13:31.599670967 -0400
+@@ -153,6 +153,7 @@ static int meminfo_proc_show(struct seq_
+ 
+ static int __init proc_meminfo_init(void)
+ {
++	printk("a\n");
+ 	proc_create_single("meminfo", 0, NULL, meminfo_proc_show);
+ 	return 0;
+ }
diff --git a/test/integration/rhel-8.3/meminfo-init2-FAIL.patch b/test/integration/rhel-8.3/meminfo-init2-FAIL.patch
new file mode 100644
index 0000000..8cc8748
--- /dev/null
+++ b/test/integration/rhel-8.3/meminfo-init2-FAIL.patch
@@ -0,0 +1,19 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-03-17 01:12:55.155895808 -0400
++++ src/fs/proc/meminfo.c	2020-03-17 01:13:28.655446767 -0400
+@@ -41,6 +41,7 @@ static int meminfo_proc_show(struct seq_
+ 	unsigned long sreclaimable, sunreclaim;
+ 	int lru;
+ 
++	printk("a\n");
+ 	si_meminfo(&i);
+ 	si_swapinfo(&i);
+ 	committed = percpu_counter_read_positive(&vm_committed_as);
+@@ -153,6 +154,7 @@ static int meminfo_proc_show(struct seq_
+ 
+ static int __init proc_meminfo_init(void)
+ {
++	printk("a\n");
+ 	proc_create_single("meminfo", 0, NULL, meminfo_proc_show);
+ 	return 0;
+ }
diff --git a/test/integration/rhel-8.3/meminfo-string-LOADED.test b/test/integration/rhel-8.3/meminfo-string-LOADED.test
new file mode 100755
index 0000000..10dc20b
--- /dev/null
+++ b/test/integration/rhel-8.3/meminfo-string-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep VMALLOCCHUNK /proc/meminfo
diff --git a/test/integration/rhel-8.3/meminfo-string.patch b/test/integration/rhel-8.3/meminfo-string.patch
new file mode 100644
index 0000000..79c22de
--- /dev/null
+++ b/test/integration/rhel-8.3/meminfo-string.patch
@@ -0,0 +1,12 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-03-17 13:21:08.363654606 -0400
++++ src/fs/proc/meminfo.c	2020-03-17 13:22:47.153218616 -0400
+@@ -121,7 +121,7 @@ static int meminfo_proc_show(struct seq_
+ 	seq_printf(m, "VmallocTotal:   %8lu kB\n",
+ 		   (unsigned long)VMALLOC_TOTAL >> 10);
+ 	show_val_kb(m, "VmallocUsed:    ", 0ul);
+-	show_val_kb(m, "VmallocChunk:   ", 0ul);
++	show_val_kb(m, "VMALLOCCHUNK:   ", 0ul);
+ 	show_val_kb(m, "Percpu:         ", pcpu_nr_pages());
+ 
+ #ifdef CONFIG_MEMORY_FAILURE
diff --git a/test/integration/rhel-8.3/module-LOADED.test b/test/integration/rhel-8.3/module-LOADED.test
new file mode 100755
index 0000000..72bb852
--- /dev/null
+++ b/test/integration/rhel-8.3/module-LOADED.test
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+set -o errexit
+
+sudo modprobe nfsd
+sleep 5
+grep -q kpatch /proc/fs/nfs/exports
+
+# TODO: This will trigger a printk on newer kernels which have the .klp.arch
+# removal.  Don't actually do the grep until running on a newer kernel.
+echo "file fs/nfsd/export.c +p" > /sys/kernel/debug/dynamic_debug/control
+cat /proc/fs/nfs/exports > /dev/null
+# dmesg | grep -q "kpatch: pr_debug"
diff --git a/test/integration/rhel-8.3/module.patch b/test/integration/rhel-8.3/module.patch
new file mode 100644
index 0000000..5dcee19
--- /dev/null
+++ b/test/integration/rhel-8.3/module.patch
@@ -0,0 +1,85 @@
+From 08078d00ab1749a6f84148a00d8d26572af4ec97 Mon Sep 17 00:00:00 2001
+Message-Id: <08078d00ab1749a6f84148a00d8d26572af4ec97.1586900628.git.jpoimboe@redhat.com>
+From: Josh Poimboeuf <jpoimboe@redhat.com>
+Date: Tue, 14 Apr 2020 15:17:51 -0500
+Subject: [PATCH] kpatch module integration test
+
+This tests several things related to the patching of modules:
+
+- 'kpatch_string' tests the referencing of a symbol which is outside the
+  .o, but inside the patch module.
+
+- alternatives patching (.altinstructions)
+
+- paravirt patching (.parainstructions)
+
+- jump labels (5.8+ kernels only) -- including dynamic printk
+
+Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
+---
+ fs/nfsd/export.c         | 30 ++++++++++++++++++++++++++++++
+ net/netlink/af_netlink.c |  5 +++++
+ 2 files changed, 35 insertions(+)
+
+diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
+--- src.orig/fs/nfsd/export.c	2020-05-12 11:14:29.230792719 -0400
++++ src/fs/nfsd/export.c	2020-05-12 11:15:17.078719042 -0400
+@@ -1196,15 +1196,45 @@ static void exp_flags(struct seq_file *m
+ 	}
+ }
+ 
++#include <linux/version.h>
++extern char *kpatch_string(void);
++
+ static int e_show(struct seq_file *m, void *p)
+ {
+ 	struct cache_head *cp = p;
+ 	struct svc_export *exp = container_of(cp, struct svc_export, h);
+ 	struct cache_detail *cd = m->private;
++#ifdef CONFIG_X86_64
++	unsigned long long sched_clock;
++
++	alternative("ud2", "call yield", X86_FEATURE_ALWAYS);
++	alternative("call yield", "ud2", X86_FEATURE_IA64);
++
++	sched_clock = paravirt_sched_clock();
++	if (!jiffies)
++		printk("kpatch: sched_clock: %llu\n", sched_clock);
++#endif
++
++	pr_debug("kpatch: pr_debug() test\n");
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
++{
++	static DEFINE_STATIC_KEY_TRUE(kpatch_key);
++
++	if (static_branch_unlikely(&mcsafe_key))
++		printk("kpatch: mcsafe_key\n");
++
++	BUG_ON(!static_branch_likely(&kpatch_key));
++	static_branch_disable(&kpatch_key);
++	BUG_ON(static_branch_likely(&kpatch_key));
++	static_branch_enable(&kpatch_key);
++}
++#endif
+ 
+ 	if (p == SEQ_START_TOKEN) {
+ 		seq_puts(m, "# Version 1.1\n");
+ 		seq_puts(m, "# Path Client(Flags) # IPs\n");
++		seq_puts(m, kpatch_string());
+ 		return 0;
+ 	}
+ 
+diff -Nupr src.orig/net/netlink/af_netlink.c src/net/netlink/af_netlink.c
+--- src.orig/net/netlink/af_netlink.c	2020-05-12 11:14:29.780768884 -0400
++++ src/net/netlink/af_netlink.c	2020-05-12 11:15:17.078719042 -0400
+@@ -2788,4 +2788,9 @@ panic:
+ 	panic("netlink_init: Cannot allocate nl_table\n");
+ }
+ 
++char *kpatch_string(void)
++{
++	return "# kpatch\n";
++}
++
+ core_initcall(netlink_proto_init);
diff --git a/test/integration/rhel-8.3/multiple.test b/test/integration/rhel-8.3/multiple.test
new file mode 100755
index 0000000..7e4b352
--- /dev/null
+++ b/test/integration/rhel-8.3/multiple.test
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
+
+declare -a blacklist=(meminfo-string-LOADED.test)
+
+source ${SCRIPTDIR}/../common/multiple.template
diff --git a/test/integration/rhel-8.3/new-function.patch b/test/integration/rhel-8.3/new-function.patch
new file mode 100644
index 0000000..dab2c63
--- /dev/null
+++ b/test/integration/rhel-8.3/new-function.patch
@@ -0,0 +1,25 @@
+diff -Nupr src.orig/drivers/tty/n_tty.c src/drivers/tty/n_tty.c
+--- src.orig/drivers/tty/n_tty.c	2020-03-17 01:12:58.001112468 -0400
++++ src/drivers/tty/n_tty.c	2020-03-17 01:13:37.546123784 -0400
+@@ -2296,7 +2296,7 @@ static ssize_t n_tty_read(struct tty_str
+  *		  lock themselves)
+  */
+ 
+-static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
++static ssize_t noinline kpatch_n_tty_write(struct tty_struct *tty, struct file *file,
+ 			   const unsigned char *buf, size_t nr)
+ {
+ 	const unsigned char *b = buf;
+@@ -2383,6 +2383,12 @@ break_out:
+ 	return (b - buf) ? b - buf : retval;
+ }
+ 
++static ssize_t __attribute__((optimize("-fno-optimize-sibling-calls"))) n_tty_write(struct tty_struct *tty, struct file *file,
++			   							     const unsigned char *buf, size_t nr)
++{
++	return kpatch_n_tty_write(tty, file, buf, nr);
++}
++
+ /**
+  *	n_tty_poll		-	poll method for N_TTY
+  *	@tty: terminal device
diff --git a/test/integration/rhel-8.3/new-globals.patch b/test/integration/rhel-8.3/new-globals.patch
new file mode 100644
index 0000000..085d8be
--- /dev/null
+++ b/test/integration/rhel-8.3/new-globals.patch
@@ -0,0 +1,34 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2020-03-17 01:12:55.154895731 -0400
++++ src/fs/proc/cmdline.c	2020-03-17 01:13:40.492348137 -0400
+@@ -17,3 +17,10 @@ static int __init proc_cmdline_init(void
+ 	return 0;
+ }
+ fs_initcall(proc_cmdline_init);
++
++#include <linux/printk.h>
++void kpatch_print_message(void)
++{
++	if (!jiffies)
++		printk("hello there!\n");
++}
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2020-03-17 01:12:55.155895808 -0400
++++ src/fs/proc/meminfo.c	2020-03-17 01:13:40.492348137 -0400
+@@ -21,6 +21,8 @@
+ #include <asm/pgtable.h>
+ #include "internal.h"
+ 
++void kpatch_print_message(void);
++
+ void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
+ {
+ }
+@@ -57,6 +59,7 @@ static int meminfo_proc_show(struct seq_
+ 	sreclaimable = global_node_page_state(NR_SLAB_RECLAIMABLE);
+ 	sunreclaim = global_node_page_state(NR_SLAB_UNRECLAIMABLE);
+ 
++	kpatch_print_message();
+ 	show_val_kb(m, "MemTotal:       ", i.totalram);
+ 	show_val_kb(m, "MemFree:        ", i.freeram);
+ 	show_val_kb(m, "MemAvailable:   ", available);
diff --git a/test/integration/rhel-8.3/parainstructions-section.patch b/test/integration/rhel-8.3/parainstructions-section.patch
new file mode 100644
index 0000000..5f03a97
--- /dev/null
+++ b/test/integration/rhel-8.3/parainstructions-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/generic.c src/fs/proc/generic.c
+--- src.orig/fs/proc/generic.c	2020-03-17 01:12:55.154895731 -0400
++++ src/fs/proc/generic.c	2020-03-17 01:13:43.430571880 -0400
+@@ -205,6 +205,7 @@ int proc_alloc_inum(unsigned int *inum)
+ {
+ 	int i;
+ 
++	printk("kpatch-test: testing change to .parainstructions section\n");
+ 	i = ida_simple_get(&proc_inum_ida, 0, UINT_MAX - PROC_DYNAMIC_FIRST + 1,
+ 			   GFP_KERNEL);
+ 	if (i < 0)
diff --git a/test/integration/rhel-8.3/shadow-newpid-LOADED.test.disabled b/test/integration/rhel-8.3/shadow-newpid-LOADED.test.disabled
new file mode 100755
index 0000000..c07d112
--- /dev/null
+++ b/test/integration/rhel-8.3/shadow-newpid-LOADED.test.disabled
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep -q newpid: /proc/$$/status
diff --git a/test/integration/rhel-8.3/shadow-newpid.patch.disabled b/test/integration/rhel-8.3/shadow-newpid.patch.disabled
new file mode 100644
index 0000000..d737bfb
--- /dev/null
+++ b/test/integration/rhel-8.3/shadow-newpid.patch.disabled
@@ -0,0 +1,77 @@
+Disabled due to https://github.com/dynup/kpatch/issues/940
+---
+diff -Nupr src.orig/fs/proc/array.c src/fs/proc/array.c
+--- src.orig/fs/proc/array.c	2020-03-17 01:12:55.154895731 -0400
++++ src/fs/proc/array.c	2020-03-17 01:14:09.668569881 -0400
+@@ -370,12 +370,19 @@ static inline void task_seccomp(struct s
+ 	seq_putc(m, '\n');
+ }
+ 
++#include <linux/livepatch.h>
+ static inline void task_context_switch_counts(struct seq_file *m,
+ 						struct task_struct *p)
+ {
++	int *newpid;
++
+ 	seq_put_decimal_ull(m, "voluntary_ctxt_switches:\t", p->nvcsw);
+ 	seq_put_decimal_ull(m, "\nnonvoluntary_ctxt_switches:\t", p->nivcsw);
+ 	seq_putc(m, '\n');
++
++	newpid = klp_shadow_get(p, 0);
++	if (newpid)
++		seq_printf(m, "newpid:\t%d\n", *newpid);
+ }
+ 
+ static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
+diff -Nupr src.orig/kernel/exit.c src/kernel/exit.c
+--- src.orig/kernel/exit.c	2020-03-17 01:12:55.490921320 -0400
++++ src/kernel/exit.c	2020-03-17 01:14:09.668569881 -0400
+@@ -762,6 +762,7 @@ static void check_stack_usage(void)
+ static inline void check_stack_usage(void) {}
+ #endif
+ 
++#include <linux/livepatch.h>
+ void __noreturn do_exit(long code)
+ {
+ 	struct task_struct *tsk = current;
+@@ -868,6 +869,8 @@ void __noreturn do_exit(long code)
+ 	exit_thread(tsk);
+ 	exit_umh(tsk);
+ 
++	klp_shadow_free(tsk, 0, NULL);
++
+ 	/*
+ 	 * Flush inherited counters to the parent - before the parent
+ 	 * gets woken up by child-exit notifications.
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2020-03-17 01:12:55.500922081 -0400
++++ src/kernel/fork.c	2020-03-17 01:14:09.668569881 -0400
+@@ -2206,6 +2206,7 @@ struct task_struct *fork_idle(int cpu)
+  * It copies the process, and if successful kick-starts
+  * it and waits for it to finish using the VM if required.
+  */
++#include <linux/livepatch.h>
+ long _do_fork(unsigned long clone_flags,
+ 	      unsigned long stack_start,
+ 	      unsigned long stack_size,
+@@ -2218,6 +2219,8 @@ long _do_fork(unsigned long clone_flags,
+ 	struct task_struct *p;
+ 	int trace = 0;
+ 	long nr;
++	int *newpid;
++	static int ctr = 0;
+ 
+ 	/*
+ 	 * Determine whether and which event to report to ptracer.  When
+@@ -2244,6 +2247,11 @@ long _do_fork(unsigned long clone_flags,
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
++	newpid = klp_shadow_get_or_alloc(p, 0, sizeof(*newpid), GFP_KERNEL,
++					 NULL, NULL);
++	if (newpid)
++		*newpid = ctr++;
++
+ 	/*
+ 	 * Do this prior waking up the new thread - the thread pointer
+ 	 * might get invalid after that point, if the thread exits quickly.
diff --git a/test/integration/rhel-8.3/smp-locks-section.patch b/test/integration/rhel-8.3/smp-locks-section.patch
new file mode 100644
index 0000000..664ec7e
--- /dev/null
+++ b/test/integration/rhel-8.3/smp-locks-section.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/drivers/tty/tty_buffer.c src/drivers/tty/tty_buffer.c
+--- src.orig/drivers/tty/tty_buffer.c	2020-03-17 01:12:58.012113306 -0400
++++ src/drivers/tty/tty_buffer.c	2020-03-17 01:13:46.342793643 -0400
+@@ -256,6 +256,9 @@ static int __tty_buffer_request_room(str
+ 	struct tty_buffer *b, *n;
+ 	int left, change;
+ 
++	if (!size)
++		printk("kpatch-test: testing .smp_locks section changes\n");
++
+ 	b = buf->tail;
+ 	if (b->flags & TTYB_NORMAL)
+ 		left = 2 * b->size - b->used;
diff --git a/test/integration/rhel-8.3/special-static.patch.disabled b/test/integration/rhel-8.3/special-static.patch.disabled
new file mode 100644
index 0000000..695f0a1
--- /dev/null
+++ b/test/integration/rhel-8.3/special-static.patch.disabled
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2020-03-17 01:12:55.500922081 -0400
++++ src/kernel/fork.c	2020-03-17 01:13:49.230013502 -0400
+@@ -1523,10 +1523,18 @@ static void posix_cpu_timers_init_group(
+ static inline void posix_cpu_timers_init_group(struct signal_struct *sig) { }
+ #endif
+ 
++void kpatch_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch copy signal\n");
++}
++
+ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
+ {
+ 	struct signal_struct *sig;
+ 
++	kpatch_foo();
++
+ 	if (clone_flags & CLONE_THREAD)
+ 		return 0;
+ 
diff --git a/test/integration/rhel-8.3/symvers-disagreement-FAIL.patch b/test/integration/rhel-8.3/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..798d21f
--- /dev/null
+++ b/test/integration/rhel-8.3/symvers-disagreement-FAIL.patch
@@ -0,0 +1,51 @@
+From 2d6b7bce089e52563bd9c67df62f48e90b48047d Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/base/core.c b/drivers/base/core.c
+index 26bae20f0553..506ebbf0a210 100644
+--- a/drivers/base/core.c
++++ b/drivers/base/core.c
+@@ -30,6 +30,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
+index f74e6bda1788..86f7d453549c 100644
+--- a/drivers/usb/core/usb.c
++++ b/drivers/usb/core/usb.c
+@@ -685,6 +685,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
+-- 
+2.21.3
+
diff --git a/test/integration/rhel-8.3/tracepoints-section.patch b/test/integration/rhel-8.3/tracepoints-section.patch
new file mode 100644
index 0000000..8b77551
--- /dev/null
+++ b/test/integration/rhel-8.3/tracepoints-section.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/kernel/time/timer.c src/kernel/time/timer.c
+--- src.orig/kernel/time/timer.c	2020-03-17 01:12:55.499922005 -0400
++++ src/kernel/time/timer.c	2020-03-17 01:13:52.157236408 -0400
+@@ -1696,6 +1696,9 @@ static __latent_entropy void run_timer_s
+ {
+ 	struct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);
+ 
++	if (!base)
++		printk("kpatch-test: testing __tracepoints section changes\n");
++
+ 	__run_timers(base);
+ 	if (IS_ENABLED(CONFIG_NO_HZ_COMMON))
+ 		__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));
diff --git a/test/integration/rhel-8.3/warn-detect-FAIL.patch b/test/integration/rhel-8.3/warn-detect-FAIL.patch
new file mode 100644
index 0000000..e9518a9
--- /dev/null
+++ b/test/integration/rhel-8.3/warn-detect-FAIL.patch
@@ -0,0 +1,8 @@
+diff -Nupr src.orig/arch/x86/kvm/x86.c src/arch/x86/kvm/x86.c
+--- src.orig/arch/x86/kvm/x86.c	2020-03-17 01:12:56.596005471 -0400
++++ src/arch/x86/kvm/x86.c	2020-03-17 01:13:55.095460151 -0400
+@@ -1,3 +1,4 @@
++
+ /*
+  * Kernel-based Virtual Machine driver for Linux
+  *
diff --git a/test/integration/rhel-8.4/bug-table-section.patch b/test/integration/rhel-8.4/bug-table-section.patch
new file mode 100644
index 0000000..f1e2af8
--- /dev/null
+++ b/test/integration/rhel-8.4/bug-table-section.patch
@@ -0,0 +1,12 @@
+diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
+--- src.orig/fs/proc/proc_sysctl.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/proc_sysctl.c	2021-04-20 11:04:27.636102900 -0400
+@@ -338,6 +338,8 @@ static void start_unregistering(struct c
+ 
+ static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)
+ {
++	if (jiffies == 0)
++		printk("kpatch-test: testing __bug_table section changes\n");
+ 	BUG_ON(!head);
+ 	spin_lock(&sysctl_lock);
+ 	if (!use_table(head))
diff --git a/test/integration/rhel-8.4/cmdline-string-LOADED.test b/test/integration/rhel-8.4/cmdline-string-LOADED.test
new file mode 100755
index 0000000..a8e0a08
--- /dev/null
+++ b/test/integration/rhel-8.4/cmdline-string-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep kpatch=1 /proc/cmdline
diff --git a/test/integration/rhel-8.4/cmdline-string.patch b/test/integration/rhel-8.4/cmdline-string.patch
new file mode 100644
index 0000000..0f01b59
--- /dev/null
+++ b/test/integration/rhel-8.4/cmdline-string.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/cmdline.c	2021-04-20 11:04:30.118109128 -0400
+@@ -6,8 +6,7 @@
+ 
+ static int cmdline_proc_show(struct seq_file *m, void *v)
+ {
+-	seq_puts(m, saved_command_line);
+-	seq_putc(m, '\n');
++	seq_printf(m, "%s kpatch=1\n", saved_command_line);
+ 	return 0;
+ }
+ 
diff --git a/test/integration/rhel-8.4/data-new-LOADED.test b/test/integration/rhel-8.4/data-new-LOADED.test
new file mode 100755
index 0000000..9f25744
--- /dev/null
+++ b/test/integration/rhel-8.4/data-new-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep "kpatch:         5" /proc/meminfo
diff --git a/test/integration/rhel-8.4/data-new.patch b/test/integration/rhel-8.4/data-new.patch
new file mode 100644
index 0000000..23e1bdd
--- /dev/null
+++ b/test/integration/rhel-8.4/data-new.patch
@@ -0,0 +1,20 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/meminfo.c	2021-04-20 11:04:32.584115315 -0400
+@@ -31,6 +31,8 @@ static void show_val_kb(struct seq_file
+ 	seq_write(m, " kB\n", 4);
+ }
+ 
++static int foo = 5;
++
+ static int meminfo_proc_show(struct seq_file *m, void *v)
+ {
+ 	struct sysinfo i;
+@@ -146,6 +148,7 @@ static int meminfo_proc_show(struct seq_
+ 	show_val_kb(m, "CmaFree:        ",
+ 		    global_zone_page_state(NR_FREE_CMA_PAGES));
+ #endif
++	seq_printf(m, "kpatch:         %d\n", foo);
+ 
+ 	hugetlb_report_meminfo(m);
+ 
diff --git a/test/integration/rhel-8.4/data-read-mostly.patch b/test/integration/rhel-8.4/data-read-mostly.patch
new file mode 100644
index 0000000..482d997
--- /dev/null
+++ b/test/integration/rhel-8.4/data-read-mostly.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/net/core/dev.c src/net/core/dev.c
+--- src.orig/net/core/dev.c	2021-04-20 11:04:27.355102195 -0400
++++ src/net/core/dev.c	2021-04-20 11:04:34.800120875 -0400
+@@ -5058,6 +5058,7 @@ skip_classify:
+ 		case RX_HANDLER_PASS:
+ 			break;
+ 		default:
++			printk("BUG!\n");
+ 			BUG();
+ 		}
+ 	}
diff --git a/test/integration/rhel-8.4/fixup-section.patch b/test/integration/rhel-8.4/fixup-section.patch
new file mode 100644
index 0000000..6321af8
--- /dev/null
+++ b/test/integration/rhel-8.4/fixup-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/readdir.c src/fs/readdir.c
+--- src.orig/fs/readdir.c	2021-04-20 11:04:26.675100489 -0400
++++ src/fs/readdir.c	2021-04-20 11:04:36.984126354 -0400
+@@ -189,6 +189,7 @@ static int filldir(struct dir_context *c
+ 			goto efault;
+ 	}
+ 	dirent = buf->current_dir;
++	asm("nop");
+ 	if (__put_user(d_ino, &dirent->d_ino))
+ 		goto efault;
+ 	if (__put_user(reclen, &dirent->d_reclen))
diff --git a/test/integration/rhel-8.4/gcc-constprop.patch b/test/integration/rhel-8.4/gcc-constprop.patch
new file mode 100644
index 0000000..dd62372
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-constprop.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/kernel/time/timekeeping.c src/kernel/time/timekeeping.c
+--- src.orig/kernel/time/timekeeping.c	2021-04-20 11:04:27.325102120 -0400
++++ src/kernel/time/timekeeping.c	2021-04-20 11:04:39.253132047 -0400
+@@ -1231,6 +1231,9 @@ void do_gettimeofday(struct timeval *tv)
+ {
+ 	struct timespec64 now;
+ 
++	if (!tv)
++		return;
++
+ 	getnstimeofday64(&now);
+ 	tv->tv_sec = now.tv_sec;
+ 	tv->tv_usec = now.tv_nsec/1000;
diff --git a/test/integration/rhel-8.4/gcc-isra.patch b/test/integration/rhel-8.4/gcc-isra.patch
new file mode 100644
index 0000000..51fd423
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-isra.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/proc_sysctl.c src/fs/proc/proc_sysctl.c
+--- src.orig/fs/proc/proc_sysctl.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/proc_sysctl.c	2021-04-20 11:04:41.824138498 -0400
+@@ -53,6 +53,7 @@ void proc_sys_poll_notify(struct ctl_tab
+ 	if (!poll)
+ 		return;
+ 
++	printk("kpatch-test: testing gcc .isra function name mangling\n");
+ 	atomic_inc(&poll->event);
+ 	wake_up_interruptible(&poll->wait);
+ }
diff --git a/test/integration/rhel-8.4/gcc-mangled-3.patch b/test/integration/rhel-8.4/gcc-mangled-3.patch
new file mode 100644
index 0000000..699eb1a
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-mangled-3.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/mm/slub.c src/mm/slub.c
+--- src.orig/mm/slub.c	2021-04-20 11:04:27.343102165 -0400
++++ src/mm/slub.c	2021-04-20 11:04:44.205144472 -0400
+@@ -5749,6 +5749,9 @@ void get_slabinfo(struct kmem_cache *s,
+ 	int node;
+ 	struct kmem_cache_node *n;
+ 
++	if (!jiffies)
++		printk("slabinfo\n");
++
+ 	for_each_kmem_cache_node(s, node, n) {
+ 		nr_slabs += node_nr_slabs(n);
+ 		nr_objs += node_nr_objs(n);
diff --git a/test/integration/rhel-8.4/gcc-static-local-var-2.patch b/test/integration/rhel-8.4/gcc-static-local-var-2.patch
new file mode 100644
index 0000000..f847008
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-static-local-var-2.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/mm/mmap.c src/mm/mmap.c
+--- src.orig/mm/mmap.c	2021-04-20 11:04:27.341102160 -0400
++++ src/mm/mmap.c	2021-04-20 11:04:46.880151184 -0400
+@@ -1690,6 +1690,9 @@ unsigned long mmap_region(struct file *f
+ 	struct rb_node **rb_link, *rb_parent;
+ 	unsigned long charged = 0;
+ 
++	if (!jiffies)
++		printk("kpatch mmap foo\n");
++
+ 	/* Check against address space limit. */
+ 	if (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {
+ 		unsigned long nr_pages;
diff --git a/test/integration/rhel-8.4/gcc-static-local-var-3.patch b/test/integration/rhel-8.4/gcc-static-local-var-3.patch
new file mode 100644
index 0000000..8b9ec4f
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-static-local-var-3.patch
@@ -0,0 +1,19 @@
+diff -Nupr src.orig/kernel/reboot.c src/kernel/reboot.c
+--- src.orig/kernel/reboot.c	2021-04-20 11:04:27.316102097 -0400
++++ src/kernel/reboot.c	2021-04-20 11:04:49.155156892 -0400
+@@ -393,8 +393,15 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
+ 	return ret;
+ }
+ 
++void kpatch_bar(void)
++{
++	if (!jiffies)
++		printk("kpatch_foo\n");
++}
++
+ static void deferred_cad(struct work_struct *dummy)
+ {
++	kpatch_bar();
+ 	kernel_restart(NULL);
+ }
+ 
diff --git a/test/integration/rhel-8.4/gcc-static-local-var-4.patch b/test/integration/rhel-8.4/gcc-static-local-var-4.patch
new file mode 100644
index 0000000..cdef516
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-static-local-var-4.patch
@@ -0,0 +1,23 @@
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2021-04-20 11:04:26.671100479 -0400
++++ src/fs/aio.c	2021-04-20 11:04:51.420162575 -0400
+@@ -248,11 +248,18 @@ static int __init aio_setup(void)
+ }
+ __initcall(aio_setup);
+ 
+-static void put_aio_ring_file(struct kioctx *ctx)
++void kpatch_aio_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch aio foo\n");
++}
++
++__always_inline static void put_aio_ring_file(struct kioctx *ctx)
+ {
+ 	struct file *aio_ring_file = ctx->aio_ring_file;
+ 	struct address_space *i_mapping;
+ 
++	kpatch_aio_foo();
+ 	if (aio_ring_file) {
+ 		truncate_setsize(file_inode(aio_ring_file), 0);
+ 
diff --git a/test/integration/rhel-8.4/gcc-static-local-var-4.test b/test/integration/rhel-8.4/gcc-static-local-var-4.test
new file mode 100755
index 0000000..e085f93
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-static-local-var-4.test
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+set -o pipefail
+if ! $(eu-readelf --wide --symbols test-gcc-static-local-var-4.ko | awk '$NF == "free_ioctx" { exit 1 }'); then
+	exit 1
+else
+	exit 0
+fi
diff --git a/test/integration/rhel-8.4/gcc-static-local-var-5.patch b/test/integration/rhel-8.4/gcc-static-local-var-5.patch
new file mode 100644
index 0000000..1ba0205
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-static-local-var-5.patch
@@ -0,0 +1,45 @@
+diff -Nupr src.orig/kernel/audit.c src/kernel/audit.c
+--- src.orig/kernel/audit.c	2021-04-20 11:04:27.312102087 -0400
++++ src/kernel/audit.c	2021-04-20 11:04:53.691168273 -0400
+@@ -327,6 +327,12 @@ void audit_panic(const char *message)
+ 	}
+ }
+ 
++void kpatch_audit_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch audit foo\n");
++}
++
+ static inline int audit_rate_check(void)
+ {
+ 	static unsigned long	last_check = 0;
+@@ -337,6 +343,7 @@ static inline int audit_rate_check(void)
+ 	unsigned long		elapsed;
+ 	int			retval	   = 0;
+ 
++	kpatch_audit_foo();
+ 	if (!audit_rate_limit) return 1;
+ 
+ 	spin_lock_irqsave(&lock, flags);
+@@ -356,6 +363,11 @@ static inline int audit_rate_check(void)
+ 	return retval;
+ }
+ 
++noinline void kpatch_audit_check(void)
++{
++	audit_rate_check();
++}
++
+ /**
+  * audit_log_lost - conditionally log lost audit message event
+  * @message: the message stating reason for lost audit message
+@@ -402,6 +414,8 @@ static int audit_log_config_change(char
+ 	struct audit_buffer *ab;
+ 	int rc = 0;
+ 
++	kpatch_audit_check();
++
+ 	ab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);
+ 	if (unlikely(!ab))
+ 		return rc;
diff --git a/test/integration/rhel-8.4/gcc-static-local-var-6.patch b/test/integration/rhel-8.4/gcc-static-local-var-6.patch
new file mode 100644
index 0000000..9163e02
--- /dev/null
+++ b/test/integration/rhel-8.4/gcc-static-local-var-6.patch
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/net/ipv6/netfilter.c src/net/ipv6/netfilter.c
+--- src.orig/net/ipv6/netfilter.c	2021-04-20 11:04:27.369102230 -0400
++++ src/net/ipv6/netfilter.c	2021-04-20 11:04:56.097174309 -0400
+@@ -86,6 +86,8 @@ static int nf_ip6_reroute(struct sk_buff
+ 	return 0;
+ }
+ 
++#include "kpatch-macros.h"
++
+ int __nf_ip6_route(struct net *net, struct dst_entry **dst,
+ 		   struct flowi *fl, bool strict)
+ {
+@@ -99,6 +101,9 @@ int __nf_ip6_route(struct net *net, stru
+ 	struct dst_entry *result;
+ 	int err;
+ 
++	if (!jiffies)
++		printk("kpatch nf_ip6_route foo\n");
++
+ 	result = ip6_route_output(net, sk, &fl->u.ip6);
+ 	err = result->error;
+ 	if (err)
diff --git a/test/integration/rhel-8.4/macro-callbacks.patch b/test/integration/rhel-8.4/macro-callbacks.patch
new file mode 100644
index 0000000..68033a3
--- /dev/null
+++ b/test/integration/rhel-8.4/macro-callbacks.patch
@@ -0,0 +1,155 @@
+diff -Nupr src.orig/drivers/input/joydev.c src/drivers/input/joydev.c
+--- src.orig/drivers/input/joydev.c	2021-04-20 11:04:26.086099011 -0400
++++ src/drivers/input/joydev.c	2021-04-20 11:04:58.399180085 -0400
+@@ -1084,3 +1084,47 @@ static void __exit joydev_exit(void)
+ 
+ module_init(joydev_init);
+ module_exit(joydev_exit);
++
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0; /* return -ENODEV; */
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/drivers/input/misc/pcspkr.c src/drivers/input/misc/pcspkr.c
+--- src.orig/drivers/input/misc/pcspkr.c	2021-04-20 11:04:26.090099021 -0400
++++ src/drivers/input/misc/pcspkr.c	2021-04-20 11:04:58.399180085 -0400
+@@ -133,3 +133,46 @@ static struct platform_driver pcspkr_pla
+ };
+ module_platform_driver(pcspkr_platform_driver);
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
+diff -Nupr src.orig/fs/aio.c src/fs/aio.c
+--- src.orig/fs/aio.c	2021-04-20 11:04:26.671100479 -0400
++++ src/fs/aio.c	2021-04-20 11:04:58.399180085 -0400
+@@ -49,6 +49,50 @@
+ 
+ #define KIOCB_KEY		0
+ 
++#include <linux/module.h>
++#include "kpatch-macros.h"
++
++static const char *const module_state[] = {
++	[MODULE_STATE_LIVE]	= "[MODULE_STATE_LIVE] Normal state",
++	[MODULE_STATE_COMING]	= "[MODULE_STATE_COMING] Full formed, running module_init",
++	[MODULE_STATE_GOING]	= "[MODULE_STATE_GOING] Going away",
++	[MODULE_STATE_UNFORMED]	= "[MODULE_STATE_UNFORMED] Still setting it up",
++};
++
++static void callback_info(const char *callback, patch_object *obj)
++{
++	if (obj->mod)
++		pr_info("%s: %s -> %s\n", callback, obj->mod->name,
++			module_state[obj->mod->state]);
++	else
++		pr_info("%s: vmlinux\n", callback);
++}
++
++static int pre_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++	return 0;
++}
++KPATCH_PRE_PATCH_CALLBACK(pre_patch_callback);
++
++static void post_patch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_PATCH_CALLBACK(post_patch_callback);
++
++static void pre_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_PRE_UNPATCH_CALLBACK(pre_unpatch_callback);
++
++static void post_unpatch_callback(patch_object *obj)
++{
++	callback_info(__func__, obj);
++}
++KPATCH_POST_UNPATCH_CALLBACK(post_unpatch_callback);
++
+ #define AIO_RING_MAGIC			0xa10a10a1
+ #define AIO_RING_COMPAT_FEATURES	1
+ #define AIO_RING_INCOMPAT_FEATURES	0
diff --git a/test/integration/rhel-8.4/macro-printk.patch b/test/integration/rhel-8.4/macro-printk.patch
new file mode 100644
index 0000000..f5f9004
--- /dev/null
+++ b/test/integration/rhel-8.4/macro-printk.patch
@@ -0,0 +1,149 @@
+diff -Nupr src.orig/net/ipv4/fib_frontend.c src/net/ipv4/fib_frontend.c
+--- src.orig/net/ipv4/fib_frontend.c	2021-04-20 11:04:27.363102215 -0400
++++ src/net/ipv4/fib_frontend.c	2021-04-20 11:05:00.587185575 -0400
+@@ -790,6 +790,7 @@ errout:
+ 	return err;
+ }
+ 
++#include "kpatch-macros.h"
+ static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			     struct netlink_ext_ack *extack)
+ {
+@@ -811,6 +812,7 @@ static int inet_rtm_newroute(struct sk_b
+ 	err = fib_table_insert(net, tb, &cfg, extack);
+ 	if (!err && cfg.fc_type == RTN_LOCAL)
+ 		net->ipv4.fib_has_custom_local_routes = true;
++	KPATCH_PRINTK("[inet_rtm_newroute]: err is %d\n", err);
+ errout:
+ 	return err;
+ }
+diff -Nupr src.orig/net/ipv4/fib_semantics.c src/net/ipv4/fib_semantics.c
+--- src.orig/net/ipv4/fib_semantics.c	2021-04-20 11:04:27.363102215 -0400
++++ src/net/ipv4/fib_semantics.c	2021-04-20 11:05:00.588185577 -0400
+@@ -1023,6 +1023,7 @@ static bool fib_valid_prefsrc(struct fib
+ 	return true;
+ }
+ 
++#include "kpatch-macros.h"
+ struct fib_info *fib_create_info(struct fib_config *cfg,
+ 				 struct netlink_ext_ack *extack)
+ {
+@@ -1056,6 +1057,7 @@ struct fib_info *fib_create_info(struct
+ #endif
+ 
+ 	err = -ENOBUFS;
++	KPATCH_PRINTK("[fib_create_info]: create error err is %d\n",err);
+ 	if (fib_info_cnt >= fib_info_hash_size) {
+ 		unsigned int new_size = fib_info_hash_size << 1;
+ 		struct hlist_head *new_info_hash;
+@@ -1076,6 +1078,7 @@ struct fib_info *fib_create_info(struct
+ 		if (!fib_info_hash_size)
+ 			goto failure;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 2 create error err is %d\n",err);
+ 
+ 	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
+ 	if (!fi)
+@@ -1089,6 +1092,8 @@ struct fib_info *fib_create_info(struct
+ 	}
+ 
+ 	fib_info_cnt++;
++	KPATCH_PRINTK("[fib_create_info]: 3 create error err is %d\n",err);
++
+ 	fi->fib_net = net;
+ 	fi->fib_protocol = cfg->fc_protocol;
+ 	fi->fib_scope = cfg->fc_scope;
+@@ -1144,9 +1149,11 @@ struct fib_info *fib_create_info(struct
+ 					       "LWT encap type not specified");
+ 				goto err_inval;
+ 			}
++			KPATCH_PRINTK("[fib_create_info]: 4 create error err is %d\n",err);
+ 			err = lwtunnel_build_state(cfg->fc_encap_type,
+ 						   cfg->fc_encap, AF_INET, cfg,
+ 						   &lwtstate, extack);
++			KPATCH_PRINTK("[fib_create_info]: 5 create error err is %d\n",err);
+ 			if (err)
+ 				goto failure;
+ 
+@@ -1164,6 +1171,7 @@ struct fib_info *fib_create_info(struct
+ 		nh->nh_weight = 1;
+ #endif
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 6 create error err is %d\n",err);
+ 
+ 	if (fib_props[cfg->fc_type].error) {
+ 		if (cfg->fc_gw || cfg->fc_oif || cfg->fc_mp) {
+@@ -1185,6 +1193,7 @@ struct fib_info *fib_create_info(struct
+ 			goto err_inval;
+ 		}
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 7 create error err is %d\n",err);
+ 
+ 	if (cfg->fc_scope > RT_SCOPE_HOST) {
+ 		NL_SET_ERR_MSG(extack, "Invalid scope");
+@@ -1223,6 +1232,7 @@ struct fib_info *fib_create_info(struct
+ 		if (linkdown == fi->fib_nhs)
+ 			fi->fib_flags |= RTNH_F_LINKDOWN;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 8 create error err is %d\n",err);
+ 
+ 	if (fi->fib_prefsrc && !fib_valid_prefsrc(cfg, fi->fib_prefsrc)) {
+ 		NL_SET_ERR_MSG(extack, "Invalid prefsrc address");
+@@ -1232,6 +1242,7 @@ struct fib_info *fib_create_info(struct
+ 	change_nexthops(fi) {
+ 		fib_info_update_nh_saddr(net, nexthop_nh);
+ 	} endfor_nexthops(fi)
++	KPATCH_PRINTK("[fib_create_info]: 9 create error err is %d\n",err);
+ 
+ 	fib_rebalance(fi);
+ 
+@@ -1243,6 +1254,7 @@ link_it:
+ 		ofi->fib_treeref++;
+ 		return ofi;
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 10 create error err is %d\n",err);
+ 
+ 	fi->fib_treeref++;
+ 	refcount_set(&fi->fib_clntref, 1);
+@@ -1266,6 +1278,7 @@ link_it:
+ 		hlist_add_head(&nexthop_nh->nh_hash, head);
+ 	} endfor_nexthops(fi)
+ 	spin_unlock_bh(&fib_info_lock);
++	KPATCH_PRINTK("[fib_create_info]: 11 create error err is %d\n",err);
+ 	return fi;
+ 
+ err_inval:
+@@ -1276,6 +1289,7 @@ failure:
+ 		fi->fib_dead = 1;
+ 		free_fib_info(fi);
+ 	}
++	KPATCH_PRINTK("[fib_create_info]: 12 create error err is %d\n",err);
+ 
+ 	return ERR_PTR(err);
+ }
+diff -Nupr src.orig/net/ipv4/fib_trie.c src/net/ipv4/fib_trie.c
+--- src.orig/net/ipv4/fib_trie.c	2021-04-20 11:04:27.363102215 -0400
++++ src/net/ipv4/fib_trie.c	2021-04-20 11:05:00.588185577 -0400
+@@ -1174,6 +1174,7 @@ static void fib_remove_alias(struct trie
+ 			     struct key_vector *l, struct fib_alias *old);
+ 
+ /* Caller must hold RTNL. */
++#include "kpatch-macros.h"
+ int fib_table_insert(struct net *net, struct fib_table *tb,
+ 		     struct fib_config *cfg, struct netlink_ext_ack *extack)
+ {
+@@ -1195,11 +1196,14 @@ int fib_table_insert(struct net *net, st
+ 
+ 	pr_debug("Insert table=%u %08x/%d\n", tb->tb_id, key, plen);
+ 
++	KPATCH_PRINTK("[fib_table_insert]: start\n");
+ 	fi = fib_create_info(cfg, extack);
+ 	if (IS_ERR(fi)) {
+ 		err = PTR_ERR(fi);
++		KPATCH_PRINTK("[fib_table_insert]: create error err is %d\n",err);
+ 		goto err;
+ 	}
++	KPATCH_PRINTK("[fib_table_insert]: cross\n");
+ 
+ 	l = fib_find_node(t, &tp, key);
+ 	fa = l ? fib_find_alias(&l->leaf, slen, tos, fi->fib_priority,
diff --git a/test/integration/rhel-8.4/meminfo-init-FAIL.patch b/test/integration/rhel-8.4/meminfo-init-FAIL.patch
new file mode 100644
index 0000000..abd02dc
--- /dev/null
+++ b/test/integration/rhel-8.4/meminfo-init-FAIL.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/meminfo.c	2021-04-20 11:05:05.090196873 -0400
+@@ -156,6 +156,7 @@ static int meminfo_proc_show(struct seq_
+ 
+ static int __init proc_meminfo_init(void)
+ {
++	printk("a\n");
+ 	proc_create_single("meminfo", 0, NULL, meminfo_proc_show);
+ 	return 0;
+ }
diff --git a/test/integration/rhel-8.4/meminfo-init2-FAIL.patch b/test/integration/rhel-8.4/meminfo-init2-FAIL.patch
new file mode 100644
index 0000000..b261bab
--- /dev/null
+++ b/test/integration/rhel-8.4/meminfo-init2-FAIL.patch
@@ -0,0 +1,19 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/meminfo.c	2021-04-20 11:05:02.874191313 -0400
+@@ -41,6 +41,7 @@ static int meminfo_proc_show(struct seq_
+ 	unsigned long sreclaimable, sunreclaim;
+ 	int lru;
+ 
++	printk("a\n");
+ 	si_meminfo(&i);
+ 	si_swapinfo(&i);
+ 	committed = percpu_counter_read_positive(&vm_committed_as);
+@@ -156,6 +157,7 @@ static int meminfo_proc_show(struct seq_
+ 
+ static int __init proc_meminfo_init(void)
+ {
++	printk("a\n");
+ 	proc_create_single("meminfo", 0, NULL, meminfo_proc_show);
+ 	return 0;
+ }
diff --git a/test/integration/rhel-8.4/meminfo-string-LOADED.test b/test/integration/rhel-8.4/meminfo-string-LOADED.test
new file mode 100755
index 0000000..10dc20b
--- /dev/null
+++ b/test/integration/rhel-8.4/meminfo-string-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep VMALLOCCHUNK /proc/meminfo
diff --git a/test/integration/rhel-8.4/meminfo-string.patch b/test/integration/rhel-8.4/meminfo-string.patch
new file mode 100644
index 0000000..d07429a
--- /dev/null
+++ b/test/integration/rhel-8.4/meminfo-string.patch
@@ -0,0 +1,12 @@
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/meminfo.c	2021-04-20 11:05:07.263202325 -0400
+@@ -120,7 +120,7 @@ static int meminfo_proc_show(struct seq_
+ 	seq_printf(m, "VmallocTotal:   %8lu kB\n",
+ 		   (unsigned long)VMALLOC_TOTAL >> 10);
+ 	show_val_kb(m, "VmallocUsed:    ", 0ul);
+-	show_val_kb(m, "VmallocChunk:   ", 0ul);
++	show_val_kb(m, "VMALLOCCHUNK:   ", 0ul);
+ 	show_val_kb(m, "Percpu:         ", pcpu_nr_pages());
+ 
+ #ifdef CONFIG_MEMORY_FAILURE
diff --git a/test/integration/rhel-8.4/module-LOADED.test b/test/integration/rhel-8.4/module-LOADED.test
new file mode 100755
index 0000000..72bb852
--- /dev/null
+++ b/test/integration/rhel-8.4/module-LOADED.test
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+set -o errexit
+
+sudo modprobe nfsd
+sleep 5
+grep -q kpatch /proc/fs/nfs/exports
+
+# TODO: This will trigger a printk on newer kernels which have the .klp.arch
+# removal.  Don't actually do the grep until running on a newer kernel.
+echo "file fs/nfsd/export.c +p" > /sys/kernel/debug/dynamic_debug/control
+cat /proc/fs/nfs/exports > /dev/null
+# dmesg | grep -q "kpatch: pr_debug"
diff --git a/test/integration/rhel-8.4/module.patch b/test/integration/rhel-8.4/module.patch
new file mode 100644
index 0000000..812dba8
--- /dev/null
+++ b/test/integration/rhel-8.4/module.patch
@@ -0,0 +1,85 @@
+From 08078d00ab1749a6f84148a00d8d26572af4ec97 Mon Sep 17 00:00:00 2001
+Message-Id: <08078d00ab1749a6f84148a00d8d26572af4ec97.1586900628.git.jpoimboe@redhat.com>
+From: Josh Poimboeuf <jpoimboe@redhat.com>
+Date: Tue, 14 Apr 2020 15:17:51 -0500
+Subject: [PATCH] kpatch module integration test
+
+This tests several things related to the patching of modules:
+
+- 'kpatch_string' tests the referencing of a symbol which is outside the
+  .o, but inside the patch module.
+
+- alternatives patching (.altinstructions)
+
+- paravirt patching (.parainstructions)
+
+- jump labels (5.8+ kernels only) -- including dynamic printk
+
+Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
+---
+ fs/nfsd/export.c         | 30 ++++++++++++++++++++++++++++++
+ net/netlink/af_netlink.c |  5 +++++
+ 2 files changed, 35 insertions(+)
+
+diff -Nupr src.orig/fs/nfsd/export.c src/fs/nfsd/export.c
+--- src.orig/fs/nfsd/export.c	2021-04-20 11:04:26.703100559 -0400
++++ src/fs/nfsd/export.c	2021-04-20 11:05:09.399207684 -0400
+@@ -1221,15 +1221,45 @@ static void exp_flags(struct seq_file *m
+ 	}
+ }
+ 
++#include <linux/version.h>
++extern char *kpatch_string(void);
++
+ static int e_show(struct seq_file *m, void *p)
+ {
+ 	struct cache_head *cp = p;
+ 	struct svc_export *exp = container_of(cp, struct svc_export, h);
+ 	struct cache_detail *cd = m->private;
++#ifdef CONFIG_X86_64
++	unsigned long long sched_clock;
++
++	alternative("ud2", "call yield", X86_FEATURE_ALWAYS);
++	alternative("call yield", "ud2", X86_FEATURE_IA64);
++
++	sched_clock = paravirt_sched_clock();
++	if (!jiffies)
++		printk("kpatch: sched_clock: %llu\n", sched_clock);
++#endif
++
++	pr_debug("kpatch: pr_debug() test\n");
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
++{
++	static DEFINE_STATIC_KEY_TRUE(kpatch_key);
++
++	if (static_branch_unlikely(&mcsafe_key))
++		printk("kpatch: mcsafe_key\n");
++
++	BUG_ON(!static_branch_likely(&kpatch_key));
++	static_branch_disable(&kpatch_key);
++	BUG_ON(static_branch_likely(&kpatch_key));
++	static_branch_enable(&kpatch_key);
++}
++#endif
+ 
+ 	if (p == SEQ_START_TOKEN) {
+ 		seq_puts(m, "# Version 1.1\n");
+ 		seq_puts(m, "# Path Client(Flags) # IPs\n");
++		seq_puts(m, kpatch_string());
+ 		return 0;
+ 	}
+ 
+diff -Nupr src.orig/net/netlink/af_netlink.c src/net/netlink/af_netlink.c
+--- src.orig/net/netlink/af_netlink.c	2021-04-20 11:04:27.385102270 -0400
++++ src/net/netlink/af_netlink.c	2021-04-20 11:05:09.399207684 -0400
+@@ -2879,4 +2879,9 @@ panic:
+ 	panic("netlink_init: Cannot allocate nl_table\n");
+ }
+ 
++char *kpatch_string(void)
++{
++	return "# kpatch\n";
++}
++
+ core_initcall(netlink_proto_init);
diff --git a/test/integration/rhel-8.4/multiple.test b/test/integration/rhel-8.4/multiple.test
new file mode 100755
index 0000000..7e4b352
--- /dev/null
+++ b/test/integration/rhel-8.4/multiple.test
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+SCRIPTDIR="$(readlink -f $(dirname $(type -p $0)))"
+
+declare -a blacklist=(meminfo-string-LOADED.test)
+
+source ${SCRIPTDIR}/../common/multiple.template
diff --git a/test/integration/rhel-8.4/new-function.patch b/test/integration/rhel-8.4/new-function.patch
new file mode 100644
index 0000000..35b222e
--- /dev/null
+++ b/test/integration/rhel-8.4/new-function.patch
@@ -0,0 +1,25 @@
+diff -Nupr src.orig/drivers/tty/n_tty.c src/drivers/tty/n_tty.c
+--- src.orig/drivers/tty/n_tty.c	2021-04-20 11:04:26.603100308 -0400
++++ src/drivers/tty/n_tty.c	2021-04-20 11:05:11.672213387 -0400
+@@ -2296,7 +2296,7 @@ static ssize_t n_tty_read(struct tty_str
+  *		  lock themselves)
+  */
+ 
+-static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
++static ssize_t noinline kpatch_n_tty_write(struct tty_struct *tty, struct file *file,
+ 			   const unsigned char *buf, size_t nr)
+ {
+ 	const unsigned char *b = buf;
+@@ -2383,6 +2383,12 @@ break_out:
+ 	return (b - buf) ? b - buf : retval;
+ }
+ 
++static ssize_t __attribute__((optimize("-fno-optimize-sibling-calls"))) n_tty_write(struct tty_struct *tty, struct file *file,
++			   							     const unsigned char *buf, size_t nr)
++{
++	return kpatch_n_tty_write(tty, file, buf, nr);
++}
++
+ /**
+  *	n_tty_poll		-	poll method for N_TTY
+  *	@tty: terminal device
diff --git a/test/integration/rhel-8.4/new-globals.patch b/test/integration/rhel-8.4/new-globals.patch
new file mode 100644
index 0000000..1ab87c0
--- /dev/null
+++ b/test/integration/rhel-8.4/new-globals.patch
@@ -0,0 +1,34 @@
+diff -Nupr src.orig/fs/proc/cmdline.c src/fs/proc/cmdline.c
+--- src.orig/fs/proc/cmdline.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/cmdline.c	2021-04-20 11:05:13.847218845 -0400
+@@ -17,3 +17,10 @@ static int __init proc_cmdline_init(void
+ 	return 0;
+ }
+ fs_initcall(proc_cmdline_init);
++
++#include <linux/printk.h>
++void kpatch_print_message(void)
++{
++	if (!jiffies)
++		printk("hello there!\n");
++}
+diff -Nupr src.orig/fs/proc/meminfo.c src/fs/proc/meminfo.c
+--- src.orig/fs/proc/meminfo.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/meminfo.c	2021-04-20 11:05:13.847218845 -0400
+@@ -21,6 +21,8 @@
+ #include <asm/pgtable.h>
+ #include "internal.h"
+ 
++void kpatch_print_message(void);
++
+ void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
+ {
+ }
+@@ -57,6 +59,7 @@ static int meminfo_proc_show(struct seq_
+ 	sreclaimable = global_node_page_state_pages(NR_SLAB_RECLAIMABLE_B);
+ 	sunreclaim = global_node_page_state_pages(NR_SLAB_UNRECLAIMABLE_B);
+ 
++	kpatch_print_message();
+ 	show_val_kb(m, "MemTotal:       ", i.totalram);
+ 	show_val_kb(m, "MemFree:        ", i.freeram);
+ 	show_val_kb(m, "MemAvailable:   ", available);
diff --git a/test/integration/rhel-8.4/parainstructions-section.patch b/test/integration/rhel-8.4/parainstructions-section.patch
new file mode 100644
index 0000000..843ee94
--- /dev/null
+++ b/test/integration/rhel-8.4/parainstructions-section.patch
@@ -0,0 +1,11 @@
+diff -Nupr src.orig/fs/proc/generic.c src/fs/proc/generic.c
+--- src.orig/fs/proc/generic.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/generic.c	2021-04-20 11:05:16.189224721 -0400
+@@ -205,6 +205,7 @@ int proc_alloc_inum(unsigned int *inum)
+ {
+ 	int i;
+ 
++	printk("kpatch-test: testing change to .parainstructions section\n");
+ 	i = ida_simple_get(&proc_inum_ida, 0, UINT_MAX - PROC_DYNAMIC_FIRST + 1,
+ 			   GFP_KERNEL);
+ 	if (i < 0)
diff --git a/test/integration/rhel-8.4/shadow-newpid-LOADED.test b/test/integration/rhel-8.4/shadow-newpid-LOADED.test
new file mode 100755
index 0000000..c07d112
--- /dev/null
+++ b/test/integration/rhel-8.4/shadow-newpid-LOADED.test
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+grep -q newpid: /proc/$$/status
diff --git a/test/integration/rhel-8.4/shadow-newpid.patch b/test/integration/rhel-8.4/shadow-newpid.patch
new file mode 100644
index 0000000..3292906
--- /dev/null
+++ b/test/integration/rhel-8.4/shadow-newpid.patch
@@ -0,0 +1,75 @@
+diff -Nupr src.orig/fs/proc/array.c src/fs/proc/array.c
+--- src.orig/fs/proc/array.c	2021-04-20 11:04:26.717100594 -0400
++++ src/fs/proc/array.c	2021-04-20 11:05:18.430230343 -0400
+@@ -370,12 +370,19 @@ static inline void task_seccomp(struct s
+ 	seq_putc(m, '\n');
+ }
+ 
++#include <linux/livepatch.h>
+ static inline void task_context_switch_counts(struct seq_file *m,
+ 						struct task_struct *p)
+ {
++	int *newpid;
++
+ 	seq_put_decimal_ull(m, "voluntary_ctxt_switches:\t", p->nvcsw);
+ 	seq_put_decimal_ull(m, "\nnonvoluntary_ctxt_switches:\t", p->nivcsw);
+ 	seq_putc(m, '\n');
++
++	newpid = klp_shadow_get(p, 0);
++	if (newpid)
++		seq_printf(m, "newpid:\t%d\n", *newpid);
+ }
+ 
+ static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
+diff -Nupr src.orig/kernel/exit.c src/kernel/exit.c
+--- src.orig/kernel/exit.c	2021-04-20 11:04:27.314102092 -0400
++++ src/kernel/exit.c	2021-04-20 11:05:18.430230343 -0400
+@@ -701,6 +701,7 @@ static void check_stack_usage(void)
+ static inline void check_stack_usage(void) {}
+ #endif
+ 
++#include <linux/livepatch.h>
+ void __noreturn do_exit(long code)
+ {
+ 	struct task_struct *tsk = current;
+@@ -794,6 +795,8 @@ void __noreturn do_exit(long code)
+ 	exit_task_work(tsk);
+ 	exit_thread(tsk);
+ 
++	klp_shadow_free(tsk, 0, NULL);
++
+ 	/*
+ 	 * Flush inherited counters to the parent - before the parent
+ 	 * gets woken up by child-exit notifications.
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2021-04-20 11:04:27.315102095 -0400
++++ src/kernel/fork.c	2021-04-20 11:05:18.431230346 -0400
+@@ -2222,6 +2222,7 @@ struct mm_struct *copy_init_mm(void)
+  * It copies the process, and if successful kick-starts
+  * it and waits for it to finish using the VM if required.
+  */
++#include <linux/livepatch.h>
+ long _do_fork(unsigned long clone_flags,
+ 	      unsigned long stack_start,
+ 	      unsigned long stack_size,
+@@ -2234,6 +2235,8 @@ long _do_fork(unsigned long clone_flags,
+ 	struct task_struct *p;
+ 	int trace = 0;
+ 	long nr;
++	int *newpid;
++	static int ctr = 0;
+ 
+ 	/*
+ 	 * Determine whether and which event to report to ptracer.  When
+@@ -2260,6 +2263,11 @@ long _do_fork(unsigned long clone_flags,
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
++	newpid = klp_shadow_get_or_alloc(p, 0, sizeof(*newpid), GFP_KERNEL,
++					 NULL, NULL);
++	if (newpid)
++		*newpid = ctr++;
++
+ 	/*
+ 	 * Do this prior waking up the new thread - the thread pointer
+ 	 * might get invalid after that point, if the thread exits quickly.
diff --git a/test/integration/rhel-8.4/smp-locks-section.patch b/test/integration/rhel-8.4/smp-locks-section.patch
new file mode 100644
index 0000000..d6273a5
--- /dev/null
+++ b/test/integration/rhel-8.4/smp-locks-section.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/drivers/tty/tty_buffer.c src/drivers/tty/tty_buffer.c
+--- src.orig/drivers/tty/tty_buffer.c	2021-04-20 11:04:26.609100323 -0400
++++ src/drivers/tty/tty_buffer.c	2021-04-20 11:05:20.584235748 -0400
+@@ -256,6 +256,9 @@ static int __tty_buffer_request_room(str
+ 	struct tty_buffer *b, *n;
+ 	int left, change;
+ 
++	if (!size)
++		printk("kpatch-test: testing .smp_locks section changes\n");
++
+ 	b = buf->tail;
+ 	if (b->flags & TTYB_NORMAL)
+ 		left = 2 * b->size - b->used;
diff --git a/test/integration/rhel-8.4/special-static.patch b/test/integration/rhel-8.4/special-static.patch
new file mode 100644
index 0000000..8c1e197
--- /dev/null
+++ b/test/integration/rhel-8.4/special-static.patch
@@ -0,0 +1,22 @@
+diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
+--- src.orig/kernel/fork.c	2021-04-20 11:04:27.315102095 -0400
++++ src/kernel/fork.c	2021-04-20 11:05:23.010241835 -0400
+@@ -1554,10 +1554,18 @@ static void posix_cpu_timers_init_group(
+ 	posix_cputimers_group_init(pct, cpu_limit);
+ }
+ 
++void kpatch_foo(void)
++{
++	if (!jiffies)
++		printk("kpatch copy signal\n");
++}
++
+ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
+ {
+ 	struct signal_struct *sig;
+ 
++	kpatch_foo();
++
+ 	if (clone_flags & CLONE_THREAD)
+ 		return 0;
+ 
diff --git a/test/integration/rhel-8.4/symvers-disagreement-FAIL.patch b/test/integration/rhel-8.4/symvers-disagreement-FAIL.patch
new file mode 100644
index 0000000..cd62d06
--- /dev/null
+++ b/test/integration/rhel-8.4/symvers-disagreement-FAIL.patch
@@ -0,0 +1,46 @@
+From 2d6b7bce089e52563bd9c67df62f48e90b48047d Mon Sep 17 00:00:00 2001
+From: Julien Thierry <jthierry@redhat.com>
+Date: Wed, 6 May 2020 14:30:57 +0100
+Subject: [PATCH] Symbol version change
+
+This change causes:
+1) Some exported symbols in drivers/base/core.c to see their CRCs
+   change.
+2) Changes usb_get_dev() referencing a get_device() whose CRC has
+   changed, causing the symbol and the new CRC to be included in the
+   __version section of the final module.
+
+This makes the final module unloadable for the target kernel.
+
+See "Exported symbol versioning" of the patch author guide for more
+detail.
+
+---
+ drivers/base/core.c    | 2 ++
+ drivers/usb/core/usb.c | 2 ++
+ 2 files changed, 4 insertions(+)
+
+diff -Nupr src.orig/drivers/base/core.c src/drivers/base/core.c
+--- src.orig/drivers/base/core.c	2021-04-20 11:04:25.703098050 -0400
++++ src/drivers/base/core.c	2021-04-20 11:05:25.287247548 -0400
+@@ -31,6 +31,8 @@
+ #include "base.h"
+ #include "power/power.h"
+ 
++#include <linux/blktrace_api.h>
++
+ #ifdef CONFIG_SYSFS_DEPRECATED
+ #ifdef CONFIG_SYSFS_DEPRECATED_V2
+ long sysfs_deprecated = 1;
+diff -Nupr src.orig/drivers/usb/core/usb.c src/drivers/usb/core/usb.c
+--- src.orig/drivers/usb/core/usb.c	2021-04-20 11:04:26.613100333 -0400
++++ src/drivers/usb/core/usb.c	2021-04-20 11:05:25.287247548 -0400
+@@ -693,6 +693,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_dev);
+  */
+ struct usb_device *usb_get_dev(struct usb_device *dev)
+ {
++	barrier();
++
+ 	if (dev)
+ 		get_device(&dev->dev);
+ 	return dev;
diff --git a/test/integration/rhel-8.4/tracepoints-section.patch b/test/integration/rhel-8.4/tracepoints-section.patch
new file mode 100644
index 0000000..5af1b46
--- /dev/null
+++ b/test/integration/rhel-8.4/tracepoints-section.patch
@@ -0,0 +1,13 @@
+diff -Nupr src.orig/kernel/time/timer.c src/kernel/time/timer.c
+--- src.orig/kernel/time/timer.c	2021-04-20 11:04:27.325102120 -0400
++++ src/kernel/time/timer.c	2021-04-20 11:05:27.596253341 -0400
+@@ -1751,6 +1751,9 @@ static __latent_entropy void run_timer_s
+ {
+ 	struct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);
+ 
++	if (!base)
++		printk("kpatch-test: testing __tracepoints section changes\n");
++
+ 	__run_timers(base);
+ 	if (IS_ENABLED(CONFIG_NO_HZ_COMMON))
+ 		__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));
diff --git a/test/integration/rhel-8.4/warn-detect-FAIL.patch b/test/integration/rhel-8.4/warn-detect-FAIL.patch
new file mode 100644
index 0000000..6c1e7ac
--- /dev/null
+++ b/test/integration/rhel-8.4/warn-detect-FAIL.patch
@@ -0,0 +1,9 @@
+diff -Nupr src.orig/arch/x86/kvm/x86.c src/arch/x86/kvm/x86.c
+--- src.orig/arch/x86/kvm/x86.c	2021-04-20 11:04:27.273101989 -0400
++++ src/arch/x86/kvm/x86.c	2021-04-20 11:05:29.870259047 -0400
+@@ -1,4 +1,5 @@
+ // SPDX-License-Identifier: GPL-2.0-only
++
+ /*
+  * Kernel-based Virtual Machine driver for Linux
+  *
diff --git a/test/integration/vm-integration-run b/test/integration/vm-integration-run
index 2cdcb5b..d5cb560 100755
--- a/test/integration/vm-integration-run
+++ b/test/integration/vm-integration-run
@@ -64,6 +64,7 @@ if [[ -d "${HOME}/src" && -f "${HOME}/src/version" ]]; then
   mv "${HOME}/src" "${HOME}/.kpatch/"
 fi
 
+# shellcheck disable=SC1091
 source /etc/os-release
 
 if [[ "${NAME}" == "Fedora" ]] && [[ "${VERSION_ID}" -lt 30 ]]; then
diff --git a/test/unit/objs b/test/unit/objs
index 34d0a61..365ce3a 160000
--- a/test/unit/objs
+++ b/test/unit/objs
@@ -1 +1 @@
-Subproject commit 34d0a61ce8dc7da23e3cb47de6a8eee30484638c
+Subproject commit 365ce3af2ba7258d43982028b22d148f5c4686ac
-- 
2.42.0

